diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index dffb855..d720abe 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -18,7 +18,7 @@ config CRYPTO_DEV_PADLOCK
 	  (so called VIA PadLock ACE, Advanced Cryptography Engine)
 	  that provides instructions for very fast cryptographic
 	  operations with supported algorithms.
-	  
+
 	  The instructions are used only when the CPU supports them.
 	  Otherwise software encryption is used.
 
@@ -386,4 +386,11 @@ config CRYPTO_DEV_ATMEL_SHA
 	  To compile this driver as a module, choose M here: the module
 	  will be called atmel-sha.
 
+config CRYPTO_DEV_MTK_AES
+	tristate "Support for MediaTek AES Engine "
+	depends on RALINK_MT7628
+	help
+	 Turn on the configuration will include MediaTek AES Engine driver.
+
+
 endif # CRYPTO_HW
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 38ce13d..aec0a95 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_CRYPTO_DEV_NX) += nx/
 obj-$(CONFIG_CRYPTO_DEV_ATMEL_AES) += atmel-aes.o
 obj-$(CONFIG_CRYPTO_DEV_ATMEL_TDES) += atmel-tdes.o
 obj-$(CONFIG_CRYPTO_DEV_ATMEL_SHA) += atmel-sha.o
+obj-$(CONFIG_CRYPTO_DEV_MTK_AES) += aes_engine/
diff --git a/drivers/crypto/aes_engine/Makefile b/drivers/crypto/aes_engine/Makefile
new file mode 100755
index 0000000..392684a
--- /dev/null
+++ b/drivers/crypto/aes_engine/Makefile
@@ -0,0 +1,59 @@
+
+# Make sure that ARCH, KERNEL_DIR and CROSS_COMPILE are set
+
+ifndef KERNEL_DIR
+  ERROR_KERNEL_DIR_NOT_SET:=YES
+endif
+
+
+ifndef ARCH
+  ERROR_ARCH_NOT_SET:=YES
+endif
+
+PWD :=drivers/crypto/aes_engine
+PATH_BUILD=$(PWD)
+
+# Include Paths
+INCLUDE_FLAGS_ALL:= \
+  $(INCLUDE_APP)
+
+
+# Compiler Flags
+WARNING_FLAGS=
+DEBUG_FLAGS=-O2
+CODE_COVERAGE_FLAGS=
+PROFILING_FLAGS=
+BACKWARD_COMPATIBILITY_FLAGS=
+
+EXTRA_CFLAGS += $(BACKWARD_COMPATIBILITY_FLAGS)
+EXTRA_CFLAGS += $(INCLUDE_FLAGS_ALL)
+EXTRA_CFLAGS += $(WARNING_FLAGS)
+EXTRA_CFLAGS += $(DEBUG_FLAGS)
+EXTRA_CFLAGS += $(PROFILING_FLAGS)
+
+
+.PHONY = clean clean_module
+
+obj-m	+= mtk_aes.o
+mtk_aes-objs:= \
+	aes_engine.o	\
+	mcrypto_aes_api.o
+
+#mtk_aes-objs+= \
+	aes128_ciphertext.o	\
+	aes128_plaintext.o
+
+clean:	clean_module
+
+clean_module:
+	# this is run in $PATH_BUILD where the Makefile resides
+	find . \( -name "*.o" -o -name ".*.cmd" -o -name "*.bak" \) -type f -print | xargs rm -f
+	rm -rf .tmp_versions
+	rm -f *.o  .*.cmd  .*.flags  *.mod.c  *.ko  *.symvers  *.markers  *.order
+
+# end of file
+#openssl enc -e -aes-128-cbc -in padlock-aes.c -out padlock-aes.c.aes -k 123456789 -iv 5a5aa5a5 -nosalt -P
+#openssl enc -e -aes-128-cbc -in padlock-aes.c -out padlock-aes.c.aes -k 123456789 -iv 5a5aa5a5 -nosalt
+#openssl enc -d -aes-128-cbc -in padlock-aes.c.aes -out padlock-aes.c.p -k 123456789 -iv 5a5aa5a5 -nosalt
+#xxd -i padlock-aes.c >aes128_plaintext.c
+#xxd -i padlock-aes.c.aes >aes128_ciphertext.c
\ No newline at end of file
diff --git a/drivers/crypto/aes_engine/aes_engine.c b/drivers/crypto/aes_engine/aes_engine.c
new file mode 100755
index 0000000..2d6488a
--- /dev/null
+++ b/drivers/crypto/aes_engine/aes_engine.c
@@ -0,0 +1,1234 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/if_vlan.h>
+#include <linux/if_ether.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/rt2880/surfboardint.h>
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+#include <asm/rt2880/rt_mmap.h>
+#else
+#include <linux/libata-compat.h>
+#endif
+#include <linux/proc_fs.h>
+#include <linux/scatterlist.h>
+#include "aes_engine.h"
+#include "aes_pattern.h"
+#include "mcrypto_aes_api.h"
+
+int (*AesDoneIntCallback[NUM_AES_RX_DESC])(uint32_t);
+AES_userdata_type AES_userdata[NUM_AES_RX_DESC];
+
+static DECLARE_TASKLET( \
+AesRxTasklet, AesRxHandler, 0);
+
+typedef struct aes_engine_proc_t {
+    int put_count;
+    int isr_count;
+}aes_engine_proc_type;
+
+aes_engine_proc_type aes_engine_proc;
+
+uint8_t* sbuf[MAX_TEST_SEQ][MAX_SG_BUF];
+uint8_t* dbuf[MAX_TEST_SEQ][MAX_SG_BUF];
+uint8_t* tv_key[MAX_TEST_SEQ];
+
+struct scatterlist sg_src_test[MAX_TEST_SEQ][MAX_SG_BUF];
+struct scatterlist sg_dst_test[MAX_TEST_SEQ][MAX_SG_BUF];
+int tv_seq[MAX_TEST_SEQ];
+int tv_enc[MAX_TEST_SEQ];
+static unsigned long aes_tx_front_idx=0;
+static unsigned long aes_rx_front_idx=0;
+static unsigned long aes_tx_rear_idx=0;
+static unsigned long aes_rx_rear_idx=0;
+#ifdef DBG
+static unsigned long start_clk = 0, end_clk = 0;
+extern u32 mips_cpu_feq;
+#endif
+static struct proc_dir_entry *pProcDir   = NULL;
+static const int aes_key_len[3]={16,24,32};
+
+struct AesReqEntry AES_Entry;
+EXPORT_SYMBOL(AES_Entry);
+static int AesDescriptorInit(void);
+static void set_AES_glo_cfg(void);
+static void clear_AES_glo_cfg(void);
+static int aes_irq_enabled = 0;
+int aes_dbg_print = 0;
+static int burstlen = 4;
+
+int AesProcessScatterGather(
+	struct scatterlist* sg_src,
+	struct scatterlist* sg_dst,
+	uint32_t TransCount,
+	uint8_t*	Key,
+	uint8_t*	IV,
+	uint32_t	aes_mode
+	)
+{
+	int i=1;
+	int j=1;
+	int bUserData = 0;
+	struct scatterlist *next_dst, *next_src;
+	u8* Src0, *Dst0, *Dst1;
+	struct AES_txdesc* txdesc = NULL;
+	struct AES_rxdesc* rxdesc = NULL;
+	unsigned int aes_tx_scatter = 0;
+	unsigned int aes_rx_gather = 0;
+	unsigned int keylen = aes_key_len[aes_mode&0x03];
+	unsigned long flags = 0;
+	int rx_remain_len = 0;
+	int rx_desc_userdata = 0;
+
+	next_src = sg_src;
+	next_dst = sg_dst;
+
+	if (aes_irq_enabled == 0)
+		spin_lock_irqsave(&(AES_Entry.page_lock), flags);
+	//start_clk = read_c0_count();
+
+	while(next_src->length==0)
+	{
+		if(!sg_is_last(next_src))
+			next_src = sg_next(next_src);
+		else
+		{
+			printk("last src length=0\n");
+			goto EXIT;
+		}
+	}
+	while(next_dst->length==0)
+	{
+		if(!sg_is_last(next_dst))
+			next_dst = sg_next(next_dst);
+		else
+		{
+			printk("last dst length=0\n");
+			goto EXIT;
+		}
+	}
+
+	Src0 = sg_virt(next_src);
+	Dst0 = sg_virt(next_dst);
+
+	//RX descriptor
+	while(1)
+	{
+		aes_rx_gather  = (aes_rx_rear_idx + j) % NUM_AES_RX_DESC;
+
+		if (bUserData == 0)
+		{
+			rxdesc = &AES_Entry.AES_rx_ring0[aes_rx_gather];
+			DBGPRINT(DBG_HIGH, "AES set RX Desc[%u] Dst0=%08X, len=%d\n",(u32)aes_rx_gather, (u32)Dst0, next_dst->length);
+
+	        if (((u32)Dst0&0x3) || (next_dst->length&0x3))
+			{
+				bUserData = 1;
+				rx_desc_userdata = aes_rx_gather;
+				AES_userdata[aes_rx_gather].orig_SDP0 = (u32)Dst0;
+		        AES_userdata[aes_rx_gather].orig_SDL = next_dst->length;
+				rx_remain_len += next_dst->length;
+			}
+			else
+				AES_userdata[aes_rx_gather].new_SDP0 = 0;
+
+			if (bUserData == 0)
+			{
+				rxdesc->SDP0 = dma_map_single(NULL, Dst0, next_dst->length, PCI_DMA_FROMDEVICE);
+				rxdesc->aes_rxd_info2.SDL0 = next_dst->length;
+				rxdesc->aes_rxd_info2.DDONE = 0;
+
+	 		}
+		}
+		else
+		{
+			AES_userdata[aes_rx_gather].orig_SDP0 = (u32)Dst0;
+	        AES_userdata[aes_rx_gather].orig_SDL = next_dst->length;
+			rx_remain_len += next_dst->length;
+		}
+		if (sg_is_last(next_dst))
+		{
+			if (bUserData == 0)
+				rxdesc->aes_rxd_info2.LS0 = 1;
+			break;
+		}
+		else
+		{
+			if (bUserData == 0)
+				rxdesc->aes_rxd_info2.LS0 = 0;//1;
+		}
+
+		next_dst = sg_next(next_dst);
+		Dst0 = sg_virt(next_dst);
+		j++;
+	}
+
+  	if (bUserData == 0)
+		aes_rx_rear_idx = aes_rx_gather;
+	else
+	{
+		int new_SDL = rx_remain_len;
+        int rx_desc_start = rx_desc_userdata;
+        int remain_SDL = new_SDL;
+
+       	while (remain_SDL > 0)
+		{
+	        int SDL = (remain_SDL > (16384-4)) ? 16380 : remain_SDL;
+
+			Dst1 = kmalloc(SDL, GFP_DMA|GFP_ATOMIC);
+			DBGPRINT(DBG_HIGH, "RxDesc[%u] realloc len %d (%08X)\n", (u32)rx_desc_start, (u32)SDL, (u32)Dst1);
+			if (Dst1)
+			{
+       			rxdesc = &AES_Entry.AES_rx_ring0[rx_desc_start];
+
+	        	rxdesc->SDP0 = dma_map_single(NULL, Dst1, SDL, PCI_DMA_FROMDEVICE);
+				rxdesc->aes_rxd_info2.SDL0 = SDL;
+				rxdesc->aes_rxd_info2.DDONE = 0;
+				rxdesc->aes_rxd_info2.LS0 = 0;
+
+				AES_userdata[rx_desc_start].new_SDP0 = (u32)Dst1;
+				AES_userdata[rx_desc_start].new_SDL = SDL;
+				aes_rx_rear_idx = rx_desc_start;
+
+				remain_SDL-=SDL;
+				rx_desc_start = (rx_desc_start + 1) % NUM_AES_RX_DESC;
+			}
+			else
+			{
+				printk("Can't alloc AES Engine bounce buffer\n");
+				AES_userdata[rx_desc_start].new_SDP0 = 0;
+				//need free previous kmalloc buffer
+				break;
+			}
+		}
+		rxdesc->aes_rxd_info2.LS0 = 1;
+	}
+
+	while(1)
+	{
+		aes_tx_scatter = (aes_tx_rear_idx + i) % NUM_AES_TX_DESC;
+		DBGPRINT(DBG_HIGH, "AES set TX Desc[%u] Src0=%08X len=%d klen=%d\n",aes_tx_scatter, (u32)Src0, next_src->length,keylen);
+		txdesc = &AES_Entry.AES_tx_ring0[aes_tx_scatter];
+
+		txdesc->aes_txd_info4.value = aes_mode;
+
+		{
+			if (aes_mode&CBC_MODE)
+			{
+				txdesc->aes_txd_info4.value |= VALID_IV;
+				txdesc->aes_txd_info4.value |= RESTORE_IV;
+				if (i > 1)
+					txdesc->aes_txd_info4.value &= ~VALID_IV;
+
+				//first tx, set Key and IV
+				if (txdesc->aes_txd_info4.value & VALID_IV)
+				{
+					if (IV == NULL)
+						memset((void*)txdesc->IV, 0xFF, sizeof(uint32_t)*4);
+					else
+						memcpy((void*)txdesc->IV, IV, sizeof(uint32_t)*4);
+				}
+			}
+
+			if (i==1)
+			{
+				txdesc->SDP0 = ((uint32_t)Key & 0x1FFFFFFF);
+				if (bUserData)
+				{
+					txdesc->aes_txd_info4.value |= CARRY_USERDATA;
+					*(uint32_t*)&Key[keylen] = 	(uint32_t)AES_userdata;
+					txdesc->aes_txd_info2.SDL0 = ((keylen>>2)+1)*sizeof(uint32_t);	/* KEY + USER_DATA */
+				}
+				else
+					txdesc->aes_txd_info2.SDL0 = ((keylen>>2))*sizeof(uint32_t);	/* KEY */
+			}
+			else
+				txdesc->aes_txd_info2.SDL0 = 0;
+
+			txdesc->aes_txd_info2.LS0 = 0;//1;
+		}
+
+		txdesc->SDP1 = ((uint32_t)(Src0) & 0x1FFFFFFF);
+		txdesc->aes_txd_info2.SDL1 = next_src->length;
+		txdesc->aes_txd_info2.DDONE = 0;
+
+		dma_cache_wback_inv((unsigned long)(Src0), (next_src->length));
+		if (bUserData)
+			dma_cache_wback_inv((unsigned long)(Key), ((keylen>>2)+1)*sizeof(uint32_t));
+		else
+			dma_cache_wback_inv((unsigned long)(Key), ((keylen>>2))*sizeof(uint32_t));
+
+		if (sg_is_last(next_src))
+		{
+			DBGPRINT(DBG_HIGH, "[%d]LS1=1\n",i);
+			txdesc->aes_txd_info2.LS1 = 1;
+			break;
+		}
+		else
+			txdesc->aes_txd_info2.LS1 = 0;
+
+		next_src = sg_next(next_src);
+		Src0 = sg_virt(next_src);
+		i++;
+	}
+
+	aes_tx_rear_idx = aes_tx_scatter;
+
+
+
+  	for (i=0; i < NUM_AES_TX_DESC; i++) {
+#ifdef DBG
+		uint32_t* ptr = (uint32_t*)&AES_Entry.AES_tx_ring0[i];
+#endif
+		DBGPRINT(DBG_LOW, "Tx Ring%d[%08X] [f=%u r=%u]:\n",i,(u32)ptr, (u32)aes_tx_front_idx, (u32)aes_tx_rear_idx);
+		DBGPRINT(DBG_LOW, "%08X %08X %08X %08X\n",*ptr, *(ptr+1),*(ptr+2),*(ptr+3));
+		DBGPRINT(DBG_LOW, "%08X %08X %08X %08X\n",*(ptr+4), *(ptr+5),*(ptr+6),*(ptr+7));
+	}
+	DBGPRINT(DBG_LOW, "\n");
+	for (i=0; i < NUM_AES_RX_DESC; i++) {
+#ifdef DBG
+		uint32_t* ptr = (uint32_t*)&AES_Entry.AES_rx_ring0[i];
+#endif
+		DBGPRINT(DBG_LOW, "Rx Ring%d[%08X] [f=%u r=%u]:\n",i,(u32)ptr, (u32)aes_rx_front_idx, (u32)aes_rx_rear_idx);
+		DBGPRINT(DBG_LOW, "%08X %08X %08X %08X\n",*ptr, *(ptr+1),*(ptr+2),*(ptr+3));
+		DBGPRINT(DBG_LOW, "%08X %08X %08X %08X\n",*(ptr+4), *(ptr+5),*(ptr+6),*(ptr+7));
+	}
+	DBGPRINT(DBG_LOW, "\n");
+
+	DBGPRINT(DBG_MID, "AES_RX_CALC_IDX0 = %d\n",sysRegRead(AES_RX_CALC_IDX0));
+	DBGPRINT(DBG_MID, "AES_RX_DRX_IDX0 = %d\n",sysRegRead(AES_RX_DRX_IDX0));
+	DBGPRINT(DBG_MID, "AES_TX_CTX_IDX0 = %d\n",sysRegRead(AES_TX_CTX_IDX0));
+	DBGPRINT(DBG_MID, "AES_TX_DTX_IDX0 = %d\n",sysRegRead(AES_TX_DTX_IDX0));
+	DBGPRINT(DBG_MID, "AES_INFO = 0x%08X\n",sysRegRead(AES_INFO));
+	DBGPRINT(DBG_MID, "AES_GLO_CFG = 0x%08X\n",sysRegRead(AES_GLO_CFG));
+	DBGPRINT(DBG_MID, "AES_INT_STATUS = 0x%08X\n",sysRegRead(AES_INT_STATUS));
+	DBGPRINT(DBG_MID, "AES_GLO_CFG = 0x%08X\n",sysRegRead(AES_GLO_CFG));
+	DBGPRINT(DBG_MID, "AES_RST_CFG = 0x%08X\n",sysRegRead(AES_RST_CFG));
+
+	DBGPRINT(DBG_MID, "[*]TT [front=%u rear=%u]; RR [front=%u rear=%u]\n",(u32)aes_tx_front_idx, (u32)aes_tx_rear_idx,(u32)aes_rx_front_idx,(u32)aes_rx_rear_idx);
+#ifdef DBG
+	start_clk = read_c0_count();
+#endif
+	sysRegWrite(AES_TX_CTX_IDX0, cpu_to_le32((u32)((aes_tx_rear_idx+1)%NUM_AES_TX_DESC)));//tx start to move, 1->2->255->0->1
+
+EXIT:
+	DBGPRINT(DBG_MID, "[]<<<<< AES set DONE >>>>>][\n");
+
+	if (aes_irq_enabled == 0)
+		spin_unlock_irqrestore(&(AES_Entry.page_lock), flags);
+
+	if (aes_irq_enabled == 0)
+	{
+		AesRxHandler(0);
+
+#if 0
+		for (i=0; i < NUM_AES_TX_DESC; i++) {
+			memset(&AES_Entry.AES_tx_ring0[i], 0, sizeof(struct AES_txdesc));
+			AES_Entry.AES_tx_ring0[i].aes_txd_info2.LS0 = 0;
+			AES_Entry.AES_tx_ring0[i].aes_txd_info2.LS1 = 0;
+			AES_Entry.AES_tx_ring0[i].aes_txd_info2.DDONE = 1;
+		}
+
+		for (i = 0; i < NUM_AES_RX_DESC; i++) {
+			memset(&AES_Entry.AES_rx_ring0[i],0,sizeof(struct AES_rxdesc));
+			AES_Entry.AES_rx_ring0[i].aes_rxd_info2.DDONE = 0;
+			AES_Entry.AES_rx_ring0[i].aes_rxd_info2.LS0 = 0;
+		}
+
+		//TX0
+		//sysRegWrite(AES_TX_BASE_PTR0, phys_to_bus((u32) AES_Entry.phy_aes_tx_ring0));
+		//sysRegWrite(AES_TX_MAX_CNT0, cpu_to_le32((u32) NUM_AES_TX_DESC));
+		sysRegWrite(AES_TX_CTX_IDX0, 0);
+		aes_tx_front_idx = 0;
+		aes_tx_rear_idx = NUM_AES_TX_DESC-1;
+		sysRegWrite(AES_RST_CFG, AES_PST_DTX_IDX0);
+
+		//RX0
+		//sysRegWrite(AES_RX_BASE_PTR0, phys_to_bus((u32) AES_Entry.phy_aes_rx_ring0));
+		//sysRegWrite(AES_RX_MAX_CNT0,  cpu_to_le32((u32) NUM_AES_RX_DESC));
+
+		sysRegWrite(AES_RX_CALC_IDX0, cpu_to_le32((u32) (NUM_AES_RX_DESC - 1)));
+		sysRegRead(AES_RX_CALC_IDX0);
+		aes_rx_front_idx = 0;
+		aes_rx_rear_idx = NUM_AES_RX_DESC-1;
+		sysRegWrite(AES_RST_CFG, AES_PST_DRX_IDX0);
+#endif
+	}
+	return 0;
+}
+
+
+int AesKickEngine(void)
+{
+	int i;
+	unsigned long flags = 0;
+	DBGPRINT(DBG_MID, "AES Kick Off\n");
+
+	if (aes_irq_enabled == 1)
+		spin_lock_irqsave(&(AES_Entry.page_lock), flags);
+
+	for (i = 0; i < MAX_TEST_SEQ; i++)
+	{
+		int j;
+		int tv;
+		uint8_t* src;
+
+		if (tv_seq[i] < 0)
+			continue;
+
+		tv = tv_seq[i];
+		DBGPRINT(DBG_LOW, "IV=%08X\n",(u32)pattern[tv].iv);
+		for (j = 0; j < 16; j++)
+			DBGPRINT(DBG_LOW, "%02X ",pattern[tv].iv[j]);
+		DBGPRINT(DBG_LOW, "\n");
+
+		DBGPRINT(DBG_LOW, "KEY=%08X seq=%d tv=%u\n",(u32)tv_key[i],i,tv_seq[i]);
+		src = tv_key[i];
+		for (j = 0; j < aes_key_len[pattern[tv].mode&0x03]; j++, src++)
+			DBGPRINT(DBG_LOW, "%02X ",*src);
+		DBGPRINT(DBG_LOW, "\n");
+
+		if (tv_enc[i]==1)
+		{
+			pattern[tv].mode |= ENCRYPTION;
+		}
+		else
+		{
+			pattern[tv].mode &= ~ENCRYPTION;
+		}
+
+		//start_clk = read_c0_count();
+		AesProcessScatterGather(&sg_src_test[i][0], &sg_dst_test[i][0], \
+								pattern[tv].totallen, (uint8_t*)tv_key[i], \
+								(uint8_t*)pattern[tv].iv, (u32)pattern[tv].mode);
+	}
+	if (aes_irq_enabled == 1)
+		spin_unlock_irqrestore(&(AES_Entry.page_lock), flags);
+	return 0;
+}
+
+void AesRxHandler(unsigned long data)
+{
+
+	int k,n,m, bUserData = 0;
+	unsigned long flags = 0, regVal;
+	int try_count = -1;
+#ifdef DBG
+	end_clk = 0;
+#endif
+	if (aes_irq_enabled == 1)
+		spin_lock_irqsave(&(AES_Entry.page_lock), flags);
+
+	do {
+		regVal = sysRegRead(AES_GLO_CFG);
+		if((regVal & AES_RX_DMA_BUSY))
+		{
+			DBGPRINT(DBG_MID, "Poll RX_DMA_BUSY !!! \n");
+			udelay(10);
+			continue;
+		}
+		if((regVal & AES_TX_DMA_BUSY))
+		{
+			DBGPRINT(DBG_MID, "Poll TX_DMA_BUSY !!! \n");
+			udelay(10);
+			continue;
+
+		}
+		break;
+
+	}while(1);
+
+	k = aes_rx_front_idx;
+	m = aes_tx_front_idx;
+	n = k;
+	DBGPRINT(DBG_MID, "TX [front=%u rear=%u]; RX [front=%u rear=%u]\n",\
+			(u32)aes_tx_front_idx, (u32)aes_tx_rear_idx, (u32)aes_rx_front_idx, (u32)aes_rx_rear_idx);
+	do
+	{
+		if (AES_Entry.AES_rx_ring0[n].aes_rxd_info2.DDONE ==0)
+		{
+			if (aes_irq_enabled == 1)
+				n = (n+1)%NUM_AES_RX_DESC;
+			try_count++;
+			if (try_count >= NUM_AES_RX_DESC)
+			{
+				printk("============ Empty Rx Desc[%d] (try=%d)=============\n",n,try_count);
+				if (aes_irq_enabled == 1)
+					break;
+			}
+			continue;
+		}
+		else
+		{
+#ifdef DBG
+			if (end_clk ==0)
+				end_clk = read_c0_count();
+#endif
+		}
+		k = n;
+
+		if (AES_Entry.AES_rx_ring0[k].aes_rxd_info4.bitfield.UDV)
+		{
+			bUserData = 1;
+		}
+
+		if (bUserData)
+		{
+
+			if (AES_userdata[k].new_SDP0)
+			{
+				int first_rx = k;
+				int last_rx = k;
+				do {
+					//int kk;
+					int j;
+					int pos;
+					//u8* pdst = AES_userdata[first_rx].new_SDP0;
+					DBGPRINT(DBG_HIGH, "Rx[%d] user data, len=%d\n",first_rx,AES_Entry.AES_rx_ring0[first_rx].aes_rxd_info2.SDL0);
+
+					dma_unmap_single (NULL, AES_Entry.AES_rx_ring0[first_rx].SDP0, AES_Entry.AES_rx_ring0[first_rx].aes_rxd_info2.SDL0, PCI_DMA_FROMDEVICE);
+					pos = 0;
+					j = last_rx;//k;
+					do{
+						memcpy((void*)AES_userdata[j].orig_SDP0, (void*)AES_userdata[first_rx].new_SDP0+pos, AES_userdata[j].orig_SDL);
+						//pdst = AES_userdata[first_rx].new_SDP0+pos;
+						//for (kk=0; kk<16; kk++)
+						//	printk("%02X ",*pdst++);
+						//printk("\n");
+						DBGPRINT(DBG_HIGH, "copy to RxBuf[%d][%08X] len=%d\n",j, AES_userdata[j].orig_SDP0,AES_userdata[j].orig_SDL);
+						pos+=AES_userdata[j].orig_SDL;
+						if (pos >=AES_userdata[first_rx].new_SDL)
+							break;
+						j = (j+1)%NUM_AES_RX_DESC;
+
+					}while(1);
+					last_rx = j;
+					kfree((void*)AES_userdata[first_rx].new_SDP0);
+					if (AES_Entry.AES_rx_ring0[first_rx].aes_rxd_info2.LS0 == 1)
+					{
+						k = first_rx;
+						break;
+					}
+					first_rx = (first_rx+1)%NUM_AES_RX_DESC;
+				}while(1);
+			}
+		}
+		else
+			dma_unmap_single (NULL, AES_Entry.AES_rx_ring0[k].SDP0, AES_Entry.AES_rx_ring0[k].aes_rxd_info2.SDL0, PCI_DMA_FROMDEVICE);
+
+
+		DBGPRINT(DBG_HIGH, "Rx Desc[%d] Done\n",k);
+		if (AES_Entry.AES_rx_ring0[k].aes_rxd_info2.LS0)
+		{
+			AES_Entry.AES_rx_ring0[k].aes_rxd_info2.LS0 = 0;
+			/* last RX, release correspond TX */
+			do
+			{
+				AES_Entry.AES_tx_ring0[m].aes_txd_info2.DDONE = 1;
+				if (AES_Entry.AES_tx_ring0[m].aes_txd_info2.LS1)
+				{
+					AES_Entry.AES_tx_ring0[m].aes_txd_info2.LS1 = 0;
+					m = (m+1)%NUM_AES_TX_DESC;
+					break;
+				}
+				m = (m+1)%NUM_AES_TX_DESC;
+			}while (1);
+			if (aes_tx_front_idx==aes_tx_rear_idx)
+			{
+				aes_tx_front_idx = m;
+				DBGPRINT(DBG_HIGH, "Tx Desc Clean\n");
+			}
+			else
+				aes_tx_front_idx = m;
+
+			if (k==aes_rx_rear_idx)
+			{
+				aes_rx_front_idx = (k+1)%NUM_AES_RX_DESC;
+				DBGPRINT(DBG_HIGH, "Rx Desc Clean\n");
+				AES_Entry.AES_rx_ring0[k].aes_rxd_info2.DDONE = 0;
+				break;
+			}
+			else
+				aes_rx_front_idx = (k+1)%NUM_AES_RX_DESC;
+			bUserData = 0;
+		}
+		AES_Entry.AES_rx_ring0[k].aes_rxd_info2.DDONE = 0;
+		n = (k+1)%NUM_AES_RX_DESC;
+
+
+	}while(1);
+
+	sysRegWrite(AES_RX_CALC_IDX0, cpu_to_le32((u32) (k)));
+	aes_rx_rear_idx = sysRegRead(AES_RX_CALC_IDX0);
+	if (aes_irq_enabled == 1)
+		spin_unlock_irqrestore(&(AES_Entry.page_lock), flags);
+#ifdef DBG
+	//if (end_clk ==0)
+	//	end_clk = read_c0_count();
+#endif
+	return ;
+}
+
+irqreturn_t AesEngineIrqHandler(
+	int irq,
+	void *irqaction
+	)
+{
+
+	DBGPRINT(DBG_HIGH, "AES INT %08X\n",sysRegRead(AES_INT_STATUS));
+	tasklet_hi_schedule(&AesRxTasklet);
+	sysRegWrite(AES_INT_STATUS, AES_FE_INT_ALL);  //Write one clear INT_status
+
+	return IRQ_HANDLED;
+}
+
+
+static int aes_engine_proc_read(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len;
+    if (off > 0)
+    {
+        return 0;
+    }
+
+    len = sprintf(buf, "isr : %d\n", aes_engine_proc.isr_count);
+    len += sprintf(buf + len, "put packet : %d\n", aes_engine_proc.put_count);
+    return len;
+}
+
+static int aes_engine_proc_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+    char buf[128];
+    char* pch[5];
+    char* ptr;
+    char cmd;
+    int len = count, i;
+	unsigned long reg_int_mask=0;
+
+    if (len >= sizeof(buf))
+    {
+        len = sizeof(buf) - 1;
+    }
+	memset(buf, 0x0 ,128);
+    if (copy_from_user(buf, buffer, len))
+    {
+        return -EFAULT;
+    }
+
+	ptr = buf;
+	i = 0;
+	pch[i] = strsep(&ptr," ");
+	cmd = (char)*(pch[0]+0);
+	while (pch[i] != NULL)
+  	{
+    	DBGPRINT (DBG_LOW, "[%d]%s\n",i,pch[i]);
+    	i++;
+    	pch[i] = strsep (&ptr, " ");
+    	if (i >= 5)
+    		break;
+  	}
+	if (cmd == 't')
+	{
+		memset(sbuf, 0, sizeof(uint32_t)*MAX_TEST_SEQ*MAX_SG_BUF);
+		memset(dbuf, 0, sizeof(uint32_t)*MAX_TEST_SEQ*MAX_SG_BUF);
+		memset(tv_seq, 0xFF, sizeof(int)*MAX_TEST_SEQ);
+		memset(tv_enc, 0xFF, sizeof(int)*MAX_TEST_SEQ);
+		memset(tv_key, 0, sizeof(uint32_t)*MAX_TEST_SEQ);
+		if (i <= 2)
+		{
+			tv_seq[0] = 0;
+			tv_enc[0] = 0;
+		}
+		else
+		{
+			tv_enc[0] = (*(pch[2]+0)=='e') ? 1 : 0;
+			tv_seq[0] = simple_strtol(pch[1], (char **)pch[2], 10);
+		}
+		AesGenPattern(tv_seq[0], 0, tv_enc[0]);
+		AesKickEngine();
+	}
+	if (cmd == 's')
+	{
+		memset(sbuf, 0, sizeof(uint32_t)*MAX_TEST_SEQ*MAX_SG_BUF);
+		memset(dbuf, 0, sizeof(uint32_t)*MAX_TEST_SEQ*MAX_SG_BUF);
+		memset(tv_seq, 0xFF, sizeof(int)*MAX_TEST_SEQ);
+		memset(tv_enc, 0xFF, sizeof(int)*MAX_TEST_SEQ);
+		memset(tv_key, 0, sizeof(uint32_t)*MAX_TEST_SEQ);
+		tv_seq[0] = 0;
+		tv_seq[1] = 0;
+		tv_seq[2] = 1;
+		tv_seq[3] = 2;
+		tv_seq[4] = 1;
+		tv_seq[5] = 3;
+
+		tv_seq[6] = 4;
+		tv_seq[7] = 4;
+		tv_seq[8] = 5;
+		tv_seq[9] = 5;
+
+		tv_seq[10] = 6;
+		tv_seq[11] = 7;
+
+		tv_seq[12] = 8;
+		tv_seq[13] = 8;
+
+		tv_enc[0] = 1;
+		tv_enc[1] = 0;
+		tv_enc[2] = 1;
+		tv_enc[3] = 1;
+		tv_enc[4] = 0;
+		tv_enc[5] = 0;
+
+		tv_enc[6] = 1;
+		tv_enc[7] = 0;
+		tv_enc[8] = 1;
+		tv_enc[9] = 0;
+
+		tv_enc[10] = 1;
+		tv_enc[11] = 0;
+
+		tv_enc[12] = 1;
+		tv_enc[13] = 0;
+
+		printk("============================================================\n");
+
+		for (i=0; i<MAX_TEST_SEQ;i++)
+		{
+			if (tv_seq[i]>=0)
+			{
+				AesGenPattern(tv_seq[i], i, tv_enc[i]);
+				printk("============================================================\n");
+			}
+
+		}
+		AesKickEngine();
+
+	}
+	if (cmd == 'z')
+	{
+		for (i=0; i<MAX_TEST_SEQ;i++)
+		{
+			if (tv_seq[i]>=0)
+			{
+				AesResultVerify(tv_seq[i], i, tv_enc[i]);
+				printk("============================================================\n");
+			}
+
+		}
+	}
+	if (cmd == 'd')
+	{
+		for (i=0; i < NUM_AES_TX_DESC; i++) {
+			uint32_t* ptr = (uint32_t*)&AES_Entry.AES_tx_ring0[i];
+			printk("Tx Ring%d[%08X]:\n",i,(u32)ptr);
+			printk("%08X %08X %08X %08X\n",*ptr, *(ptr+1),*(ptr+2),*(ptr+3));
+			printk("%08X %08X %08X %08X\n",*(ptr+4), *(ptr+5),*(ptr+6),*(ptr+7));
+		}
+		printk("\n");
+		for (i=0; i < NUM_AES_RX_DESC; i++) {
+			uint32_t* ptr = (uint32_t*)&AES_Entry.AES_rx_ring0[i];
+			printk("Rx Ring%d[%08X]:\n",i,(u32)ptr);
+			printk("%08X %08X %08X %08X\n",*ptr, *(ptr+1),*(ptr+2),*(ptr+3));
+			printk("%08X %08X %08X %08X\n",*(ptr+4), *(ptr+5),*(ptr+6),*(ptr+7));
+		}
+		printk("\n");
+	}
+	if (cmd == 'p')
+	{
+		aes_dbg_print = simple_strtol(pch[1], (char **)pch[2], 10);
+	}
+	if (cmd == 'v')
+	{
+		AesResultVerify(tv_seq[0], 0, tv_enc[0]);
+#ifdef DBG
+		{
+			unsigned long delta;
+
+			if(start_clk <= end_clk)
+				delta = (end_clk - start_clk)/((mips_cpu_feq>>1)/(1000000));
+			else
+				delta = (0xFFFFFFFF - (start_clk - end_clk))/((mips_cpu_feq>>1)/(1000000));
+
+			printk("Time consume = %u usec\n",(u32)delta);
+			printk("Data Rate = %u MB/s\n", (u32)(pattern[tv_seq[0]].totallen/delta));
+		}
+#endif
+	}
+	if (cmd == 'c')
+	{
+		int n, j, seq;
+
+		for (seq = 0; seq < MAX_TEST_SEQ; seq++)
+		{
+			if (tv_key[seq])
+				free_page((unsigned long)tv_key[seq]);
+			tv_key[seq] =NULL;
+
+			if (tv_seq[seq] >= 0)
+			{
+				n = pattern[tv_seq[seq]].src_multipage;
+				for (j = 0 ; j < n ; j++)
+					if (sbuf[seq][j])
+					{
+			    		free_page((unsigned long)sbuf[seq][j]);
+			    		sbuf[seq][j] = NULL;
+					}
+
+				n = pattern[tv_seq[seq]].dst_multipage;
+				for (j = 0 ; j < n ; j++)
+					if (dbuf[seq][j])
+					{
+			    		free_page((unsigned long)dbuf[seq][j]);
+			    		dbuf[seq][j] = NULL;
+		    		}
+			}
+		}
+
+		//new PROM
+		clear_AES_glo_cfg();
+		msleep(10);
+
+		if (AES_Entry.AES_tx_ring0)
+			pci_free_consistent(NULL, NUM_AES_TX_DESC*sizeof(struct AES_txdesc), AES_Entry.AES_tx_ring0, AES_Entry.phy_aes_tx_ring0);
+		if (AES_Entry.AES_rx_ring0)
+			pci_free_consistent(NULL, NUM_AES_RX_DESC*sizeof(struct AES_rxdesc), AES_Entry.AES_rx_ring0, AES_Entry.phy_aes_rx_ring0);
+		AES_Entry.AES_tx_ring0 = NULL;
+		AES_Entry.AES_rx_ring0 = NULL;
+
+		//Disable AES interrupt
+		reg_int_mask=sysRegRead(AES_INT_MASK);
+		sysRegWrite(AES_INT_MASK,reg_int_mask & ~(AES_FE_INT_ALL) );
+
+		AesDescriptorInit();
+		set_AES_glo_cfg();
+		sysRegWrite(AES_INT_MASK, (reg_int_mask  & ~(AES_FE_INT_TX)) |(AES_FE_INT_RX));
+	}
+	return len;
+}
+
+
+void set_AES_glo_cfg(void)
+{
+	int AES_glo_cfg=0;
+	int burst_mode = 0;
+	//AES_glo_cfg = (AES_TX_WB_DDONE | AES_RX_DMA_EN | AES_TX_DMA_EN | AES_BT_SIZE_32DWORDS | AES_MUTI_ISSUE);
+	if (burstlen==4)
+		burst_mode = 0;
+	else if (burstlen==8)
+		burst_mode = 1;
+	else if (burstlen==16)
+		burst_mode = 2;
+	else if (burstlen==32)
+		burst_mode = 3;
+	else
+		burst_mode = 0;
+	printk("set burstmode=%02X\n",burst_mode);
+
+	AES_glo_cfg = (AES_TX_WB_DDONE | AES_RX_DMA_EN | AES_TX_DMA_EN |(burst_mode<<4)|AES_DESC_5DW_INFO_EN|AES_RX_ANYBYTE_ALIGN );
+	sysRegWrite(AES_GLO_CFG, AES_glo_cfg);
+}
+void clear_AES_glo_cfg(void)
+{
+	unsigned int regValue;
+
+	regValue = sysRegRead(AES_GLO_CFG);
+	regValue &= ~(AES_TX_WB_DDONE | AES_RX_DMA_EN | AES_TX_DMA_EN |(0x3<<4)|AES_DESC_5DW_INFO_EN|AES_RX_ANYBYTE_ALIGN  );
+	sysRegWrite(AES_GLO_CFG, regValue);
+	DBGPRINT(DBG_LOW, "Done\n");
+}
+
+static int AesDescriptorInit(void)
+{
+	int		i;
+	unsigned int	regVal;
+	int bAESDescInit = 0;
+/*
+	while(1)
+	{
+		regVal = sysRegRead(AES_GLO_CFG);
+		if((regVal & AES_RX_DMA_BUSY))
+		{
+			printk("\n  RX_DMA_BUSY !!! ");
+			continue;
+		}
+		if((regVal & AES_TX_DMA_BUSY))
+		{
+			printk("\n  TX_DMA_BUSY !!! ");
+			continue;
+		}
+		break;
+	}
+*/
+	udelay(1000);
+	regVal = sysRegRead(AES_GLO_CFG);
+	if((regVal & AES_RX_DMA_BUSY))
+	{
+		printk("\n  RX_DMA_BUSY !!! ");
+
+	}
+	if((regVal & AES_TX_DMA_BUSY))
+	{
+		printk("\n  TX_DMA_BUSY !!! ");
+
+	}
+
+
+	//initial TX ring0
+
+	if (AES_Entry.AES_tx_ring0 == NULL)
+	{
+		AES_Entry.AES_tx_ring0 = pci_alloc_consistent(NULL, NUM_AES_TX_DESC * sizeof(struct AES_txdesc), &AES_Entry.phy_aes_tx_ring0);
+		printk("\nphy_tx_ring0 = 0x%08x, tx_ring0 = 0x%p\n", AES_Entry.phy_aes_tx_ring0, AES_Entry.AES_tx_ring0);
+	}
+	else
+		bAESDescInit = 1;
+
+	for (i=0; i < NUM_AES_TX_DESC; i++) {
+		memset(&AES_Entry.AES_tx_ring0[i], 0, sizeof(struct AES_txdesc));
+#if defined(AES_SCATTER)
+		AES_Entry.AES_tx_ring0[i].aes_txd_info2.LS0 = 0;
+#else
+		AES_Entry.AES_tx_ring0[i].aes_txd_info2.LS0 = 0;
+#endif
+		AES_Entry.AES_tx_ring0[i].aes_txd_info2.LS1 = 0;//1;
+		AES_Entry.AES_tx_ring0[i].aes_txd_info2.DDONE = 1;
+	}
+
+	//initial RX ring0
+
+	if (AES_Entry.AES_rx_ring0 == NULL)
+	{
+		AES_Entry.AES_rx_ring0 = pci_alloc_consistent(NULL, NUM_AES_RX_DESC * sizeof(struct AES_rxdesc), &AES_Entry.phy_aes_rx_ring0);
+		printk("\nphy_rx_ring0 = 0x%08x, rx_ring0 = 0x%p\n",AES_Entry.phy_aes_rx_ring0,AES_Entry.AES_rx_ring0);
+	}
+	else
+		bAESDescInit = 1;
+
+
+	for (i = 0; i < NUM_AES_RX_DESC; i++) {
+		memset(&AES_Entry.AES_rx_ring0[i],0,sizeof(struct AES_rxdesc));
+		AES_Entry.AES_rx_ring0[i].aes_rxd_info2.DDONE = 0;
+#if defined(AES_SCATTER)
+		AES_Entry.AES_rx_ring0[i].aes_rxd_info2.LS0 = 0;
+#else
+		AES_Entry.AES_rx_ring0[i].aes_rxd_info2.LS0 = 0;//1;
+#endif
+	}
+
+	if (bAESDescInit == 0)
+	{
+		// AES_GLO_CFG
+		regVal = sysRegRead(AES_GLO_CFG);
+		regVal &= 0x000000FF;
+		sysRegWrite(AES_GLO_CFG, regVal);
+		regVal=sysRegRead(AES_GLO_CFG);
+		/* Tell the adapter where the TX/RX rings are located. */
+		//TX0
+		sysRegWrite(AES_TX_BASE_PTR0, phys_to_bus((u32) AES_Entry.phy_aes_tx_ring0));
+		sysRegWrite(AES_TX_MAX_CNT0, cpu_to_le32((u32) NUM_AES_TX_DESC));
+		sysRegWrite(AES_TX_CTX_IDX0, 0);
+		aes_tx_front_idx = 0;
+		aes_tx_rear_idx = NUM_AES_TX_DESC-1;
+		sysRegWrite(AES_RST_CFG, AES_PST_DTX_IDX0);
+		printk("TX_CTX_IDX0 = %x\n", sysRegRead(AES_TX_CTX_IDX0));
+		printk("TX_DTX_IDX0 = %x\n", sysRegRead(AES_TX_DTX_IDX0));
+
+
+		//RX0
+		sysRegWrite(AES_RX_BASE_PTR0, phys_to_bus((u32) AES_Entry.phy_aes_rx_ring0));
+		sysRegWrite(AES_RX_MAX_CNT0,  cpu_to_le32((u32) NUM_AES_RX_DESC));
+		sysRegWrite(AES_RX_CALC_IDX0, cpu_to_le32((u32) (NUM_AES_RX_DESC - 1)));
+		sysRegRead(AES_RX_CALC_IDX0);
+		aes_rx_front_idx = 0;
+		aes_rx_rear_idx = NUM_AES_RX_DESC-1;
+		sysRegWrite(AES_RST_CFG, AES_PST_DRX_IDX0);
+		printk("RX_CRX_IDX0 = %x\n", sysRegRead(AES_RX_CALC_IDX0));
+		printk("RX_DRX_IDX0 = %x\n", sysRegRead(AES_RX_DRX_IDX0));
+	}
+
+	return 1;
+}
+
+static int __init AesEngineInit(void)
+{
+	struct proc_dir_entry *entry;
+	uint32_t Ret=0;
+	unsigned long reg_int_mask=0;
+	printk("Enable MTK AesEngine Module (verson=%08X) \n", sysRegRead(AES_INFO));
+	entry = create_proc_entry(PROCNAME, 0666, NULL);
+    if (entry == NULL)
+    {
+        printk("AES Engine : unable to create /proc entry\n");
+        return -1;
+    }
+    entry->read_proc = aes_engine_proc_read;
+    entry->write_proc = aes_engine_proc_write;
+    memset(&aes_engine_proc, 0, sizeof(aes_engine_proc_type));
+
+	if (aes_irq_enabled)
+	{
+		Ret = request_irq(SURFBOARDINT_AESENGINE, AesEngineIrqHandler, \
+		    IRQF_DISABLED, "AES_ENGINE", NULL);
+
+		if(Ret){
+			printk("IRQ %d is not free.\n", SURFBOARDINT_AESENGINE);
+			return 1;
+		}
+		printk("request IRQ=%d sucess\n",SURFBOARDINT_AESENGINE);
+	}
+
+	spin_lock_init(&(AES_Entry.page_lock));
+	printk("reg_int_mask=%lu, INT_MASK= %x \n", reg_int_mask, sysRegRead(AES_INT_MASK));
+	AesDescriptorInit();
+	set_AES_glo_cfg();
+	printk("AES_GLO_CFG = %x\n", sysRegRead(AES_GLO_CFG));
+
+	memset(AesDoneIntCallback, 0, NUM_AES_RX_DESC*sizeof(uint32_t));
+	memset(AES_userdata, 0, NUM_AES_RX_DESC*sizeof(AES_userdata_type));
+
+	tasklet_init(&AesRxTasklet, AesRxHandler , 0);
+
+	if (aes_irq_enabled)
+	{
+		sysRegWrite(AES_INT_MASK, (reg_int_mask  & ~(AES_FE_INT_TX)) |(AES_FE_INT_RX));
+	}
+
+	Ret = crypto_register_alg(&mcrypto_cbc_alg);
+	printk("register aes-cbc crypto api to kernel\n");
+	if (Ret)
+	{
+		printk("register aes-cbc crypto api to kernel failed !!!\n");
+		crypto_unregister_alg(&mcrypto_cbc_alg);
+	}
+	Ret = crypto_register_alg(&mcrypto_aes_alg);
+	printk("register aes crypto api to kernel\n");
+	if (Ret)
+	{
+		printk("register aes crypto api to kernel failed !!!\n");
+		crypto_unregister_alg(&mcrypto_aes_alg);
+	}
+	return Ret;
+}
+
+
+
+static void __exit AesEngineExit(void)
+{
+	unsigned long reg_int_mask=0;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+	cancel_work_sync(&AES_Entry.reset_task);
+#endif
+	clear_AES_glo_cfg();
+	msleep(10);
+
+	if (AES_Entry.AES_tx_ring0 != NULL) {
+		pci_free_consistent(NULL, NUM_AES_TX_DESC*sizeof(struct AES_txdesc), AES_Entry.AES_tx_ring0, AES_Entry.phy_aes_tx_ring0);
+	}
+
+	pci_free_consistent(NULL, NUM_AES_RX_DESC*sizeof(struct AES_rxdesc), AES_Entry.AES_rx_ring0, AES_Entry.phy_aes_rx_ring0);
+	printk("Free TX/RX Ring Memory!\n");
+	printk("Disable AES Controller Module\n");
+	//Disable AES interrupt
+	reg_int_mask=sysRegRead(AES_INT_MASK);
+	sysRegWrite(AES_INT_MASK,reg_int_mask & ~(AES_FE_INT_ALL) );
+	if (aes_irq_enabled)
+		free_irq(SURFBOARDINT_AESENGINE, NULL);
+	remove_proc_entry(PROCNAME, pProcDir);
+
+	crypto_unregister_alg(&mcrypto_cbc_alg);
+	crypto_unregister_alg(&mcrypto_aes_alg);
+}
+
+int AesGenPattern(int tv, int seq, int enc)
+{
+	int j, n;
+	uint8_t* source;
+	int pos = 0;
+
+	if (enc==1)
+	{
+		pattern[tv].mode |= ENCRYPTION;
+		printk("Gen Encrypt pattern (seq=%d tv=%d klen=%d)\n",seq, tv, (aes_key_len[pattern[tv].mode&0x03]<<3));
+	}
+	else
+	{
+		pattern[tv].mode &= ~ENCRYPTION;
+		printk("Gen Decrypt pattern (seq=%d tv=%d klen=%d)\n",seq, tv, (aes_key_len[pattern[tv].mode&0x03]<<3));
+	}
+	n = pattern[tv].src_multipage;
+	sg_init_table(&sg_src_test[seq][0], n);
+	if (enc)
+	{
+		source = (uint8_t*)pattern[tv].plaintext;
+		pattern[tv].totallen = pattern[tv].plainlen;
+	}
+	else
+	{
+		source = (uint8_t*)pattern[tv].ciphertext;
+		pattern[tv].totallen = pattern[tv].cipherlen;
+	}
+	tv_key[seq] = (void *)__get_free_page(GFP_KERNEL);
+	if (!tv_key[seq])
+        goto EXIT;
+	memset(tv_key[seq], 0, PAGE_SIZE);
+	memcpy(tv_key[seq], pattern[tv].key, aes_key_len[pattern[tv].mode&0x03]);
+
+	for (j = 0 ; j < n ; j++)
+	{
+    	sbuf[seq][j] = (void *)__get_free_page(GFP_KERNEL);
+    	if (!sbuf[seq][j])
+        	goto EXIT;
+    	memset(sbuf[seq][j], 0, PAGE_SIZE);
+
+    	if (j==(n-1))
+    	{
+    		if ((pos+pattern[tv].src_length[j]-pattern[tv].totallen) > 0)
+    		{
+    			int npadding = (pos+pattern[tv].src_length[j]-pattern[tv].totallen);
+    			memset(sbuf[seq][j]+pattern[tv].src_offset[j]+pattern[tv].src_length[j]-npadding, (uint8_t)npadding, npadding);
+    			memcpy(sbuf[seq][j]+pattern[tv].src_offset[j], source+pos, pattern[tv].src_length[j]-npadding);
+    		}
+    		else
+    			memcpy(sbuf[seq][j]+pattern[tv].src_offset[j], source+pos, pattern[tv].src_length[j]);
+    	}
+    	else
+			memcpy(sbuf[seq][j]+pattern[tv].src_offset[j], source+pos, pattern[tv].src_length[j]);
+
+		sg_set_buf(&sg_src_test[seq][j], sbuf[seq][j]+pattern[tv].src_offset[j], pattern[tv].src_length[j]);
+		//{
+		//	int jj;
+			//uint8_t* src = sbuf[seq][j]+pattern[tv].src_offset[j];
+			//for (jj =0; jj< pattern[tv].src_length[j]; jj++)
+		//	{
+				//printk("%02X ", *src);
+				//src++;
+		//	}
+			//printk("\n");
+		//}
+		pos += pattern[tv].src_length[j];
+	}
+
+	n = pattern[tv].dst_multipage;
+	sg_init_table(&sg_dst_test[seq][0], n);
+	for (j = 0; j < n; j++)
+	{
+		dbuf[seq][j] = (void *)__get_free_page(GFP_KERNEL);
+    	if (!dbuf[seq][j])
+        	goto EXIT;
+		memset(dbuf[seq][j], 0x5A, PAGE_SIZE);
+		sg_set_buf(&sg_dst_test[seq][j], dbuf[seq][j]+pattern[tv].dst_offset[j], pattern[tv].dst_length[j]);
+	}
+
+	return 0;
+EXIT:
+	printk("%s : OOM\n",__func__);
+	if (tv_key[seq])
+		free_page((u32)tv_key[seq]);
+
+	n = pattern[tv].src_multipage;
+	for (j = 0 ; j < n ; j++)
+		if (sbuf[seq][j])
+			free_page((unsigned long)sbuf[seq][j]);
+
+
+	n = pattern[tv].dst_multipage;
+	for (j = 0 ; j < n ; j++)
+		if (dbuf[seq][j])
+			free_page((unsigned long)dbuf[seq][j]);
+
+	printk("AES pattern generation failed\n");
+    return -ENOMEM;
+
+}
+
+int AesResultVerify(int tv, int seq, int enc)
+{
+	int j, n, ret, totallen, remain;
+	int pos = 0;
+	uint8_t * source;
+
+	if (enc==1)
+	{
+		source = (uint8_t*)pattern[tv].ciphertext;
+		totallen = pattern[tv].cipherlen;
+		printk("Verify Encrypt pattern (seq=%d tv=%d totallen=%d)\n",seq, tv, totallen);
+	}
+	else
+	{
+		source = (uint8_t*)pattern[tv].plaintext;
+		totallen = pattern[tv].plainlen;
+		printk("Verify Decrypt pattern (seq=%d tv=%d totallen=%d)\n",seq, tv, totallen);
+	}
+	n = pattern[tv].dst_multipage;
+
+	for (j = 0 ; j < n ; j++)
+	{
+		int jj;
+		int len = 16, cmplen = 0;
+
+		uint8_t* src, *dst;
+		if (totallen < pattern[tv].dst_length[j])
+		{
+			cmplen = totallen;
+			printk("Padding %d bytes\n",pattern[tv].dst_length[j]-totallen);
+		}
+		else
+			cmplen = pattern[tv].dst_length[j];
+
+		totallen-=cmplen;
+		printk("compare TestVector[%08X] DST[%08X] len=%d\n", (u32)(source+pos), (u32)(dbuf[seq][j]+pattern[tv].dst_offset[j]), cmplen);
+		ret = strncmp(dbuf[seq][j]+pattern[tv].dst_offset[j], source+pos, cmplen);
+		printk("Verify TestVector[%d][%d] ret=%d done\n",tv,j,ret);
+		dst = dbuf[seq][j]+pattern[tv].dst_offset[j];
+		src = source+pos;
+		len = (cmplen < 16) ? cmplen : 16;
+		remain = cmplen;
+		for (jj = 0; jj < cmplen; jj+=16)
+		{
+			int kk;
+			uint8_t* psrc, *pdst;
+			psrc = src;
+			for (kk=0; kk<len; kk++)
+				DBGPRINT(DBG_LOW, "%02X ",*psrc++);
+			DBGPRINT(DBG_LOW, "\n");
+			pdst = dst;
+			for (kk=0; kk<len; kk++)
+				DBGPRINT(DBG_LOW, "%02X ",*pdst++);
+			DBGPRINT(DBG_LOW, "\n\n");
+			if (remain < 16)
+				len = remain;
+			for (kk=0; kk<len; kk++,src++,dst++)
+			{
+				if (*src!=*dst)
+				{
+					printk("[==== error ====][%d][%d]\n",j,kk);
+					goto EXIT;
+				}
+			}
+			remain -= 16;
+
+
+		}
+		pos += cmplen;
+	}
+EXIT:
+    return 0;
+}
+#ifdef DBG
+IMPORT_SYMBOL(mips_cpu_feq);
+#endif
+MODULE_DESCRIPTION("MTK AES Engine Module");
+MODULE_AUTHOR("Qwert");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(MOD_VERSION_AES_ENGINE);
+module_param_named(irq, aes_irq_enabled, int, S_IRUGO);
+module_param_named(b, burstlen, int, S_IRUGO);
+module_init(AesEngineInit);
+module_exit(AesEngineExit);
diff --git a/drivers/crypto/aes_engine/aes_engine.h b/drivers/crypto/aes_engine/aes_engine.h
new file mode 100755
index 0000000..ef1538a
--- /dev/null
+++ b/drivers/crypto/aes_engine/aes_engine.h
@@ -0,0 +1,255 @@
+#ifndef _MTK_AES_ENGINE
+#define _MTK_AES_ENGINE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <asm/rt2880/rt_mmap.h>
+#endif
+
+#define MOD_VERSION_AES_ENGINE 			"0.1"
+#define NUM_AES_RX_DESC     16
+#define NUM_AES_TX_DESC    	16
+
+#define phys_to_bus(a) (a & 0x1FFFFFFF)
+
+#define PHYS_TO_K1(physaddr) KSEG1ADDR(physaddr)
+
+extern int aes_dbg_print;
+
+#define DBG_LOW		3
+#define DBG_MID		2
+#define DBG_HIGH	1
+
+//#define DBG
+#ifdef DBG
+#define DBGPRINT(level, fmt, args...)      do{ if ((aes_dbg_print>0)&&(aes_dbg_print>=level)) printk(fmt, ## args);}while(0)
+#else
+#define DBGPRINT(level, fmt, args...)      do {}while(0)
+#endif
+
+#define sysRegRead(phys)        \
+        (*(volatile unsigned int *)PHYS_TO_K1(phys))
+
+//#ifdef DBG
+#if 0
+#define sysRegWrite(phys, val)  \
+        do {\
+        	(*(volatile unsigned int *)PHYS_TO_K1(phys)) = (val);\
+        	DBGPRINT("AES[%08X]=%08X\n",(u32)phys,(u32)sysRegRead(phys));\
+        }while(0);
+#else
+#define sysRegWrite(phys, val)  \
+        ((*(volatile unsigned int *)PHYS_TO_K1(phys)) = (val))
+#endif
+
+
+#define u_long	unsigned long
+#define u32	unsigned int
+#define u16	unsigned short
+
+
+/* 1. AES */
+#define AES_TX_BASE_PTR0            (RALINK_AES_ENGINE_BASE + 0x000)
+#define AES_TX_MAX_CNT0             (RALINK_AES_ENGINE_BASE + 0x004)
+#define AES_TX_CTX_IDX0             (RALINK_AES_ENGINE_BASE + 0x008)
+#define AES_TX_DTX_IDX0             (RALINK_AES_ENGINE_BASE + 0x00C)
+
+#define AES_RX_BASE_PTR0            (RALINK_AES_ENGINE_BASE + 0x100)
+#define AES_RX_MAX_CNT0             (RALINK_AES_ENGINE_BASE + 0x104)
+#define AES_RX_CALC_IDX0            (RALINK_AES_ENGINE_BASE + 0x108)
+#define AES_RX_DRX_IDX0             (RALINK_AES_ENGINE_BASE + 0x10C)
+
+#define AES_INFO                    (RALINK_AES_ENGINE_BASE + 0x200)
+#define AES_GLO_CFG 				(RALINK_AES_ENGINE_BASE + 0x204)
+#define AES_RST_IDX            		(RALINK_AES_ENGINE_BASE + 0x208)
+#define AES_RST_CFG            		(AES_RST_IDX)
+#define AES_DLY_INT_CFG             (RALINK_AES_ENGINE_BASE + 0x20C)
+#define HAES_FREEQ_THRES            (RALINK_AES_ENGINE_BASE + 0x210)
+#define AES_INT_STATUS              (RALINK_AES_ENGINE_BASE + 0x220)
+#define AES_FE_INT_STATUS		    (AES_INT_STATUS)
+#define AES_INT_MASK                (RALINK_AES_ENGINE_BASE + 0x228)
+//#define FE_INT_ENABLE		(INT_MASK)
+
+/*BUS MATRIX*/
+#define OCP_CFG0	  (RALINK_RBUS_MATRIXCTL_BASE+0x000);
+#define OCP_CFG1      (RALINK_RBUS_MATRIXCTL_BASE+0x004);
+#define DYN_CFG0      (RALINK_RBUS_MATRIXCTL_BASE+0x010);
+#define DYN_CFG1	  (RALINK_RBUS_MATRIXCTL_BASE+0x014);
+#define DYN_CFG2      (RALINK_RBUS_MATRIXCTL_BASE+0x018);
+#define DYN_CFG3      (RALINK_RBUS_MATRIXCTL_BASE+0x01C);
+#define IOCU_CFG      (RALINK_RBUS_MATRIXCTL_BASE+0x020);
+
+
+/* ====================================== */
+/* ====================================== */
+#define PSE_RESET       (1<<0)
+/* ====================================== */
+#define AES_PST_DRX_IDX1       (1<<17)
+#define AES_PST_DRX_IDX0       (1<<16)
+#define AES_PST_DTX_IDX3       (1<<3)
+#define AES_PST_DTX_IDX2       (1<<2)
+#define AES_PST_DTX_IDX1       (1<<1)
+#define AES_PST_DTX_IDX0       (1<<0)
+
+#define AES_RX_2B_OFFSET	    (1<<31)
+#define AES_RX_ANYBYTE_ALIGN   (1<<12)
+#define AES_DESC_5DW_INFO_EN	(1<<11)
+#define AES_MUTI_ISSUE        (1<<10)
+#define AES_TWO_BUFFER        (1<<9)
+#define AES_TX_WB_DDONE       (1<<6)
+#define AES_RX_DMA_BUSY       (1<<3)
+#define AES_TX_DMA_BUSY       (1<<1)
+#define AES_RX_DMA_EN         (1<<2)
+#define AES_TX_DMA_EN         (1<<0)
+
+#define AES_BT_SIZE_4DWORDS     (0<<4)
+#define AES_BT_SIZE_8DWORDS     (1<<4)
+#define AES_BT_SIZE_16DWORDS    (2<<4)
+#define AES_BT_SIZE_32DWORDS    (3<<4)
+
+#define AES_RX_COHERENT      (1<<31)
+#define AES_RX_DLY_INT       (1<<30)
+#define AES_TX_COHERENT      (1<<29)
+#define AES_TX_DLY_INT       (1<<28)
+#define AES_RX_DONE_INT0     (1<<16)
+#define AES_TX_DONE_INT0     (1)
+//#define AES_TX_DONE_BIT      (1<<31)
+//#define AES_TX_LS0           (1<<30)
+/*
+#define FE_INT_ALL		(AES_TX_DONE_INT3 | AES_TX_DONE_INT2 | \
+			         AES_TX_DONE_INT1 | AES_TX_DONE_INT0 | \
+	                         AES_RX_DONE_INT0 | AES_RX_DONE_INT1)*/
+//#define AES_FE_INT_ALL    (AES_TX_DONE_INT0 | AES_RX_DONE_INT0 | AES_RX_COHERENT | AES_TX_COHERENT | AES_RX_DLY_INT | AES_TX_DLY_INT)
+#define AES_FE_INT_ALL			(AES_RX_DONE_INT0)
+#define AES_FE_INT_TX			(AES_TX_DONE_INT0)
+#define AES_FE_INT_RX     (AES_RX_DONE_INT0)
+#define AES_FE_INT_STATUS_REG (*(volatile unsigned long *)(FE_INT_STATUS))
+#define AES_FE_INT_STATUS_CLEAN(reg) (*(volatile unsigned long *)(FE_INT_STATUS)) = reg
+
+// Define Whole FE Reset Register
+#define RSTCTRL         (RALINK_SYSCTL_BASE + 0x34)
+/*=========================================
+      AES AES_RX Descriptor Format define
+=========================================*/
+//-------------------------------------------------
+typedef struct _AES_RXD_INFO2_    AES_RXD_INFO2_T;
+
+struct _AES_RXD_INFO2_
+{
+	volatile unsigned int    RSV                 	: 16;
+	volatile unsigned int    SDL0                  	: 14;
+	volatile unsigned int    LS0                   	: 1;
+	volatile unsigned int    DDONE	             	: 1;
+};
+//-------------------------------------------------
+typedef struct _AES_RXD_INFO4_    AES_RXD_INFO4_T;
+
+struct _AES_RXD_INFO4_
+{
+	volatile unsigned int	KEY_LEN				: 2;
+	volatile unsigned int	ENC					: 1;
+	volatile unsigned int	UDV					: 1;
+	volatile unsigned int	CBC					: 1;
+	volatile unsigned int	IVR					: 1;
+	volatile unsigned int	KIU					: 1;
+	volatile unsigned int	RSV					: 25;
+};
+
+
+struct AES_rxdesc {
+	unsigned int SDP0;
+	AES_RXD_INFO2_T aes_rxd_info2;
+	unsigned int user_data;
+	union {
+		AES_RXD_INFO4_T bitfield;
+		uint32_t value;
+	}aes_rxd_info4;
+	unsigned int IV[4];
+}__attribute__((aligned(32)));
+
+
+/*=========================================
+      AES AES_TX Descriptor Format define
+=========================================*/
+//-------------------------------------------------
+typedef struct _AES_TXD_INFO2_    AES_TXD_INFO2_T;
+
+struct _AES_TXD_INFO2_
+{
+	volatile unsigned int    SDL1                 	: 14;
+	volatile unsigned int    LS1                   	: 1;
+	volatile unsigned int    RSV                   	: 1;
+	volatile unsigned int    SDL0                  	: 14;
+	volatile unsigned int    LS0                   	: 1;
+	volatile unsigned int    DDONE             		: 1;
+};
+//-------------------------------------------------
+typedef struct _AES_TXD_INFO4_    AES_TXD_INFO4_T;
+
+struct _AES_TXD_INFO4_
+{
+	volatile unsigned int	KEY_LEN				: 2;
+	volatile unsigned int	ENC					: 1;
+	volatile unsigned int	UDV					: 1;
+	volatile unsigned int	CBC					: 1;
+	volatile unsigned int	IVR					: 1;
+	volatile unsigned int	KIU					: 1;
+	volatile unsigned int	RSV					: 25;
+};
+
+
+struct AES_txdesc {
+	unsigned int SDP0;
+	AES_TXD_INFO2_T aes_txd_info2;
+	unsigned int SDP1;
+	union {
+		AES_TXD_INFO4_T bitfield;
+		uint32_t value;
+	}aes_txd_info4;
+	unsigned int IV[4];
+}__attribute__((aligned(32)));
+
+typedef struct AES_userdata_t {
+	unsigned int orig_SDP0;
+	unsigned int orig_SDL;
+	unsigned int new_SDP0;
+	unsigned int new_SDL;
+}AES_userdata_type;
+
+struct AesReqEntry {
+
+    unsigned int  	aes_tx_full;
+    unsigned int	phy_aes_tx_ring0;
+    unsigned int	phy_aes_rx_ring0;
+    spinlock_t          page_lock;              /* Page register locks */
+    struct AES_txdesc *AES_tx_ring0;
+
+	struct AES_rxdesc *AES_rx_ring0;
+	int (*DoneIntCallback)(uint32_t, uint32_t);
+	struct work_struct  reset_task;
+};
+
+int AesProcessScatterGather(
+	struct scatterlist* sg_src,
+	struct scatterlist* sg_dst,
+	uint32_t TransCount,
+	uint8_t*	Key,
+	uint8_t*	IV,
+	uint32_t	aes_mode
+	);
+void AesRxHandler(unsigned long data);
+int AesGenPattern(int tv, int seq, int enc);
+int AesResultVerify(int tv, int seq,int enc);
+int AesKickEngine(void);
+
+#define AES_128		0
+#define AES_192		1
+#define AES_256		2
+
+#define ENCRYPTION		(1<<2)
+#define CARRY_USERDATA	(1<<3)
+#define CBC_MODE		(1<<4)
+#define RESTORE_IV		(1<<5)
+#define VALID_IV		(1<<6)
+#endif
+
+#define PROCNAME    "aes_engine"
+
diff --git a/drivers/crypto/aes_engine/aes_pattern.h b/drivers/crypto/aes_engine/aes_pattern.h
new file mode 100755
index 0000000..ccf7d35
--- /dev/null
+++ b/drivers/crypto/aes_engine/aes_pattern.h
@@ -0,0 +1,197 @@
+#define MAX_TEST_VECTOR	10
+#define MAX_TEST_SEQ	20
+#define MAX_SG_BUF		8
+
+extern unsigned char padlock_aes_c[];
+extern unsigned char padlock_aes_c_aes[];
+
+typedef struct test_pattern_s
+{
+	uint32_t	src_multipage;
+	uint32_t	dst_multipage;
+	uint32_t	src_offset[MAX_SG_BUF];
+	uint32_t	dst_offset[MAX_SG_BUF];
+	uint32_t	src_length[MAX_SG_BUF];
+	uint32_t	dst_length[MAX_SG_BUF];
+	uint32_t	totallen;
+	uint32_t	plainlen;
+	uint32_t	cipherlen;
+	uint32_t	mode;
+	const uint8_t*	key;
+	const uint8_t*	iv;
+	const uint8_t*	plaintext;
+	const uint8_t*	ciphertext;
+
+}test_pattern_t;
+
+test_pattern_t pattern[MAX_TEST_VECTOR] = {
+	/* single TX + single RX + 4 byte align */
+	{
+		.src_multipage = 1,
+		.dst_multipage = 1,
+		.src_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.dst_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_128,
+		.key = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.iv = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F",
+		.plaintext = "\x00\x11\x22\x33\x44\x55\x66\x77\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.ciphertext = "\x69\xc4\xe0\xd8\x6a\x7b\x04\x30\xd8\xcd\xb7\x80\x70\xb4\xc5\x5a"
+	},
+	{
+		.src_multipage = 1,
+		.dst_multipage = 1,
+		.src_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.dst_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_128|CBC_MODE,
+		.key = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c",
+		.iv = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F",
+		.plaintext = "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a",
+		.ciphertext = "\x76\x49\xab\xac\x81\x19\xb2\x46\xce\xe9\x8e\x9b\x12\xe9\x19\x7d",
+	},
+		{
+		.src_multipage = 1,
+		.dst_multipage = 1,
+		.src_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {1, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {16, 10, 0, 0, 0, 0, 0, 0},
+		.dst_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_192|CBC_MODE,
+		.key = "\x8e\x73\xb0\xf7\xda\x0e\x64\x52\xc8\x10\xf3\x2b\x80\x90\x79\xe5\x62\xf8\xea\xd2\x52\x2c\x6b\x7b",
+		.iv = "\x4F\x02\x1D\xB2\x43\xBC\x63\x3D\x71\x78\x18\x3A\x9F\xA0\x71\xE8",
+		.plaintext = "\xae\x2d\x8a\x57\x1e\x03\xac\x9c\x9e\xb7\x6f\xac\x45\xaf\x8e\x51",
+		.ciphertext = "\xb4\xd9\xad\xa9\xad\x7d\xed\xf4\xe5\xe7\x38\x76\x3f\x69\x14\x5a",
+	},
+	{
+		.src_multipage = 1,
+		.dst_multipage = 1,
+		.src_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.dst_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_256|CBC_MODE,
+		.key = "\x60\x3d\xeb\x10\x15\xca\x71\xbe\x2b\x73\xae\xf0\x85\x7d\x77\x81\x1f\x35\x2c\x07\x3b\x61\x08\xd7\x2d\x98\x10\xa3\x09\x14\xdf\xf4",
+		.iv = "\x39\xF2\x33\x69\xA9\xD9\xBA\xCF\xA5\x30\xE2\x63\x04\x23\x14\x61",
+		.plaintext = "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.ciphertext = "\xb2\xeb\x05\xe2\xc3\x9b\xe9\xfc\xda\x6c\x19\x07\x8c\x6a\x9d\x1b",
+	},
+	/* Multi TX + Multi RX + 4 byte align */
+	{
+		.src_multipage = 2,
+		.dst_multipage = 2,
+		.src_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {4, 12, 0, 0, 0, 0, 0, 0},
+		.dst_length = {8, 8, 0, 0, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_128,
+		.key = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f",
+		.iv = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F",
+		.plaintext = "\x00\x11\x22\x33\x44\x55\x66\x77\x88\x99\xaa\xbb\xcc\xdd\xee\xff",
+		.ciphertext = "\x69\xc4\xe0\xd8\x6a\x7b\x04\x30\xd8\xcd\xb7\x80\x70\xb4\xc5\x5a"
+	},
+	{
+		.src_multipage = 2,
+		.dst_multipage = 4,
+		.src_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {6, 10, 0, 0, 0, 0, 0, 0},
+		.dst_length = {4, 4, 4, 4, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_128|CBC_MODE,
+		.key = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c",
+		.iv = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F",
+		.plaintext = "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a",
+		.ciphertext = "\x76\x49\xab\xac\x81\x19\xb2\x46\xce\xe9\x8e\x9b\x12\xe9\x19\x7d",
+	},
+	/* Multi TX any byte align + single RX any byte align */
+	{
+		.src_multipage = 2,
+		.dst_multipage = 1,
+		.src_offset = {1, 3, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {1, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {6, 10, 0, 0, 0, 0, 0, 0},
+		.dst_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_192|CBC_MODE,
+		.key = "\x8e\x73\xb0\xf7\xda\x0e\x64\x52\xc8\x10\xf3\x2b\x80\x90\x79\xe5\x62\xf8\xea\xd2\x52\x2c\x6b\x7b",
+		.iv = "\x4F\x02\x1D\xB2\x43\xBC\x63\x3D\x71\x78\x18\x3A\x9F\xA0\x71\xE8",
+		.plaintext = "\xae\x2d\x8a\x57\x1e\x03\xac\x9c\x9e\xb7\x6f\xac\x45\xaf\x8e\x51",
+		.ciphertext = "\xb4\xd9\xad\xa9\xad\x7d\xed\xf4\xe5\xe7\x38\x76\x3f\x69\x14\x5a",
+	},
+	{
+		.src_multipage = 1,
+		.dst_multipage = 1,
+		.src_offset = {2, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {3, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.dst_length = {16, 0, 0, 0, 0, 0, 0, 0},
+		.totallen = 16,
+		.plainlen = 16,
+		.cipherlen = 16,
+		.mode = AES_256|CBC_MODE,
+		.key = "\x60\x3d\xeb\x10\x15\xca\x71\xbe\x2b\x73\xae\xf0\x85\x7d\x77\x81\x1f\x35\x2c\x07\x3b\x61\x08\xd7\x2d\x98\x10\xa3\x09\x14\xdf\xf4",
+		.iv = "\x39\xF2\x33\x69\xA9\xD9\xBA\xCF\xA5\x30\xE2\x63\x04\x23\x14\x61",
+		.plaintext = "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.ciphertext = "\xb2\xeb\x05\xe2\xc3\x9b\xe9\xfc\xda\x6c\x19\x07\x8c\x6a\x9d\x1b",
+	},
+/*
+	{
+		.src_multipage = 6,
+		.dst_multipage = 6,
+		.src_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.dst_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {2592, 2592, 2592, 2592, 2592, 2448, 0, 0},
+		.dst_length = {2592, 2592, 2592, 2592, 2592, 2448, 0, 0},
+		.totallen = 15397,
+		.plainlen = 15397,
+		.cipherlen = 15408,
+		.mode = AES_128|CBC_MODE,
+		//.mode = AES_256|CBC_MODE,
+		.key = "\x25\xF9\xE7\x94\x32\x3B\x45\x38\x85\xF5\x18\x1F\x1B\x62\x4D\x0B",
+		.iv =  "\x5A\x5A\xA5\xA5\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
+		.plaintext = padlock_aes_c,
+		.ciphertext = padlock_aes_c_aes
+	},
+	{
+		.src_multipage = 6,
+		.dst_multipage = 6,
+		.src_offset = {2, 3, 4, 5, 6, 7, 0, 0},
+		.dst_offset = {0, 0, 0, 0, 0, 0, 0, 0},
+		.src_length = {2591, 2593, 2593, 2591, 2593, 2447, 0, 0},
+		.dst_length = {2591, 2593, 2592, 2592, 2592, 2448, 0, 0},
+		.totallen = 15397,
+		.plainlen = 15397,
+		.cipherlen = 15408,
+		.mode = AES_128|CBC_MODE,
+		//.mode = AES_256|CBC_MODE,
+		.key = "\x25\xF9\xE7\x94\x32\x3B\x45\x38\x85\xF5\x18\x1F\x1B\x62\x4D\x0B",
+		.iv =  "\x5A\x5A\xA5\xA5\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
+		.plaintext = padlock_aes_c,
+		.ciphertext = padlock_aes_c_aes
+	}
+*/
+};
+
+
diff --git a/drivers/crypto/aes_engine/mcrypto_aes_api.c b/drivers/crypto/aes_engine/mcrypto_aes_api.c
new file mode 100755
index 0000000..c52a821
--- /dev/null
+++ b/drivers/crypto/aes_engine/mcrypto_aes_api.c
@@ -0,0 +1,283 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/crypto.h>
+#include <linux/spinlock.h>
+#include <crypto/algapi.h>
+#include <crypto/aes.h>
+#include <linux/spinlock_types.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+#include <linux/sched.h>
+#endif
+
+#include "mcrypto_aes_api.h"
+#include "aes_engine.h"
+
+
+//#define LINUX_CRYPTO_API	1
+
+int mcrypto_setkey_blk(struct crypto_tfm *tfm, const u8 *key,
+		unsigned int len)
+{
+	struct mcrypto_ctx *ctx = crypto_tfm_ctx(tfm);
+	unsigned int ret;
+
+	ctx->keylen = len;
+	if (!ctx->pData)
+		ctx->pData = (void*)tfm->__crt_alg;
+
+	memcpy(ctx->key, key, len);
+
+	{
+		int i;
+		DBGPRINT(DBG_LOW, "key[] = [");
+		for(i=0;i<len;i++)
+			DBGPRINT(DBG_LOW, "%02X ",ctx->key[i]);
+		DBGPRINT(DBG_LOW, "]\n");
+	}
+
+	ctx->fallback.blk->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;
+	ctx->fallback.blk->base.crt_flags |= (tfm->crt_flags & CRYPTO_TFM_REQ_MASK);
+
+	ret = crypto_blkcipher_setkey(ctx->fallback.blk, key, len);
+	if (ret) {
+		tfm->crt_flags &= ~CRYPTO_TFM_RES_MASK;
+		tfm->crt_flags |= (ctx->fallback.blk->base.crt_flags & CRYPTO_TFM_RES_MASK);
+	}
+	return ret;
+}
+
+int fallback_blk_dec(struct blkcipher_desc *desc,
+		struct scatterlist *dst, struct scatterlist *src,
+		unsigned int nbytes)
+{
+	unsigned int ret;
+	struct crypto_blkcipher *tfm;
+	struct mcrypto_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+
+	tfm = desc->tfm;
+	desc->tfm = ctx->fallback.blk;
+
+	ret = crypto_blkcipher_decrypt_iv(desc, dst, src, nbytes);
+
+	desc->tfm = tfm;
+	return ret;
+}
+
+int fallback_blk_enc(struct blkcipher_desc *desc,
+		struct scatterlist *dst, struct scatterlist *src,
+		unsigned int nbytes)
+{
+	unsigned int ret;
+	struct crypto_blkcipher *tfm;
+	struct mcrypto_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+
+	tfm = desc->tfm;
+	desc->tfm = ctx->fallback.blk;
+
+	ret = crypto_blkcipher_encrypt_iv(desc, dst, src, nbytes);
+
+	desc->tfm = tfm;
+
+	return ret;
+}
+
+static int
+mcrypto_cbc_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct mcrypto_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+	int err;
+
+#ifdef LINUX_CRYPTO_API
+	return fallback_blk_dec(desc, dst, src, nbytes);
+#endif
+	//if (nbytes < 256)
+	//	return fallback_blk_dec(desc, dst, src, nbytes);
+
+	DBGPRINT(DBG_LOW, "(%d)%s nbytes=%d\n",__LINE__,__func__,nbytes);
+
+	memcpy(ctx->iv, desc->info, AES_IV_LENGTH);
+	if (ctx->keylen == 32)
+		ctx->mode = AES_256;
+	else if (ctx->keylen == 24)
+		ctx->mode = AES_192;
+	else
+		ctx->mode = AES_128;
+	ctx->mode |= (CBC_MODE);
+	err = AesProcessScatterGather(src, dst, nbytes, ctx->key, ctx->iv, ctx->mode);
+
+	return err;
+}
+
+
+static int
+mcrypto_cbc_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct mcrypto_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+	int err;
+
+#ifdef LINUX_CRYPTO_API
+	return fallback_blk_enc(desc, dst, src, nbytes);
+#endif
+
+	DBGPRINT(DBG_LOW, "(%d)%s keylen=%d nbytes=%d\n",__LINE__,__func__,ctx->keylen, nbytes);
+
+	//if (nbytes < 256)
+	//	return fallback_blk_enc(desc, dst, src, nbytes);
+
+	memcpy(ctx->iv, desc->info, AES_IV_LENGTH);
+	if (ctx->keylen == 32)
+		ctx->mode = AES_256;
+	else if (ctx->keylen == 24)
+		ctx->mode = AES_192;
+	else
+		ctx->mode = AES_128;
+	ctx->mode |= (CBC_MODE | ENCRYPTION);
+	err = AesProcessScatterGather(src, dst, nbytes, ctx->key, ctx->iv, ctx->mode);
+
+	return err;
+}
+
+static int
+mcrypto_aes_decrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct mcrypto_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+	int err;
+
+#ifdef LINUX_CRYPTO_API
+	return fallback_blk_dec(desc, dst, src, nbytes);
+#endif
+	//if (nbytes < 256)
+	//	return fallback_blk_dec(desc, dst, src, nbytes);
+
+	DBGPRINT(DBG_LOW, "(%d)%s keylen=%d nbytes=%d\n",__LINE__,__func__,ctx->keylen, nbytes);
+
+	if (ctx->keylen == 32)
+		ctx->mode = AES_256;
+	else if (ctx->keylen == 24)
+		ctx->mode = AES_192;
+	else
+		ctx->mode = AES_128;
+
+	err = AesProcessScatterGather(src, dst, nbytes, ctx->key, ctx->iv, ctx->mode);
+
+	return err;
+}
+
+static int
+mcrypto_aes_encrypt(struct blkcipher_desc *desc,
+		  struct scatterlist *dst, struct scatterlist *src,
+		  unsigned int nbytes)
+{
+	struct mcrypto_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+	int err;
+
+#ifdef LINUX_CRYPTO_API
+	return fallback_blk_enc(desc, dst, src, nbytes);
+#endif
+
+	DBGPRINT(DBG_LOW, "(%d)%s keylen=%d nbytes=%d\n",__LINE__,__func__,ctx->keylen, nbytes);
+
+	//if (nbytes < 256)
+	//	return fallback_blk_enc(desc, dst, src, nbytes);
+
+	if (ctx->keylen == 32)
+		ctx->mode = AES_256;
+	else if (ctx->keylen == 24)
+		ctx->mode = AES_192;
+	else
+		ctx->mode = AES_128;
+	ctx->mode |= ENCRYPTION;
+	err = AesProcessScatterGather(src, dst, nbytes, ctx->key, ctx->iv, ctx->mode);
+
+	return err;
+}
+
+int fallback_init_blk(struct crypto_tfm *tfm)
+{
+	const char *name = tfm->__crt_alg->cra_name;
+	struct mcrypto_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	ctx->fallback.blk = crypto_alloc_blkcipher(name, 0,
+			CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK);
+
+	ctx->pData = (void*)tfm->__crt_alg;
+	if (IS_ERR(ctx->fallback.blk)) {
+		printk(KERN_ERR "Error allocating blk fallback algo %s\n", name);
+		return PTR_ERR(ctx->fallback.blk);
+	}
+
+	return 0;
+}
+
+void fallback_exit_blk(struct crypto_tfm *tfm)
+{
+	struct mcrypto_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	crypto_free_blkcipher(ctx->fallback.blk);
+	ctx->fallback.blk = NULL;
+}
+
+
+
+struct crypto_alg mcrypto_cbc_alg = {
+	.cra_name		=	"cbc(aes)",
+	.cra_driver_name	=	"cbc-aes-mcrypto",
+	.cra_priority		=	400,
+	.cra_flags			=	CRYPTO_ALG_TYPE_BLKCIPHER |
+							CRYPTO_ALG_NEED_FALLBACK,
+	.cra_init			=	fallback_init_blk,
+	.cra_exit			=	fallback_exit_blk,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct mcrypto_ctx),
+	.cra_alignmask		=	15,
+	.cra_type			=	&crypto_blkcipher_type,
+	.cra_module			=	THIS_MODULE,
+	.cra_list			=	LIST_HEAD_INIT(mcrypto_cbc_alg.cra_list),
+	.cra_u				=	{
+		.blkcipher	=	{
+			.min_keysize	=	AES_MIN_KEY_SIZE,
+			.max_keysize	=	AES_MAX_KEY_SIZE,
+			.setkey			=	mcrypto_setkey_blk,
+			.encrypt		=	mcrypto_cbc_encrypt,
+			.decrypt		=	mcrypto_cbc_decrypt,
+			.ivsize			=	AES_IV_LENGTH,
+		}
+	}
+};
+
+struct crypto_alg mcrypto_aes_alg = {
+	.cra_name		=	"aes",
+	.cra_driver_name	=	"aes-mcrypto",
+	.cra_priority		=	400,
+	.cra_flags			=	CRYPTO_ALG_TYPE_BLKCIPHER |
+							CRYPTO_ALG_NEED_FALLBACK,
+	.cra_init			=	fallback_init_blk,
+	.cra_exit			=	fallback_exit_blk,
+	.cra_blocksize		=	AES_MIN_BLOCK_SIZE,
+	.cra_ctxsize		=	sizeof(struct mcrypto_ctx),
+	.cra_alignmask		=	15,
+	.cra_type			=	&crypto_blkcipher_type,
+	.cra_module			=	THIS_MODULE,
+	.cra_list			=	LIST_HEAD_INIT(mcrypto_aes_alg.cra_list),
+	.cra_u				=	{
+		.blkcipher	=	{
+			.min_keysize	=	AES_MIN_KEY_SIZE,
+			.max_keysize	=	AES_MAX_KEY_SIZE,
+			.setkey			=	mcrypto_setkey_blk,
+			.encrypt		=	mcrypto_aes_encrypt,
+			.decrypt		=	mcrypto_aes_decrypt,
+			.ivsize			=	0,
+		}
+	}
+};
diff --git a/drivers/crypto/aes_engine/mcrypto_aes_api.h b/drivers/crypto/aes_engine/mcrypto_aes_api.h
new file mode 100755
index 0000000..38aac22
--- /dev/null
+++ b/drivers/crypto/aes_engine/mcrypto_aes_api.h
@@ -0,0 +1,50 @@
+#ifndef _MCRYPTO_AES_API_H_
+#define _MCRYPTO_AES_API_H_
+
+#include <linux/crypto.h>
+
+#define WORDSWAP(a)     	((((a)>>24)&0xff) | (((a)>>8)&0xff00) | (((a)<<8)&0xff0000) | (((a)<<24)&0xff000000))
+
+/* driver logic flags */
+#define AES_IV_LENGTH  16
+#define AES_KEY_LENGTH 16
+#define AES_MIN_BLOCK_SIZE 16
+
+struct mcrypto_ctx {
+	/* common */
+	int totallen;
+	u8 key[32+4];
+	u32 keylen;
+	u32 mode;
+
+	/* cipher */
+	u8 iv[AES_IV_LENGTH];
+	union {
+		struct crypto_blkcipher *blk;
+		struct crypto_cipher *cip;
+	} fallback;
+	void* pData;
+};
+
+
+
+extern int hmac_setkey_base(struct mcrypto_ctx *ctx,
+		const u8 *key, unsigned int keylen);
+
+extern int mcrypto_setkey_blk(struct crypto_tfm *tfm, const u8 *key,
+		unsigned int len);
+extern int fallback_blk_dec(struct blkcipher_desc *desc,
+		struct scatterlist *dst, struct scatterlist *src,
+		unsigned int nbytes);
+extern int fallback_blk_enc(struct blkcipher_desc *desc,
+		struct scatterlist *dst, struct scatterlist *src,
+		unsigned int nbytes);
+extern int fallback_init_blk(struct crypto_tfm *tfm);
+extern void fallback_exit_blk(struct crypto_tfm *tfm);
+
+
+
+extern struct crypto_alg mcrypto_cbc_alg;
+extern struct crypto_alg mcrypto_aes_alg;
+
+#endif /* !_MCRYPTO_AES_API_H_ */
diff --git a/drivers/net/cryptoDriver/Makefile b/drivers/net/cryptoDriver/Makefile
new file mode 100755
index 0000000..30cde1e
--- /dev/null
+++ b/drivers/net/cryptoDriver/Makefile
@@ -0,0 +1,53 @@
+#
+#
+#
+
+SRC_APP=source
+SRC_UTILS=source/utils
+
+
+# Include Paths
+INCLUDE_APP:= \
+ -I$(obj)/include
+
+
+INCLUDE_FLAGS_ALL:= \
+  $(INCLUDE_APP)
+
+
+# Compiler Flags
+WARNING_FLAGS=
+DEBUG_FLAGS=-g
+CODE_COVERAGE_FLAGS=
+PROFILING_FLAGS=
+BACKWARD_COMPATIBILITY_FLAGS=
+
+EXTRA_CFLAGS += $(BACKWARD_COMPATIBILITY_FLAGS)
+EXTRA_CFLAGS += $(INCLUDE_FLAGS_ALL)
+EXTRA_CFLAGS += $(WARNING_FLAGS)
+EXTRA_CFLAGS += $(DEBUG_FLAGS)
+EXTRA_CFLAGS += $(CODE_COVERAGE_FLAGS)
+EXTRA_CFLAGS += $(PROFILING_FLAGS)
+EXTRA_CFLAGS += -DRT_EIP93_DRIVER
+EXTRA_CFLAGS += -DRT_EIP93_DRIVER_DEBUG -DRT_EIP93_DRIVER_DEBUG_H
+EXTRA_CFLAGS += -DMTK_CRYPTO_DRIVER
+#EXTRA_CFLAGS += -I$(MODULES_KPROFILE_DIR)
+#EXTRA_CFLAGS += -DEXPORT_SYMTAB -D__KERNEL_SYSCALLS__
+
+ifeq ($(CONFIG_RA_NETWORK_WORKQUEUE_BH),y)
+EXTRA_CFLAGS   += -DWORKQUEUE_BH
+endif
+
+obj-$(CONFIG_RALINK_HWCRYPTO) += crypto_k.o
+crypto_k-objs:= \
+	$(SRC_UTILS)/mtk_sLib.o \
+	$(SRC_UTILS)/mtk_arm.o \
+	$(SRC_UTILS)/mtk_ringHelper.o \
+	$(SRC_UTILS)/mtk_hwDevice.o \
+	$(SRC_UTILS)/mtk_hwDmaResource.o \
+	$(SRC_UTILS)/mtk_dmaBufHelper.o \
+	$(SRC_APP)/mtk_pktProcess.o \
+	$(SRC_APP)/mtk_eip93Init.o \
+	$(SRC_APP)/mtk_pecInit.o \
+	$(SRC_APP)/mtk_interruptHelper.o \
+	$(SRC_APP)/mtk_init.o
diff --git a/drivers/net/cryptoDriver/include/mtk_AdapterInternal.h b/drivers/net/cryptoDriver/include/mtk_AdapterInternal.h
new file mode 100755
index 0000000..a64b800
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_AdapterInternal.h
@@ -0,0 +1,139 @@
+
+#ifndef EIP93_ADAPTER_INTERNAL_H
+#define EIP93_ADAPTER_INTERNAL_H
+
+#include "mtk_baseDefs.h"
+#include "mtk_cLib.h"
+#include "mtk_hwDmaAccess.h"          // HWPAL_DMAResource_t
+#include "mtk_dmaBuf.h"             // DMABuf_Handle_t
+#include "mtk_eip93.h"                // EIP93_IOArea_t
+#include "mtk_cAdapter.h"
+
+
+/*----------------------------------------------------------------------------
+ *                           Implementation helper macros
+ *----------------------------------------------------------------------------
+ */
+
+#define ZEROINIT(_x)  memset(&_x, 0, sizeof(_x))
+
+
+
+/*----------------------------------------------------------------------------
+ *                           Adapter_EIP93
+ *----------------------------------------------------------------------------
+ */
+
+extern EIP93_IOArea_t Adapter_EIP93_IOArea;
+extern unsigned int Adapter_EIP93_MaxDescriptorsInRing;
+
+bool
+Adapter_EIP93_Init(void);
+
+bool
+Adapter_EIP93_SetMode_Idle(void);
+
+bool
+Adapter_EIP93_SetMode_ARM(
+        const bool fEnableDynamicSA);
+
+
+void
+Adapter_EIP93_UnInit(void);
+
+
+void
+Adapter_GetEIP93PhysAddr(
+        DMABuf_Handle_t Handle,
+        HWPAL_DMAResource_Handle_t * const DMAHandle_p,
+        EIP93_DeviceAddress_t * const EIP93PhysAddr_p);
+
+#ifdef MTK_CRYPTO_DRIVER
+extern void mtk_interruptHandler_descriptorDone(void);
+extern void mtk_BH_handler_resultGet(unsigned long data);
+#endif
+
+/*----------------------------------------------------------------------------
+ * Adapter_EIP93_InterruptHandler_DescriptorDone
+ *
+ * This function is invoked when the EIP93 has activated the descriptor done
+ * interrupt.
+ */
+extern void
+Adapter_EIP93_InterruptHandler_DescriptorDone(void);
+
+
+extern void
+Adapter_EIP93_BH_Handler_ResultGet(
+        unsigned long data);
+
+
+/*----------------------------------------------------------------------------
+ *                           Adapter_Interrupts
+ *----------------------------------------------------------------------------
+ */
+
+bool
+Adapter_Interrupts_Init(
+        const int nIRQ);
+
+void
+Adapter_Interrupts_UnInit(void);
+
+typedef void (* Adapter_InterruptHandler_t)(void);
+
+// nIRQ is defined in mtk_interrupts.h
+void
+Adapter_Interrupt_SetHandler(
+        const int nIRQ,
+        Adapter_InterruptHandler_t HandlerFunction);
+
+void
+Adapter_Interrupt_Enable(
+        const int nIRQ);
+
+void
+Adapter_Interrupt_ClearAndEnable(
+        const int nIRQ);
+
+void
+Adapter_Interrupt_Disable(
+        const int nIRQ);
+
+
+
+
+/*----------------------------------------------------------------------------
+ *                           Adapter_DMABuf
+ *----------------------------------------------------------------------------
+ */
+
+#define ADAPTER_DMABUF_ALLOCATORREF_KMALLOC 'k'   /* kmalloc */
+
+extern const DMABuf_Handle_t Adapter_DMABuf_NullHandle;
+
+bool
+Adapter_DMABuf_IsValidHandle(
+        DMABuf_Handle_t Handle);
+
+HWPAL_DMAResource_Handle_t
+Adapter_DMABuf_Handle2DMAResourceHandle(
+        DMABuf_Handle_t Handle);
+
+bool
+Adapter_DMABuf_IsForeignAllocated(
+        DMABuf_Handle_t Handle);
+
+bool
+Adapter_DMABuf_IsSameHandle(
+        const DMABuf_Handle_t * const Handle1_p,
+        const DMABuf_Handle_t * const Handle2_p);
+
+/*----------------------------------------------------------------------------
+ *                           VTBAL Global device
+ *----------------------------------------------------------------------------
+ */
+extern void *  GlobalVTBALDevice ;
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_L0.h b/drivers/net/cryptoDriver/include/mtk_L0.h
new file mode 100755
index 0000000..e24e20e
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_L0.h
@@ -0,0 +1,490 @@
+
+#ifndef EIP93_LEVEL0_H
+#define EIP93_LEVEL0_H
+
+#include "mtk_baseDefs.h"             // BIT definitions, bool, uint32_t
+#include "mtk_hwAccess.h"              // Read32, Write32, HWPAL_Device_t
+#include "mtk_hwDmaAccess.h"          // Read32, Write32, HWPAL_DMAResource_t
+#include "mtk_arm.h"            // the API we will implement
+#include "mtk_hwInterface.h"   // the HW interface (register map)
+
+/*-----------------------------------------------------------------------------
+ * EIP93_Read32
+ *
+ * This routine writes to a Register  location in the EIP93.
+ */
+static inline uint32_t
+EIP93_Read32(
+        HWPAL_Device_t Device,
+        const unsigned int Offset)
+{
+    return HWPAL_Device_Read32(Device, Offset);
+}
+
+
+/*-----------------------------------------------------------------------------
+ * EIP93_Write32
+ *
+ * This routine writes to a Register location in the EIP93.
+ */
+static inline void
+EIP93_Write32(
+        HWPAL_Device_t Device,
+        const unsigned int  Offset,
+        const uint32_t Value)
+{
+    HWPAL_Device_Write32(Device, Offset, Value);
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_Read32Array
+ *
+ * This routine reads from a array of Register/OUT_RAM  memory locations in
+ * the EIP93.
+ */
+static inline void
+EIP93_Read32Array(
+        HWPAL_Device_t Device,
+        unsigned int Offset,            // read starts here, +4 increments
+        uint32_t * MemoryDst_p,         // writing starts here
+        const int Count)               // number of uint32's to transfer
+{
+    HWPAL_Device_Read32Array(Device, Offset, MemoryDst_p, Count);
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_Write32Array
+ *
+ * This routine writes to a array of Register/IN_RAM memory locations in
+ * the EIP93.
+ */
+static inline void
+EIP93_Write32Array(
+        HWPAL_Device_t Device,
+        unsigned int Offset,            // write starts here, +4 increments
+        uint32_t * MemorySrc_p,         // writing starts here
+        const int Count)               // number of uint32's to transfer
+{
+    HWPAL_Device_Write32Array(Device, Offset, MemorySrc_p, Count);
+}
+
+
+/*-----------------------------------------------------------------------------
+ * EIP93 register routines
+ *
+ * These routines write/read register values in EIP93 registers
+ * in HW specific format.
+ *
+ * Note: if a function argument implies a flag ('f' is a prefix),
+ *       then only the values 0 or 1 are allowed for this argument.
+ */
+static inline void
+EIP93_Write32_PE_CFG(
+        HWPAL_Device_t Device,
+        const uint8_t fRstPacketEngine,
+        const uint8_t fResetRing,
+        const uint8_t PE_Mode,
+        const uint8_t fBO_PD_en,
+        const uint8_t fBO_SA_en,
+        const uint8_t fBO_Data_en,
+        const uint8_t fBO_TD_en,
+    const uint8_t fEnablePDRUpdate)
+{
+    EIP93_Write32(
+            Device,
+            EIP93_REG_PE_CONFIG,
+            (fRstPacketEngine & 1) |
+            ((fResetRing & 1) << 1) |
+            ((PE_Mode &(BIT_2-1)) << 8) |
+            ((fBO_PD_en & 1) << 16) |
+            ((fBO_SA_en & 1) << 17) |
+            ((fBO_Data_en  & 1) << 18) |
+            ((fBO_TD_en & 1) << 20) |
+            ((fEnablePDRUpdate & 1) << 10));
+}
+
+
+static inline void
+EIP93_Read32_PE_CFG(
+        HWPAL_Device_t Device,
+        uint8_t * const fBO_PD_en,
+        uint8_t * const fBO_SA_en,
+        uint8_t * const fBO_Data_en,
+        uint8_t * const fBO_SGPD_en,
+        uint8_t * const fBO_TD_en)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_CONFIG);
+    if(fBO_PD_en)
+        *fBO_PD_en = (word >> 16) & 1;
+    if(fBO_SA_en)
+        *fBO_SA_en = (word >> 17) & 1;
+    if(fBO_Data_en)
+        *fBO_Data_en = (word >> 18) & 1;
+    if(fBO_SGPD_en)
+        *fBO_SGPD_en = (word >> 19) & 1;
+    if(fBO_TD_en)
+        *fBO_TD_en = (word >> 21) & 1;
+}
+
+
+static inline void
+EIP93_Write32_PE_IO_THRESHOLD(
+        HWPAL_Device_t Device,
+        const uint16_t InputThreshold,
+        const uint16_t OutputThreshold)
+{
+    EIP93_Write32(
+            Device,
+           EIP93_REG_PE_BUF_THRESH,
+            (InputThreshold & (BIT_10-1)) |
+        ((OutputThreshold & (BIT_10-1)) << 16));
+}
+
+
+static inline void
+EIP93_Read32_PE_IO_THRESHOLD(
+        HWPAL_Device_t Device,
+        uint16_t * const InputThreshold,
+        uint16_t * const OutputThreshold)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_BUF_THRESH);
+    if(InputThreshold)
+        *InputThreshold = word & (BIT_10-1);
+    if(OutputThreshold)
+        *OutputThreshold = (word >> 16) & (BIT_10-1);
+}
+
+
+
+
+static inline void
+EIP93_Write32_INT_CFG(
+        HWPAL_Device_t Device,
+        const uint8_t fIntHostOutputType,
+        const uint8_t fIntPulseClear)
+{
+    EIP93_Write32(Device, EIP93_REG_INT_CFG,
+                  (fIntHostOutputType & 1 ) |
+                  ((fIntPulseClear << 1) & 1));
+}
+
+static inline void
+EIP93_Read32_INT_CFG(
+        HWPAL_Device_t Device,
+        uint8_t * const fIntHostOutputType,
+        uint8_t * const fIntPulseClear)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_INT_CFG);
+    if(fIntHostOutputType)
+        *fIntHostOutputType = word & 1;
+    if(fIntPulseClear)
+        *fIntPulseClear = (word >> 1) & 1;
+}
+
+
+static inline void
+EIP93_Write32_MST_BYTE_ORDER_CFG(
+        HWPAL_Device_t Device,
+        const uint8_t ByteOrderPD,
+        const uint8_t ByteOrderSA,
+        const uint8_t ByteOrderData,
+        const uint8_t ByteOrderTD)
+{
+    EIP93_Write32(
+            Device,
+            EIP93_REG_PE_ENDIAN_CONFIG,
+            (ByteOrderPD & (BIT_4-1)) |
+            ((ByteOrderSA & (BIT_4-1)) << 4) |
+            ((ByteOrderData & (BIT_4-1)) << 8) |
+            ((ByteOrderTD & (BIT_2-1)) << 16));
+}
+
+static inline void
+EIP93_Read32_MST_BYTE_ORDER_CFG(
+        HWPAL_Device_t Device,
+        uint8_t * const ByteOrderPD,
+        uint8_t * const ByteOrderSA,
+        uint8_t * const ByteOrderData,
+        uint8_t * const ByteOrderTD)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_ENDIAN_CONFIG);
+    if(ByteOrderPD)
+        *ByteOrderPD = word & (BIT_4-1);
+    if(ByteOrderSA)
+        *ByteOrderSA = (word >> 4) & (BIT_4-1);
+    if(ByteOrderData)
+        *ByteOrderData = (word >> 8) & (BIT_4-1);
+    if(ByteOrderTD)
+        *ByteOrderTD = (word >> 16) & (BIT_2-1);
+}
+
+static inline void
+EIP93_Read32_PE_OPTIONS_1(
+        HWPAL_Device_t Device,
+        uint8_t * const fDesTdes,
+        uint8_t * const fARC4,
+        uint8_t * const fAES,
+        uint8_t * const fAES128,
+    uint8_t * const fAES192,
+    uint8_t * const fAES256,
+        uint8_t * const fKasumiF8,
+        uint8_t * const fDesOfgCfg,
+        uint8_t * const fAesCfg,
+        uint8_t * const fMD5,
+        uint8_t * const fSHA1,
+        uint8_t * const fSHA224,
+        uint8_t * const fSHA256,
+        uint8_t * const fSHA384,
+        uint8_t * const fSHA512,
+        uint8_t * const fKasumiF9,
+        uint8_t * const fAesXcbc,
+        uint8_t * const fGCM,
+        uint8_t * const fGMAC,
+        uint8_t * const fAesCbcMac,
+    uint8_t * const fAesCbcMac128,
+    uint8_t * const fAesCbcMac192,
+    uint8_t * const fAesCbcMac256)
+
+{
+    uint32_t word = EIP93_Read32(Device,EIP93_REG_PE_OPTION_1);
+    if(fDesTdes)
+        *fDesTdes = word & 1;
+    if(fARC4)
+        *fARC4 = (word >> 1) & 1;
+    if(fAES)
+        *fAES = (word >> 2) & 1;
+    if(fAES128)
+        *fAES128 = (word >> 13) & 1;
+    if(fAES192)
+        *fAES192 = (word >> 14) & 1;
+    if(fAES256)
+        *fAES256 = (word >> 15) & 1;
+    if(fKasumiF8)
+        *fKasumiF8 = 0;
+    if(fDesOfgCfg)
+        *fDesOfgCfg = 0;
+    if(fAesCfg)
+        *fAesCfg = 0;
+    if(fMD5)
+        *fMD5 = (word >> 16) & 1;
+    if(fSHA1)
+        *fSHA1 = (word >> 17) & 1;
+    if(fSHA224)
+        *fSHA224 = (word >> 18) & 1;
+    if(fSHA256)
+        *fSHA256 = (word >> 19) & 1;
+    if(fSHA384)
+        *fSHA384 = 0;
+    if(fSHA512)
+        *fSHA512 = 0;
+    if(fKasumiF9)
+        *fKasumiF9 = 0;
+    if(fAesXcbc)
+        *fAesXcbc = (word >> 23) & 1;
+    if(fGCM)
+        *fGCM = 0;
+    if(fGMAC)
+        *fGMAC = 0;
+    if(fAesCbcMac)
+        *fAesCbcMac = (word >> 28) & 1;
+    if(fAesCbcMac128)
+        *fAesCbcMac128 = (word >> 29) & 1;
+    if(fAesCbcMac192)
+        *fAesCbcMac192 = (word >> 30) & 1;
+    if(fAesCbcMac256)
+        *fAesCbcMac256 = (word >> 31) & 1;
+
+}
+
+static inline void
+EIP93_Read32_PE_OPTIONS_0(
+        HWPAL_Device_t Device,
+        uint8_t * const fInterfaceType,
+        uint8_t * const f64BitAdrIndicator,
+        uint8_t * const fExtInterupt,
+        uint8_t * const fPRNG,
+        uint8_t * const fSARev1,
+        uint8_t * const fSARev2,
+        uint8_t * const fDynamicSA,
+        uint8_t * const fESN,
+        uint8_t * const fESP,
+        uint8_t * const fAH,
+        uint8_t * const fSSL,
+        uint8_t * const fTLS,
+        uint8_t * const fDTLS,
+        uint8_t * const fSRTP,
+        uint8_t * const fMacSec)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_OPTION_0);
+    if(fInterfaceType)
+        *fInterfaceType = word & (BIT_3-1);
+    if(f64BitAdrIndicator)
+        *f64BitAdrIndicator = 0;
+    if(fExtInterupt)
+        *fExtInterupt = 0;
+    if(fPRNG)
+        *fPRNG = (word >> 6) & 1;
+    if(fSARev1)
+        *fSARev1 =  1;
+    if(fSARev2)
+        *fSARev2 = 0;
+    if(fDynamicSA)
+        *fDynamicSA = 0;
+    if(fESN)
+        *fESN = (word >> 15) & 1;
+    if(fESP)
+        *fESP = (word >> 16) & 1;
+    if(fAH)
+        *fAH = (word >> 17) & 1;
+    if(fSSL)
+        *fSSL = (word >> 20) & 1;
+    if(fTLS)
+        *fTLS = (word >> 21) & 1;
+    if(fDTLS)
+        *fDTLS = (word >> 22) & 1;
+    if(fSRTP)
+        *fSRTP = (word >> 24) & 1;
+    if(fMacSec)
+        *fMacSec = (word >> 25) & 1;
+}
+
+static inline void
+EIP93_Read32_REVISION_REG(
+        HWPAL_Device_t Device,
+        uint8_t * const EIPNumber,
+        uint8_t * const ComplEIPNumber,
+        uint8_t * const HWPatchLevel,
+        uint8_t * const MinHWRevision,
+        uint8_t * const MajHWRevision)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_REVISION);
+    if(EIPNumber)
+        *EIPNumber = word & (BIT_8-1);
+    if(ComplEIPNumber)
+        *ComplEIPNumber = (word >> 8) & (BIT_8-1);
+    if(HWPatchLevel)
+        *HWPatchLevel = (word >> 16) & (BIT_4-1);
+    if(MinHWRevision)
+        *MinHWRevision = (word >> 20) & (BIT_4-1);
+    if(MajHWRevision)
+        *MajHWRevision = (word >> 24) & (BIT_4-1);
+}
+
+/*-----------------------------------------------------------------------------
+ * PRNG_SEED (0-3) - Write Only
+ */
+static inline void
+EIP93_Write32_PRNG_SEED_0(
+        HWPAL_Device_t Device,
+        const uint32_t SecretSeed)
+{
+    EIP93_Write32(Device,  EIP93_REG_PRNG_SEED_0, SecretSeed);
+}
+
+
+static inline void
+EIP93_Write32_PRNG_SEED_1(
+        HWPAL_Device_t Device,
+        const uint32_t SecretSeed)
+{
+    EIP93_Write32(Device,  EIP93_REG_PRNG_SEED_1, SecretSeed);
+}
+static inline void
+EIP93_Write32_PRNG_SEED_2(
+        HWPAL_Device_t Device,
+        const uint32_t SecretSeed)
+{
+    EIP93_Write32(Device, EIP93_REG_PRNG_SEED_2, SecretSeed);
+}
+
+
+static inline void
+EIP93_Write32_PRNG_SEED_3(
+        HWPAL_Device_t Device,
+        const uint32_t SecretSeed)
+{
+    EIP93_Write32(Device,  EIP93_REG_PRNG_SEED_3, SecretSeed);
+}
+
+
+/*-----------------------------------------------------------------------------
+ * PRNG_KEY (0-3) - Write Only
+ */
+static inline void
+EIP93_Write32_PRNG_KEY_0(
+        HWPAL_Device_t Device,
+        const uint32_t DESKey0)
+{
+    EIP93_Write32(Device,EIP93_REG_PRNG_KEY_0, DESKey0);
+}
+
+
+static inline void
+EIP93_Write32_PRNG_KEY_1(
+        HWPAL_Device_t Device,
+        const uint32_t DESKey1)
+{
+    EIP93_Write32(Device, EIP93_REG_PRNG_KEY_1, DESKey1);
+}
+
+static inline void
+EIP93_Write32_PRNG_KEY_2(
+        HWPAL_Device_t Device,
+        const uint32_t DESKey2)
+{
+    EIP93_Write32(Device,EIP93_REG_PRNG_KEY_2, DESKey2);
+}
+
+
+static inline void
+EIP93_Write32_PRNG_KEY_3(
+        HWPAL_Device_t Device,
+        const uint32_t DESKey3)
+{
+    EIP93_Write32(Device, EIP93_REG_PRNG_KEY_3, DESKey3);
+}
+
+
+
+/*-----------------------------------------------------------------------------
+ * PRNG_LFSR (0-1) - Read/Write
+ */
+static inline void
+EIP93_Write32_PRNG_LFSR_0(
+        HWPAL_Device_t Device,
+        const uint32_t LFSRValue)
+{
+    EIP93_Write32(Device, EIP93_REG_PRNG_LFSR_0, LFSRValue);
+}
+
+static inline void
+EIP93_Read32_PRNG_LFSR_0(
+        HWPAL_Device_t Device,
+        uint32_t * const LFSRValue)
+{
+    if(LFSRValue)
+        *LFSRValue = EIP93_Read32(Device, EIP93_REG_PRNG_LFSR_0);
+}
+
+static inline void
+EIP93_Write32_PRNG_LFSR_1(
+        HWPAL_Device_t Device,
+        const uint32_t LFSRValue)
+{
+    EIP93_Write32(Device, EIP93_REG_PRNG_LFSR_1, LFSRValue);
+}
+
+static inline void
+EIP93_Read32_PRNG_LFSR_1(
+        HWPAL_Device_t Device,
+        uint32_t * const LFSRValue)
+{
+    if(LFSRValue)
+        *LFSRValue = EIP93_Read32(Device, EIP93_REG_PRNG_LFSR_1);
+}
+
+#endif
+
+
diff --git a/drivers/net/cryptoDriver/include/mtk_addrTrans.h b/drivers/net/cryptoDriver/include/mtk_addrTrans.h
new file mode 100755
index 0000000..4025de7
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_addrTrans.h
@@ -0,0 +1,91 @@
+
+#ifndef EIP93_ADDR_TRANS_H
+#define EIP93_ADDR_TRANS_H
+
+#include "mtk_baseDefs.h"
+
+
+/*----------------------------------------------------------------------------
+ * AddrTrans_Domain_t
+ *
+ * This is a list of domains that can be supported by the implementation. The
+ * exact meaning can be different for different EIP devices and different
+ * environments.
+ */
+typedef enum
+{
+    ADDRTRANS_DOMAIN_UNKNOWN,
+    ADDRTRANS_DOMAIN_DRIVER,
+    ADDRTRANS_DOMAIN_DEVICE_PE,
+    ADDRTRANS_DOMAIN_DEVICE_PKA,
+    ADDRTRANS_DOMAIN_BUS,
+    ADDRTRANS_DOMAIN_INTERHOST,
+    ADDRTRANS_DOMAIN_ALTERNATIVE
+} AddrTrans_Domain_t;
+
+
+/*----------------------------------------------------------------------------
+ * AddrTrans_Pair_t
+ *
+ * Address coupled with domain. The caller is encouraged to store the address
+ * with the domain information. The type also avoid unsafe void pointer
+ * output parameters.
+ */
+typedef struct
+{
+    void * Address_p;
+    AddrTrans_Domain_t Domain;
+} AddrTrans_Pair_t;
+
+
+/*----------------------------------------------------------------------------
+ * AddrTrans_Status_t
+ *
+ * Return values for all the API functions.
+ */
+typedef enum
+{
+    ADDRTRANS_STATUS_OK,
+    ADDRTRANS_ERROR_BAD_ARGUMENT,
+    ADDRTRANS_ERROR_CANNOT_TRANSLATE
+} AddrTrans_Status_t;
+
+
+/*----------------------------------------------------------------------------
+ * AddrTrans_Translate
+ *
+ * Attempts to translates an address from one domain to a new domain.
+ *
+ * PairIn
+ *     Source address and domain to covert from.
+ *
+ * AlternativeRef
+ *     When PairIn.Domain equals ADDRTRANS_DOMAIN_ALTERNATIVE, this value is
+ *     used as the domain indicator. It is typically provided directly from
+ *     the application through the DMA Buffer Allocation API.
+ *
+ * DestDomain
+ *     The requested domain to translate PairIn to.
+ *
+ * PairOut_p
+ *     Pointer to the memory location when the converted address plus domain
+ *     will be written.
+ *
+ * Return Values
+ *     ADDRTRANS_STATUS_OK:
+ *         Translation was successful.
+ *     ADDRTRANS_ERROR_BAD_ARGUMENT:
+ *         Invalid parameter.
+ *     ADDRTRANS_ERROR_CANNOT_TRANSLATE:
+ *         Domain (-combination) not supported, or address not in domain.
+ */
+AddrTrans_Status_t
+AddrTrans_Translate(
+        const AddrTrans_Pair_t PairIn,
+        const unsigned int AlternativeRef,
+        AddrTrans_Domain_t DestDomain,
+        AddrTrans_Pair_t * const PairOut_p);
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_arm.h b/drivers/net/cryptoDriver/include/mtk_arm.h
new file mode 100755
index 0000000..af8ce5d
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_arm.h
@@ -0,0 +1,356 @@
+
+#ifndef EIP93_ARM_H
+#define EIP93_ARM_H
+
+#include "mtk_eip93.h"
+#include "mtk_hwDmaAccess.h"
+
+
+
+/*----------------------------------------------------------------------------
+ * Number of 32bit words for a descriptor used in ARM of EIP93
+ *
+ */
+static inline unsigned int
+EIP93_ARM_DESCRIPTOR_SIZE(void )
+{
+#ifdef EIP93_ARM_NUM_OF_DESC_PADDING_WORDS
+
+        return (8+EIP93_ARM_NUM_OF_DESC_PADDING_WORDS);
+
+#else
+
+        return 8;
+
+#endif
+}
+
+
+/*----------------------------------------------------------------------------
+ * Interrupts of  EIP93 valid in ARM
+ */
+typedef enum
+{
+    EIP93_ARM_INT_CDR_THRESHOLD =         BIT_0,
+    EIP93_ARM_INT_RDR_THRESHOLD =         BIT_1,
+
+} EIP93_ARM_InterruptSource_t;
+
+
+/*----------------------------------------------------------------------------
+ * ARM settings
+ * used in _ARM_Activate function as an input
+ */
+typedef struct
+{
+    // Indicate how many 32-bit words of free space (1-511) must be available
+    // in the PE input Data RAM buffer before a  input transfer starts.
+    // A value of 0x20 .. 0x80 generally gives a good performance but
+    // the optimal value depends on the system and application.
+    unsigned int nPEInputThreshold;
+
+    // Indicates how many 32-bit words of data (1-432) must be available in
+    // the PE output Data RAM buffer before a  output transfer starts and
+    // the exact burst length that is actually used for the transfer.
+    // The maximum threshold is  511 words, as this buffer is
+    // also used to store up to 256 pad bytes and a possible 64 bytes ICV that
+    // can be stripped for decrypt operations. The last data transfer that
+    // completes the packet processing can differ to this transfer size.
+    // A value of 0x20 .. 0x80 generally gives a good performance but
+    // the optimal value depends on the system and application.
+    unsigned int nPEOutputThreshold;
+
+    // This parameter allows configuring the number of descriptors that must
+    // be completed before issuing a EIP93_INT_PE_CDRTHRESH_REQ interrupt.
+    unsigned int nDescriptorDoneCount;
+
+    // This parameter allows configuring the minimum number of descriptors
+    // that must be present in the command ring. reaching or falling below
+    // will  issuing a EIP93_INT_PE_RDRTHRESH_REQ interrupt.
+    unsigned int nDescriptorPendingCount;
+
+    // This parameter allows configuring maximum number of clock cycles allowed
+    // for a result descriptor to reside in the result ring. Extending this time
+    // will result in issuing a EIP93_INT_PE_RDRTHRESH_REQ interrupt.
+    // The rdr_thresh_irq interrupt activates when the RD
+    // counter for the RDR is non-zero for more than 2(N+8) internal system
+    // clock cycles, where 'N' is the value set in this field. Valid settings
+    // range from 0 to 15.
+    // The minimum time-out value for N=0 is 128 clock cycles and the
+    // maximum timeout value for N=15 is 8388608 clock cycles.
+    // At 100 MHz this is 1.28 us for N=0 and 83.89 ms for N=15.
+
+    unsigned int nDescriptorDoneTimeout;
+
+    // This parameter sets the spacing of a descriptor in 32bit words. The
+    // actual size of the descriptor also depends on Padding Words.
+    // This can be used to align each descriptor to a full cache
+    // line. Valid range is 8-15.
+    unsigned int nDescriptorSize;
+
+} EIP93_ARM_Settings_t;
+
+
+/*----------------------------------------------------------------------------
+ * ARM descriptor rings settings
+ * used in _ARM_Activate function as an input
+ */
+typedef struct
+{
+    // This parameter indicates whether the command and result rings share one
+    // ring (one block of memory) or use separate rings (two memory blocks).
+    bool fSeparateRings;
+
+    // Command Ring DMA resource handle
+    HWPAL_DMAResource_Handle_t CommandRingHandle;
+    // Command Ring physical address, understandable by Device
+    EIP93_DeviceAddress_t CommandRingAddr;
+
+    // Result Ring DMA resource handle
+    HWPAL_DMAResource_Handle_t ResultRingHandle;
+    // Result Ring physical address, understandable by Device
+    EIP93_DeviceAddress_t ResultRingAddr;
+
+    // Ring Size, in words
+    // This value is provided for both: Command and Result rings.
+    unsigned int RingSizeInWords;
+
+} EIP93_ARM_RingMemory_t;
+
+
+/*----------------------------------------------------------------------------
+ * Logical Command Descriptor for PacketPut
+ * and a helper function
+ */
+typedef struct
+{
+    // control fields for the command descriptor
+    // EIP93_CommandDescriptor_Control_MakeWord helper function
+    // can be used for obtaining this word
+    uint32_t ControlWord;
+
+    // source packet data, has to be provided by the caller:
+    // physical address, understandable by Device
+    EIP93_DeviceAddress_t SrcPacketAddr;
+    // source packet data length, in bytes
+    unsigned int SrcPacketByteCount;
+    // length of source packet data in words that must bypass
+    // the Packet Engine and are directly copied from
+    // the source packet buffer to the destination packet buffer
+    uint32_t BypassWordLength;
+
+    // where to place the result data, has to be allocated by the caller:
+    // physical address, understandable by Device
+    EIP93_DeviceAddress_t DstPacketAddr;
+
+    // SA data, has to be allocated and filled in by the caller:
+    // physical address, understandable by Device
+    EIP93_DeviceAddress_t SADataAddr;
+
+    //SA State,has to be allocated and filled in by the caller:
+    // physical address, understandable by Device
+    EIP93_DeviceAddress_t SAStateDataAddr;
+
+    // copy through content from command to result descriptor
+    uint32_t UserId;
+
+#ifdef EIP93_ARM_NUM_OF_DESC_PADDING_WORDS
+    // 0 or more padding word values
+    // these values will be placed by _PacketPut
+    // to additional padding words in a command descriptor passed
+    // to the device.
+    uint32_t PaddingWords[EIP93_ARM_NUM_OF_DESC_PADDING_WORDS];
+#endif
+
+} EIP93_ARM_CommandDescriptor_t;
+
+
+static inline void
+EIP93_ARM_CommandDescriptor_InitMany(
+        EIP93_ARM_CommandDescriptor_t * CommandDescriptors_p,
+        const unsigned int CommandDescriptorsCount,
+        const EIP93_DeviceAddress_t SADataAddr,
+        const EIP93_DeviceAddress_t SAStateDataAddr,
+        const uint32_t ControlWord)
+{
+    unsigned int i;
+    if (!CommandDescriptors_p)
+        return;
+    for(i = 0; i <= CommandDescriptorsCount; i++)
+    {
+        CommandDescriptors_p[i].SADataAddr = SADataAddr;
+        CommandDescriptors_p[i].SAStateDataAddr = SAStateDataAddr;
+        CommandDescriptors_p[i].ControlWord = ControlWord;
+    }
+}
+
+/*----------------------------------------------------------------------------
+ * Logical Result Descriptor for PacketGet.
+ */
+typedef struct
+{
+    // status fields for the result descriptor
+    // EIP93_ResultDescriptor_Status_InterpretWord helper function
+    // can be used for obtaining this word
+    uint32_t StatusWord;
+
+    // result packet data length, in bytes
+    unsigned int DstPacketByteCount;
+
+    // length of packet data in words that must bypass the Packet Engine
+    // and are directly copied from the source packet buffer to the
+    // destination packet buffer
+    uint32_t BypassWordLength;
+
+    //copied through user ID
+    uint32_t UserId;
+
+#ifdef EIP93_ARM_NUM_OF_DESC_PADDING_WORDS
+    // whether a number of padding words values present are valid
+    bool fPaddingWordValuesAreValid;
+    // 0 or more padding word values
+    // these values could have been placed by _PacketPut to the command ring
+    // if fPaddingWordValuesAreValid is FALSE,
+    // then there are two reasons for that:
+    //  - either these words were not provided by _PacketPut
+    //  - or _PacketGet just could not retrieve them from the result ring
+    //    (this is not possible for separate command and result rings)
+    uint32_t PaddingWords[EIP93_ARM_NUM_OF_DESC_PADDING_WORDS];
+#endif
+
+} EIP93_ARM_ResultDescriptor_t;
+
+
+/*----------------------------------------------------------------------------
+ *                         ARM APIs
+ *----------------------------------------------------------------------------
+ */
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_Activate
+ * configures the EIP93 Packet Engine operational mode for Autonomous Ring.
+ *
+ * This function is only allowed to be called from the 'initialized' state,
+ * to which the device can be put by _Initialize or _Deactivate functions.
+ * This function puts the device to the 'ARM activated' state.
+ *
+ * (input)Settings_p - different settings for ARM mode that influence
+ *                  various behaviour aspects of the EIP93 packet engine,
+                    such as PDR polling, interrupts, SA format.
+ *
+ * (input)Ring_p - command and result descriptor rings memory settings:
+ *                 DMA resources and physical base addresses.
+ *
+ * Returns EIP93_STATUS_OK if the EIP93 packet engine was successfully
+ * activated in the ARM mode, in this case the EIP93 packet engine
+ * starts polling for new command descriptors in PDR
+ * (if Settings_p->nRingPollDivisor is not 0).
+ */
+EIP93_Status_t
+EIP93_ARM_Activate(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_ARM_Settings_t * const Settings_p,
+        const EIP93_ARM_RingMemory_t * const Ring_p);
+
+
+
+//NOTE:
+//     The rest of the API functions in this header file can be called
+//     only in the 'ARM activated' state, that is AFTER the EIP93_ARM_Activate
+//     function was sucessfully called.
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_FinalizeSA
+ *
+ * This function has to be called once for each SA data buffer BEFORE
+ * it can be referenced in EIP93_ARM_CommandDescriptor_t instances, which
+ * are passsed to EIP93_ARM_PE_PacketPut().
+ * After this call the SA data buffer cannot be modified by Host,
+ * but EIP93_ARM_PE_PacketPut() invocations using this SA can be done.
+ *
+ * (input)SADataHandle - DMA resource handle for the SA data buffer
+ *
+ */
+EIP93_Status_t
+EIP93_ARM_FinalizeSA(
+        EIP93_IOArea_t * const IOArea_p,
+        const HWPAL_DMAResource_Handle_t SADataHandle);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_PacketPut
+ *
+ * Inserts packet descriptors in the command descriptor ring.
+ * May be called immediately after the EIP93_INT_PE_CDRTHRESH_REQ interrupt.
+ *
+ * EIP93_INT_PE_RDRTHRESH_REQ  interrupt can be triggered as a result
+ * of this function's call.
+ * In this case the EIP93_ARM_PacketGet function can be used
+ * to fetch the results from the result descriptor ring.
+ *
+ * (input)CmdDescriptors_p - Pointer to 1st in the the array of descriptors.
+ *
+ * (input)CmdDescriptorCount - Number of descriptors stored
+ * back-to-back in the array pointed to by CmdDescriptors_p.
+ *
+ * (output)DoneCount - Number of descriptors actually inserted
+ *                     to the command descriptor ring.
+ *
+ * Returns EIP93_BUSY_RETRY_LATER  when  PE is busy to carry out the request,
+ * in such situation call again after the above said criteria is meet.
+ */
+EIP93_Status_t
+EIP93_ARM_PacketPut(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_ARM_CommandDescriptor_t *  CmdDescriptors_p,
+        const unsigned int CmdDescriptorCount,
+        unsigned int * const DoneCount_p);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_PacketGet
+ *
+ * May be called after the EIP93_INT_PE_RDRTHRESH_REQ interrupt.
+ *
+ * (input)ResDescriptors_p - Pointer to 1st in the the array of descriptors.
+ *
+ * (input)ResDescriptorLimit - Maximum number of descriptors that are expected
+ * to be got from the result ring and for which it is enough space in
+ * ResDescriptors_p.
+ *
+ * (output)DoneCount - Number of descriptors actually emptied from the
+ * result ring and stored back-to-back in the
+ * array pointed to by ResDescriptors_p.
+ *
+ * Returns EIP93_BUSY_RETRY_LATER  if  PE busy to carry out the
+ * request, in such situation call again later.
+ */
+EIP93_Status_t
+EIP93_ARM_PacketGet(
+        EIP93_IOArea_t * const IOArea_p,
+        EIP93_ARM_ResultDescriptor_t *  ResDescriptors_p,
+        const unsigned int ResDescriptorLimit,
+        unsigned int * const DoneCount_p);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_PacketExternalGet
+ *
+ * Should be called as a result of a corresponding EIP93_ARM_PacketGet()
+ * call on an external Host. This function has to be called instead of
+ * EIP93_ARM_PacketGet() in case another, external Host is used for external
+ * completion.
+ *
+ * (input)ExternalDoneCount:Number of descriptors actually emptied from the
+ * result ring by the external host.
+ */
+EIP93_Status_t
+EIP93_ARM_PacketExternalGet(
+        EIP93_IOArea_t * const IOArea_p,
+        const unsigned int ExternalDoneCount);
+
+#endif
+
+
diff --git a/drivers/net/cryptoDriver/include/mtk_armL0.h b/drivers/net/cryptoDriver/include/mtk_armL0.h
new file mode 100755
index 0000000..8021d7d
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_armL0.h
@@ -0,0 +1,587 @@
+
+#ifndef EIP93_ARM_LEVEL0_H
+#define EIP93_ARM_LEVEL0_H
+
+#include "mtk_baseDefs.h"             // BIT definitions, bool, uint32_t
+#include "mtk_hwAccess.h"              // Read32, Write32, HWPAL_Device_t
+#include "mtk_hwDmaAccess.h"          // Read32, Write32, HWPAL_DMAResource_t
+#include "mtk_L0.h"         // the generic level0 functions
+#include "mtk_hwInterface.h"   // the HW interface (register map)
+//TreyZ
+extern void (*_dma_cache_wback_inv)(unsigned long start, unsigned long size);
+#define dma_cache_wback_inv(start, size)	_dma_cache_wback_inv(start,size)
+#define VPint *(volatile unsigned int *)
+/*-----------------------------------------------------------------------------
+ * EIP93 register routines
+ *
+ * These routines write/read register values in EIP93 registers
+ * in HW specific format.
+ *
+ * Note: if a function argument implies a flag ('f' is a prefix),
+ *       then only the values 0 or 1 are allowed for this argument.
+ */
+
+static inline void
+EIP93_Write32_PE_CDR_BASE(
+        HWPAL_Device_t Device,
+        const uint32_t CDRBaseAddress)
+{
+    EIP93_Write32(Device, EIP93_REG_PE_CDR_BASE, CDRBaseAddress);
+}
+
+static inline void
+EIP93_Read32_PE_CDR_BASE(
+        HWPAL_Device_t Device,
+        uint32_t * const CDRBaseAddress)
+{
+    if(CDRBaseAddress)
+        *CDRBaseAddress = EIP93_Read32(Device, EIP93_REG_PE_CDR_BASE);
+}
+
+static inline void
+EIP93_Write32_PE_RDR_BASE(
+        HWPAL_Device_t Device,
+        const uint32_t RDRBaseAddress)
+{
+    EIP93_Write32(Device, EIP93_REG_PE_RDR_BASE, RDRBaseAddress);
+}
+
+static inline void
+EIP93_Read32_PE_RDR_BASE(
+        HWPAL_Device_t Device,
+        uint32_t * const RDRBaseAddress)
+{
+    if(RDRBaseAddress)
+        *RDRBaseAddress = EIP93_Read32(Device, EIP93_REG_PE_RDR_BASE);
+}
+
+static inline void
+EIP93_Write32_PE_RING_SIZE(
+        HWPAL_Device_t Device,
+        const uint16_t RingOffset,
+        const uint16_t RingSize)
+{
+    EIP93_Write32(
+            Device,
+            EIP93_REG_PE_RING_CONFIG,
+            ((RingOffset & (BIT_8-1)) << 16) | ( RingSize & (BIT_10-1)) );
+}
+
+static inline void
+EIP93_Read32_PE_RING_SIZE(
+        HWPAL_Device_t Device,
+        uint16_t * const RingOffset,
+        uint16_t * const RingSize)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_RING_CONFIG);
+    if(RingOffset)
+        *RingOffset = (word >> 16) & (BIT_8-1);
+    if(RingSize)
+        *RingSize =  word & (BIT_10-1);
+}
+
+
+
+static inline void
+EIP93_Read32_PE_DMA_STAT(
+        HWPAL_Device_t Device,
+        uint8_t * const fPeInputDone,
+        uint8_t * const fPeOutputDone,
+        uint8_t * const fEncryptionDone,
+        uint8_t * const fInnerHashDone,
+        uint8_t * const fOuterHashDone,
+        uint8_t * const fCryptoPadFault,
+        uint8_t * const fSPIMismatch,
+        uint8_t * const fEXTError,
+    uint8_t * const fPeOperationDone,
+        uint8_t * const fInputRequestActive,
+        uint8_t * const fOutputRequestActive,
+        uint16_t * const PeInputSize,
+        uint16_t * const PeOutputSize)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_STATUS);
+    if(fPeInputDone)
+        *fPeInputDone = word & 1;
+    if(fPeOutputDone)
+        *fPeOutputDone = (word >> 1) & 1;
+    if(fEncryptionDone)
+        *fEncryptionDone = (word >> 2) & 1;
+    if(fInnerHashDone)
+        *fInnerHashDone = (word >> 3) & 1;
+    if(fOuterHashDone)
+        *fOuterHashDone = (word >> 4) & 1;
+    if(fCryptoPadFault)
+        *fCryptoPadFault = (word >> 5) & 1;
+    if(fSPIMismatch)
+        *fSPIMismatch = (word >> 7) & 1;
+    if(fEXTError)
+        *fEXTError = (word >> 8) & 1;
+    if(fPeOperationDone)
+        *fPeOperationDone = (word >> 9) & 1;
+    if(fInputRequestActive)
+        *fInputRequestActive = (word >> 10) & 1;
+    if(fOutputRequestActive)
+        *fOutputRequestActive = (word >> 11) & 1;
+    if(PeInputSize)
+        *PeInputSize = (word >> 12) & (BIT_10-1);
+    if(PeOutputSize)
+        *PeOutputSize = (word >> 22) & (BIT_10-1);
+}
+
+
+
+static inline void
+EIP93_Read32_PE_RING_PNTR(
+        HWPAL_Device_t Device,
+        uint16_t * const NextCDROffset,
+    uint16_t * const NextRDROffset)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_RING_RW_PNTR);
+    if(NextCDROffset)
+        *NextCDROffset = word  & (BIT_10-1);
+    if(NextRDROffset)
+        *NextRDROffset = (word >> 16) & (BIT_10-1);
+}
+
+
+static inline void
+EIP93_Read32_INT_UNMASK_STAT(
+        HWPAL_Device_t Device,
+        uint8_t * const fPeDescDoneIRQ,
+        uint8_t * const fPeDescInputIRQ,
+        uint8_t * const fPeOpDoneIRQ,
+        uint8_t * const fPeInputBufferIRQ,
+        uint8_t * const fPeOutputBufferIRQ,
+        uint8_t * const fPeErrIRQ
+       // uint8_t * const fPrngDoneIRQ
+        )
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_INT_UNMASK_STAT);
+    if(fPeDescDoneIRQ)
+        *fPeDescDoneIRQ = word & 1;
+    if(fPeDescInputIRQ)
+        *fPeDescInputIRQ = (word >> 1) & 1;
+    if(fPeOpDoneIRQ)
+        *fPeOpDoneIRQ = (word >> 9) & 1;
+    if(fPeInputBufferIRQ)
+        *fPeInputBufferIRQ = (word >> 10) & 1;
+    if(fPeOutputBufferIRQ)
+        *fPeOutputBufferIRQ = (word >> 11) & 1;
+    if(fPeErrIRQ)
+        *fPeErrIRQ = (word >> 13) & 1;
+
+}
+
+static inline void
+EIP93_Read32_INT_MASK_STAT(
+        HWPAL_Device_t Device,
+        uint8_t * const fPeDescDoneIRQ,
+        uint8_t * const fPeDescInputIRQ,
+        uint8_t * const fPeOpDoneIRQ,
+        uint8_t * const fPeInputBufferIRQ,
+        uint8_t * const fPeOutputBufferIRQ,
+        uint8_t * const fPeErrIRQ,
+        uint8_t * const fPrngDoneIRQ)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_INT_MASK_STAT);
+    if(fPeDescDoneIRQ)
+        *fPeDescDoneIRQ = word & 1;
+    if(fPeDescInputIRQ)
+        *fPeDescInputIRQ = (word >> 1) & 1;
+    if(fPeOpDoneIRQ)
+        *fPeOpDoneIRQ = (word >> 9) & 1;
+    if(fPeInputBufferIRQ)
+        *fPeInputBufferIRQ = (word >> 10) & 1;
+    if(fPeOutputBufferIRQ)
+        *fPeOutputBufferIRQ = (word >> 11) & 1;
+    if(fPeErrIRQ)
+        *fPeErrIRQ = (word >> 13) & 1;
+    if(fPrngDoneIRQ)
+        *fPrngDoneIRQ = (word >> 12) & 1;
+}
+
+
+static inline void
+EIP93_Write32_INT_CLR(
+        HWPAL_Device_t Device,
+        const uint8_t fPeDescDoneIRQ,
+        const uint8_t fPeDescInputIRQ,
+        const uint8_t fPeOpDoneIRQ,
+        const uint8_t fPeInputBufferIRQ,
+        const uint8_t fPeOutputBufferIRQ,
+        const uint8_t fPeErrIRQ,
+        const uint8_t fPrngDoneIRQ)
+{
+    EIP93_Write32(Device, EIP93_REG_INT_CLR,
+                  (fPeDescDoneIRQ & 1) |
+                  ((fPeDescInputIRQ & 1) << 1) |
+                  ((fPeOpDoneIRQ & 1) << 9) |
+                  ((fPeInputBufferIRQ & 1) << 10) |
+                  ((fPeOutputBufferIRQ & 1) << 11) |
+                  ((fPeErrIRQ & 1) << 13) |
+                  ((fPrngDoneIRQ & 1) << 12));
+}
+
+static inline void
+EIP93_Read32_PE_CD_COUNT(
+        HWPAL_Device_t Device,
+        uint32_t * const CmdDescrCount)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_CD_COUNT);
+    if(CmdDescrCount)
+        *CmdDescrCount = word & (BIT_10-1);
+}
+
+static inline void
+EIP93_Write32_PE_CD_COUNT(
+        HWPAL_Device_t Device,
+        const uint32_t CmdDescrCount)
+{
+    EIP93_Write32(Device, EIP93_REG_PE_CD_COUNT,
+          CmdDescrCount & (BIT_8-1));
+}
+
+static inline void
+EIP93_Read32_PE_RD_COUNT(
+        HWPAL_Device_t Device,
+        uint32_t * const ResDescrCount)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_RD_COUNT);
+    if(ResDescrCount)
+        *ResDescrCount = word & (BIT_10-1);
+}
+
+static inline void
+EIP93_Write32_PE_RD_COUNT(
+        HWPAL_Device_t Device,
+        const uint32_t ResDescrCount)
+{
+    EIP93_Write32(Device, EIP93_REG_PE_RD_COUNT,
+          ResDescrCount & (BIT_8-1));
+}
+
+static inline void
+EIP93_Write32_PE_RING_THRESH(
+        HWPAL_Device_t Device,
+        const uint16_t CmdDescrThreshCnt,
+        const uint16_t ResDescrThreshCnt,
+    const uint16_t ResRingTimeOut)
+{
+    EIP93_Write32(
+            Device,
+            EIP93_REG_PE_RING_THRESH,
+            (CmdDescrThreshCnt & (BIT_10-1)) |
+        ((ResDescrThreshCnt & (BIT_10-1)) << 16) |
+        ((ResRingTimeOut  & (BIT_6-1)) << 26));
+}
+
+static inline void
+EIP93_Read32_PE_RING_THRESH(
+        HWPAL_Device_t Device,
+        uint16_t * const CmdDescrThreshCnt,
+        uint16_t * const ResDescrThreshCnt,
+    uint16_t * const ResRingTimeOut)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PE_RING_THRESH);
+    if(CmdDescrThreshCnt)
+        *CmdDescrThreshCnt = word  & (BIT_10-1);
+    if(ResDescrThreshCnt)
+        *ResDescrThreshCnt =  (word >> 16) & (BIT_10-1);
+    if(ResRingTimeOut)
+        *ResDescrThreshCnt =  (word >> 26) & (BIT_6-1);
+}
+
+/*-----------------------------------------------------------------------------
+ * ARM routines
+ *
+ * These routines write/read descriptors in a descriptor ring for ARM
+ */
+// #define RT_EIP93_DRIVER_DEBUG_H //trey here is in .h file
+static inline void
+EIP93_ARM_Level0_WriteDescriptor(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const EIP93_ARM_CommandDescriptor_t * const Descr_p)
+
+{
+    uint32_t word;
+#ifdef RT_EIP93_DRIVER_DEBUG_H
+    uint32_t *p, k, bytes;
+#endif
+    // Ctrl/stat word
+    // mask out reserved and status fields.
+    word = Descr_p->ControlWord & 0xFF00FFF8; //& 0xFF00FF10;
+    word |= 1; // Host Ready is set
+    HWPAL_DMAResource_Write32(Handle, WordOffset, word);
+
+    // Source address
+    HWPAL_DMAResource_Write32(
+            Handle,
+            WordOffset+1,
+            Descr_p->SrcPacketAddr.Addr);
+
+
+
+    // Destination address
+    HWPAL_DMAResource_Write32(
+            Handle,
+            WordOffset+2,
+            Descr_p->DstPacketAddr.Addr);
+
+
+    // SA data address
+    HWPAL_DMAResource_Write32(
+            Handle,
+            WordOffset+3,
+            Descr_p->SADataAddr.Addr);
+
+
+   // SA State data address
+    HWPAL_DMAResource_Write32(
+            Handle,
+            WordOffset+4,
+            Descr_p->SAStateDataAddr.Addr);
+
+
+   HWPAL_DMAResource_Write32(
+            Handle,
+            WordOffset+5,
+            Descr_p->SAStateDataAddr.Addr);
+
+
+    // User ID address
+    HWPAL_DMAResource_Write32(
+            Handle,
+            WordOffset+6,
+            Descr_p->UserId);
+
+
+    // Length word
+    word = 0;
+    word |= Descr_p->BypassWordLength << 24;
+    word |= 1 << 22; // Host Ready is set
+    word |= ((BIT_20 - 1) & Descr_p->SrcPacketByteCount);//can not exceed 1MB
+
+    HWPAL_DMAResource_Write32(Handle, WordOffset + 7, word);
+
+	//TreyZ
+	if(((BIT_20 - 1) & Descr_p->SrcPacketByteCount) > 0)
+		dma_cache_wback_inv((unsigned long)(Descr_p->SrcPacketAddr.Addr | 0x80000000), ((BIT_20 - 1) & Descr_p->SrcPacketByteCount));
+
+	//Trey
+	#if 0
+	{
+		uint32_t *Src_p;
+		int bytes = ((BIT_20 - 1) & Descr_p->SrcPacketByteCount);
+		int k;
+
+		Src_p = (uint32_t*)(HWPAL_DMAResource_Read32(Handle, WordOffset+1) | 0xa0000000);
+    	printk("\n%d-byte SRC Content from 0x%p:\n", bytes, Src_p);
+    	for(k=0; k<bytes/4; k++){
+        	printk("0x%08x\t", *(Src_p+k));
+        	if(k%5==4) printk("\n");
+    	}
+    	printk("\n");
+	}
+	#endif
+
+
+#ifdef RT_EIP93_DRIVER_DEBUG_H
+    printk("\n[EIP93_ARM_Level0_WriteDescriptor]\n");
+    printk("ControlWord:0x%08x\n", HWPAL_DMAResource_Read32(Handle, WordOffset));
+
+	bytes = HWPAL_DMAResource_Read32(Handle, WordOffset+7) & (BIT_20 - 1);
+	p = (uint32_t*)(HWPAL_DMAResource_Read32(Handle, WordOffset+1) | 0xa0000000);
+    printk("%d-byte Src packet from 0x%p:\n", bytes, HWPAL_DMAResource_Read32(Handle, WordOffset+1));
+    for(k=0; k<bytes/4; k++){
+        printk("0x%08x\t", *(p+k));
+        if(k%5==4) printk("\n");
+    }
+    printk("\n");
+
+    printk("Dst packet Addr:0x%08x\n", HWPAL_DMAResource_Read32(Handle, WordOffset+2));
+
+    p = (uint32_t*)(HWPAL_DMAResource_Read32(Handle, WordOffset+3) | 0xa0000000);
+    printk("\n128-byte SA Content from 0x%p:\n", p);
+    for(k=0; k<32; k++){
+        printk("0x%08x\t", *(p+k));
+        if(k%5==4) printk("\n");
+    }
+    printk("\n");
+
+    p = (uint32_t*)(HWPAL_DMAResource_Read32(Handle, WordOffset+4) | 0xa0000000);
+    printk("56-byte SAState Content from 0x%p:\n", p);
+    for(k=0; k<14; k++){
+        printk("0x%08x\t", *(p+k));
+        if(k%5==4) printk("\n");
+    }
+    printk("\n");
+
+    p = (uint32_t*)(HWPAL_DMAResource_Read32(Handle, WordOffset+5) | 0xa0000000);
+    printk("SAARC4 Content from 0x%p:\n", p);
+	printk("\n");
+
+	printk("\nPE_userID:0x%08x\n", HWPAL_DMAResource_Read32(Handle, WordOffset+6));
+
+    printk("\nPE_length:0x%08x\n", HWPAL_DMAResource_Read32(Handle, WordOffset+7));
+#endif
+//#undef RT_EIP93_DRIVER_DEBUG_H //trey
+
+    // padding words
+#ifdef EIP93_ARM_NUM_OF_DESC_PADDING_WORDS
+	{
+        unsigned i;
+        for(i = 0; i < EIP93_ARM_NUM_OF_DESC_PADDING_WORDS; i++)
+        {
+            HWPAL_DMAResource_Write32(
+                    Handle,
+                    WordOffset + i + 8 ,
+                    Descr_p->PaddingWords[i]);
+
+
+        }
+    }
+#endif
+
+#if 0
+//Treyb4
+if(((BIT_20 - 1) & Descr_p->SrcPacketByteCount)==1266){
+	VPint(0x8001ffb4) = VPint(0xbfbf0118);
+}
+#endif
+
+}
+
+
+static inline bool
+EIP93_ARM_Level0_WriteDescriptor_IfFree(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const EIP93_ARM_CommandDescriptor_t * const Descr_p)
+
+{
+    uint32_t word0 = 0;
+    uint32_t lastword = 0;
+    uint32_t pe_done1 = 0;
+    uint32_t pe_done2 = 0;
+
+    word0 = HWPAL_DMAResource_Read32(Handle, WordOffset);
+    lastword = HWPAL_DMAResource_Read32(
+                    Handle,
+                    WordOffset+7);
+
+    pe_done1 = word0 & (BIT_2-1);
+    pe_done2 = (lastword >> 22) & (BIT_2-1);
+    if (pe_done1 == pe_done2 && pe_done1 == 0)
+    {
+        EIP93_ARM_Level0_WriteDescriptor(
+                                         Handle,
+                                         WordOffset,
+                                         Descr_p);
+
+        return true;
+    }
+    return false;
+}
+
+
+static inline void
+EIP93_ARM_Level0_ClearDescriptor(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset)
+{
+    unsigned i = 0;
+
+    for (i=0; i<EIP93_ARM_DESCRIPTOR_SIZE(); i++)
+    {
+        HWPAL_DMAResource_Write32(Handle, WordOffset + i, 0);
+    }
+}
+
+
+static inline void
+EIP93_ARM_Level0_ClearAllDescriptors(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int DescriptorSpacing,
+        const unsigned int NumberOfDescriptors)
+{
+    const uint32_t Words[8] = { 0 };
+    const int nDescrSize = EIP93_ARM_DESCRIPTOR_SIZE();
+    unsigned int i;
+
+    for(i = 0; i < NumberOfDescriptors; i++)
+    {
+        HWPAL_DMAResource_Write32Array(
+                Handle,
+                i * DescriptorSpacing,
+                nDescrSize,
+                Words);
+    }
+}
+
+
+static inline bool
+EIP93_ARM_Level0_ReadDescriptor_IfReady(
+        EIP93_ARM_ResultDescriptor_t * const Descr_p,
+        const HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset)
+{
+    uint32_t word0 = 0;
+    uint32_t lastword = 0;
+    uint32_t pe_done1 = 0;
+    uint32_t pe_done2 = 0;
+
+    word0 = HWPAL_DMAResource_Read32(Handle, WordOffset);
+    lastword = HWPAL_DMAResource_Read32(Handle, WordOffset+7);
+
+    pe_done1 = word0 & (BIT_2-1);
+    pe_done2 = (lastword >> 22) & (BIT_2-1);
+    if (pe_done1 == pe_done2 && pe_done1 == 2)
+    {
+        // Stat word
+        Descr_p->StatusWord = word0;
+
+        // Destination data length and bypass length
+        Descr_p->BypassWordLength = (lastword >> 24) & (BIT_8-1);
+        Descr_p->DstPacketByteCount = lastword & (BIT_20-1);
+
+	//Trey
+	#if 0
+	{
+		uint32_t *Dst_p;
+		int k;
+
+		Dst_p = (uint32_t*)(HWPAL_DMAResource_Read32(Handle, WordOffset+2) | 0xa0000000);
+    	printk("\n%d-byte DST Content from 0x%p:\n", Descr_p->DstPacketByteCount, Dst_p);
+    	for(k=0; k<Descr_p->DstPacketByteCount/4; k++){
+        	printk("0x%08x\t", *(Dst_p+k));
+        	if(k%5==4) printk("\n");
+    	}
+    	printk("\n");
+	}
+	#endif
+
+        // padding words
+#ifdef EIP93_ARM_NUM_OF_DESC_PADDING_WORDS
+        {
+            unsigned i;
+            for (i = 0; i < EIP93_ARM_NUM_OF_DESC_PADDING_WORDS; i++)
+            {
+                Descr_p->PaddingWords[i] =
+                    HWPAL_DMAResource_Read32(
+                        Handle,
+                        WordOffset + i + 8);
+            }
+        }
+#endif
+
+        return true;
+    }
+    return false;
+}
+
+
+
+#endif
+
+
diff --git a/drivers/net/cryptoDriver/include/mtk_baseDefs.h b/drivers/net/cryptoDriver/include/mtk_baseDefs.h
new file mode 100755
index 0000000..6136162
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_baseDefs.h
@@ -0,0 +1,190 @@
+
+#ifndef EIP93_BASE_DEFS_H
+#define EIP93_BASE_DEFS_H
+#include	<linux/kernel.h>
+
+/* ============ Compiler-based Configuration ============ */
+
+#ifdef __cplusplus
+#error "BasicDefs: C++ mode not yet supported"
+#endif
+
+#ifdef _MSC_VER
+#define BASICDEFS_COMPILER_MICROSOFT_V1
+#define BASICDEFS_TYPES_V1
+#define BASICDEFS_BOOL_V1
+// Microsoft compiler only supports "inline" in C++ mode and
+// expects __inline in C mode
+#define BASICDEFS_INLINE_V1
+#endif
+
+#ifdef linux
+#ifdef MODULE
+// kernel loadable module
+#define BASICDEFS_COMPILER_LINUX_V1
+#define BASICDEFS_INLINE_BUILTIN
+#include <linux/types.h>
+#else
+// user mode
+#define BASICDEFS_COMPILER_LINUX_V1
+#define BASICDEFS_TYPES_STDINT
+#define BASICDEFS_BOOL_V1
+#define BASICDEFS_INLINE_BUILTIN
+#endif
+#endif
+
+#ifdef __CYGWIN__
+#define BASICDEFS_COMPILER_CYGWIN_V1
+#define BASICDEFS_TYPES_STDINT
+#define BASICDEFS_BOOL_V1
+#define BASICDEFS_INLINE_BUILTIN
+#endif
+
+
+
+/* ============ Basic Types ============ */
+
+#ifdef BASICDEFS_TYPES_STDINT
+// ISO-C99
+#include <stdint.h>
+#endif
+
+#ifdef BASICDEFS_TYPES_V1
+typedef unsigned char  uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int   uint32_t;
+#endif
+
+
+
+/* ============ Boolean type ============ */
+
+#ifdef BASICDEFS_BOOL_V1
+
+#ifndef false
+typedef unsigned char bool;
+#define false ((bool)0)
+#define true  (!false)
+#endif
+
+#endif
+
+
+
+/* ============ NULL ============ */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+
+/* ============ MIN, MAX ============ */
+
+// warning for side-effects on the following two macros since the arguments
+// are evaluated twice changing this to inline functions is problematic
+// because of type incompatibilities
+#define MIN(_x, _y) ((_x) < (_y) ? (_x) : (_y))
+#define MAX(_x, _y) ((_x) > (_y) ? (_x) : (_y))
+
+
+
+/* ============ BIT_n ============ */
+
+// using postfix "U" to be compatible with uint32
+// ("UL" is not needed and gives lint warning)
+#define BIT_0   0x00000001U
+#define BIT_1   0x00000002U
+#define BIT_2   0x00000004U
+#define BIT_3   0x00000008U
+#define BIT_4   0x00000010U
+#define BIT_5   0x00000020U
+#define BIT_6   0x00000040U
+#define BIT_7   0x00000080U
+#define BIT_8   0x00000100U
+#define BIT_9   0x00000200U
+#define BIT_10  0x00000400U
+#define BIT_11  0x00000800U
+#define BIT_12  0x00001000U
+#define BIT_13  0x00002000U
+#define BIT_14  0x00004000U
+#define BIT_15  0x00008000U
+#define BIT_16  0x00010000U
+#define BIT_17  0x00020000U
+#define BIT_18  0x00040000U
+#define BIT_19  0x00080000U
+#define BIT_20  0x00100000U
+#define BIT_21  0x00200000U
+#define BIT_22  0x00400000U
+#define BIT_23  0x00800000U
+#define BIT_24  0x01000000U
+#define BIT_25  0x02000000U
+#define BIT_26  0x04000000U
+#define BIT_27  0x08000000U
+#define BIT_28  0x10000000U
+#define BIT_29  0x20000000U
+#define BIT_30  0x40000000U
+#define BIT_31  0x80000000U
+
+
+/* ============ MASK_n_BITS ============ */
+
+#define MASK_1_BIT      (BIT_1 - 1)
+#define MASK_2_BITS     (BIT_2 - 1)
+#define MASK_3_BITS     (BIT_3 - 1)
+#define MASK_4_BITS     (BIT_4 - 1)
+#define MASK_5_BITS     (BIT_5 - 1)
+#define MASK_6_BITS     (BIT_6 - 1)
+#define MASK_7_BITS     (BIT_7 - 1)
+#define MASK_8_BITS     (BIT_8 - 1)
+#define MASK_9_BITS     (BIT_9 - 1)
+#define MASK_10_BITS    (BIT_10 - 1)
+#define MASK_11_BITS    (BIT_11 - 1)
+#define MASK_12_BITS    (BIT_12 - 1)
+#define MASK_13_BITS    (BIT_13 - 1)
+#define MASK_14_BITS    (BIT_14 - 1)
+#define MASK_15_BITS    (BIT_15 - 1)
+#define MASK_16_BITS    (BIT_16 - 1)
+#define MASK_17_BITS    (BIT_17 - 1)
+#define MASK_18_BITS    (BIT_18 - 1)
+#define MASK_19_BITS    (BIT_19 - 1)
+#define MASK_20_BITS    (BIT_20 - 1)
+#define MASK_21_BITS    (BIT_21 - 1)
+#define MASK_22_BITS    (BIT_22 - 1)
+#define MASK_23_BITS    (BIT_23 - 1)
+#define MASK_24_BITS    (BIT_24 - 1)
+#define MASK_25_BITS    (BIT_25 - 1)
+#define MASK_26_BITS    (BIT_26 - 1)
+#define MASK_27_BITS    (BIT_27 - 1)
+#define MASK_28_BITS    (BIT_28 - 1)
+#define MASK_29_BITS    (BIT_29 - 1)
+#define MASK_30_BITS    (BIT_30 - 1)
+#define MASK_31_BITS    (BIT_31 - 1)
+
+
+/* ============ IDENTIFIER_NOT_USED ============ */
+
+#define IDENTIFIER_NOT_USED(_v) if(_v){}
+
+
+
+/* ============ inline ============ */
+
+#ifdef BASICDEFS_INLINE_V1
+#define inline __inline
+#endif
+
+
+/* ============ Temporary Backwards Compatibility ============ */
+
+#ifdef BASICDEFS_BACKCOMPAT
+typedef uint8_t  uint8;
+typedef uint16_t uint16;
+typedef uint32_t uint32;
+#define boolean bool
+#ifndef FALSE
+#define FALSE false
+#define TRUE  true
+#endif
+#endif
+
+#endif
diff --git a/drivers/net/cryptoDriver/include/mtk_cAdapter.h b/drivers/net/cryptoDriver/include/mtk_cAdapter.h
new file mode 100755
index 0000000..2d8a9d8
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_cAdapter.h
@@ -0,0 +1,74 @@
+
+#ifndef EIP93_C_ADAPTER_H
+#define EIP93_C_ADAPTER_H
+
+#include "mtk_csAdapter.h"
+
+#ifndef ADAPTER_MAX_DMARESOURCE_HANDLES
+#define ADAPTER_MAX_DMARESOURCE_HANDLES  256
+#endif
+
+#ifndef ADAPTER_EIP93_RINGSIZE_BYTES
+#define ADAPTER_EIP93_RINGSIZE_BYTES 1024
+#endif
+
+#ifndef ADAPTER_PACKETSIDECHANNEL_MAX_RECORDS
+#ifdef ADAPTER_EIP93_SEPARATE_RINGS
+#define ADAPTER_PACKETSIDECHANNEL_MAX_RECORDS  (2 * \
+             (ADAPTER_EIP93_RINGSIZE_BYTES / (8*4)))
+#else
+#define ADAPTER_PACKETSIDECHANNEL_MAX_RECORDS  (\
+                    ADAPTER_EIP93_RINGSIZE_BYTES /(8*4))
+#endif
+#endif
+
+#ifndef ADAPTER_MAX_EIP93LOGICDESCR
+#define ADAPTER_MAX_EIP93LOGICDESCR 32
+#endif
+
+#ifndef ADAPTER_EIP93_DESCRIPTORDONETIMEOUT
+#define ADAPTER_EIP93_DESCRIPTORDONETIMEOUT  0
+#endif
+
+
+
+#ifndef ADAPTER_EIP93_DMATHRESHOLD_INPUT
+#define ADAPTER_EIP93_DMATHRESHOLD_INPUT  128
+#endif
+
+#ifndef ADAPTER_EIP93_DMATHRESHOLD_OUTPUT
+#define ADAPTER_EIP93_DMATHRESHOLD_OUTPUT  128
+#endif
+
+#ifndef ADAPTER_EIP93_DHM_THRESHOLD_INPUT
+#define ADAPTER_EIP93_DHM_THRESHOLD_INPUT  128
+#endif
+
+#ifndef ADAPTER_EIP93_DHM_THRESHOLD_OUTPUT
+#define ADAPTER_EIP93_DHM_THRESHOLD_OUTPUT 128
+#endif
+
+// ensure only one of the packet engine modes is activated
+#ifdef ADAPTER_EIP93_PE_MODE_DHM
+#ifdef ADAPTER_EIP93_PE_MODE_ARM
+#error "Multiple ADAPTER_EIP93_PE_MODE_ defined in mtk_csAdapter.h"
+#endif
+#endif
+
+
+
+#ifndef ADAPTER_DRIVER_NAME
+#define ADAPTER_DRIVER_NAME "safenet_eip93_vdriver"
+#endif
+
+#ifndef ADAPTER_INTERRUPTS_TRACEFILTER
+#define ADAPTER_INTERRUPTS_TRACEFILTER BIT_31
+#endif
+
+#ifndef ADAPTER_EIP75_ALARMINTERRUPTTHRESHOLD
+#define ADAPTER_EIP75_ALARMINTERRUPTTHRESHOLD 10
+#endif
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_cEip93.h b/drivers/net/cryptoDriver/include/mtk_cEip93.h
new file mode 100755
index 0000000..673580a
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_cEip93.h
@@ -0,0 +1,27 @@
+
+#ifndef EIP93_C_EIP93_H
+#define EIP93_C_EIP93_H
+
+#include "mtk_csEip93.h"
+
+/*---------------------------------------------------------------------------
+ * flag to control paramater check
+ */
+
+//#define EIP93_STRICT_ARGS 1  //uncomment when paramters check needed
+//  Enable these flags for swapping PD, SA, DATA or register read/writes
+//  by packet engine
+
+//#define  EIP93_ENABLE_SWAP_PD
+//#define  EIP93_ENABLE_SWAP_SA
+//#define  EIP93_ENABLE_SWAP_DATA
+//#define  EIP93_ENABLE_SWAP_REG_DATA
+
+// Size of buffer for Direct Host Mode
+
+#ifndef EIP93_RAM_BUFFERSIZE_BYTES
+#define EIP93_RAM_BUFFERSIZE_BYTES 256 //for EIP93-IESW
+// #define EIP93_RAM_BUFFERSIZE_BYTES 2048 - for EIP93-I
+#endif
+
+#endif
diff --git a/drivers/net/cryptoDriver/include/mtk_cHwPci.h b/drivers/net/cryptoDriver/include/mtk_cHwPci.h
new file mode 100755
index 0000000..2b3d573
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_cHwPci.h
@@ -0,0 +1,17 @@
+
+
+#ifndef EIP93_C_HW_PCI_H
+#define EIP93_C_HW_PCI_H
+
+#include "mtk_csHwPci.h"
+
+#ifndef HWPAL_REMAP_ADDRESSES
+#define HWPAL_REMAP_ADDRESSES
+#endif
+
+#ifndef HWPAL_PCI_CONFIG_FLAGS
+#define HWPAL_PCI_CONFIG_FLAGS 0
+#endif
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_cLib.h b/drivers/net/cryptoDriver/include/mtk_cLib.h
new file mode 100755
index 0000000..069bef7
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_cLib.h
@@ -0,0 +1,31 @@
+
+#ifndef EIP93_CLIB_H
+#define EIP93_CLIB_H
+
+/* guaranteed APIs:
+
+    memcpy
+    memmove
+    memset
+    memcmp
+    offsetof
+
+*/
+
+
+/* Note: This is a template. Copy and customize according to your needs! */
+#if defined(linux) && defined(MODULE)
+
+#include <linux/string.h>     // memmove and memcpy
+#include <linux/stddef.h>     // offsetof
+
+#else
+
+#include <string.h>     // memmove
+#include <memory.h>     // memcpy, etc.
+#include <stddef.h>     // offsetof
+
+#endif
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_csAdapter.h b/drivers/net/cryptoDriver/include/mtk_csAdapter.h
new file mode 100755
index 0000000..1214c31
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_csAdapter.h
@@ -0,0 +1,88 @@
+
+#ifndef EIP93_CS_ADAPTER_H
+#define EIP93_CS_ADAPTER_H
+
+// we accept a few settings from the top-level configuration file
+#include "mtk_csDriver.h"
+
+#define ADAPTER_DRIVER_NAME "safenet-vdriver-eip93"
+
+
+// enable only one of the two PE modes
+#ifdef VDRIVER_PE_MODE_ARM
+#define ADAPTER_EIP93_PE_MODE_ARM
+#endif
+
+//#define ADAPTER_REMOVE_BOUNCEBUFFERS
+
+#ifdef VDRIVER_PE_MODE_DHM
+#define ADAPTER_EIP93_PE_MODE_DHM
+#endif
+
+// maximum number of commands accepted in one call to PEC_Packet_Put
+// maximum number of results by one call to PEC_Packet_Get
+// Number of Logical descripors in the ring
+#define ADAPTER_MAX_EIP93LOGICDESCR     32
+
+// size of the ring(s) in bytes (a descriptor is 32 bytes)
+//#define ADAPTER_EIP93_RINGSIZE_BYTES   /*20 * 10 */ /*32 * 10*/ 32 * 800 /*for integration*/
+#define ADAPTER_EIP93_RINGSIZE_BYTES 32 * 128 //trey
+
+#define ADAPTER_EIP93_DESCRIPTORDONECOUNT    0
+
+// This parameter allows configuring the number of descriptors that must
+// be completed (minus one) before issuing an interrupt to collect packets
+
+#define ADAPTER_EIP93_DESCRIPTORPENDINGCOUNT    0
+
+#ifdef VDRIVER_INTERRUPT_COALESC_COUNT
+#if VDRIVER_INTERRUPT_COALESC_COUNT > 0
+#undef ADAPTER_EIP93_DESCRIPTORPENDINGCOUNT
+#define ADAPTER_EIP93_DESCRIPTORPENDINGCOUNT  \
+    (VDRIVER_INTERRUPT_COALESC_COUNT-1)
+#endif
+#endif
+
+
+
+// wanted maximum time a packet is in the result ring: T milliseconds
+// calculate configuration value N as follows:
+//   N  = T(sec) * f(engine_Hz) / 1024
+//   N ~= T(ms)  * f(engine_Hz)          (2,3% error)
+// example: f(engine)=100MHz, T=2ms ==> N=2*100M
+#define ADAPTER_EIP93_DESCRIPTORDONETIMEOUT  15
+
+#define ADAPTER_EIP93_RINGPOLLDIVISOR 1
+
+// descriptor spacing in words, allowing cache line alignment
+// ring memory start alignment will use same value
+#define ADAPTER_SYSTEM_DCACHE_LINE_SIZE_BYTES  32
+
+
+
+#define ADAPTER_EIP93_DMATHRESHOLD_INPUT   0x20 //Gives optimal performance
+#define ADAPTER_EIP93_DMATHRESHOLD_OUTPUT  0x20 //Gives optimal performance
+
+
+#define ADAPTER_EIP93_DHM_THRESHOLD_INPUT  128
+#define ADAPTER_EIP93_DHM_THRESHOLD_OUTPUT 127
+
+// enable debug checks
+#ifndef VDRIVER_PERFORMANCE
+#define ADAPTER_PEC_DEBUG
+#define ADAPTER_PEC_STRICT_ARGS
+#endif
+
+
+// Global options
+#define ADAPTER_MAX_DMARESOURCE_HANDLES  256
+
+
+// filter for printing interrupts
+#define ADAPTER_INTERRUPTS_TRACEFILTER (0x0007FFFF - BIT_17 - BIT_13)
+
+#ifdef VDRIVER_INTERRUPTS
+#define ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+#endif
+
+#endif
diff --git a/drivers/net/cryptoDriver/include/mtk_csDriver.h b/drivers/net/cryptoDriver/include/mtk_csDriver.h
new file mode 100755
index 0000000..77fd19d
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_csDriver.h
@@ -0,0 +1,44 @@
+
+#ifndef EIP93_CS_DRIVER_H
+#define EIP93_CS_DRIVER_H
+
+// Define this when there is no actual device installed
+//#define ADAPTER_EIP93_NO_ACTUAL_DEVICE
+
+
+//Define if building for Simulator
+//#define ADAPTER_USER_DOMAIN_BUILD
+
+// enable for big-endian CPU
+//#define ADAPTER_EIP93_ARMRING_ENABLE_SWAP
+
+
+// activates DMA-enabled autonomous ring mode (ARM)
+// or CPU-managed direct host mode (DHM)
+// ARM can use overlapping command/result rings, or separate
+#define VDRIVER_PE_MODE_ARM
+//#define VDRIVER_PE_MODE_DHM
+
+// when defined, two memory block of the size ADAPTER_EIP93_RINGSIZE_BYTES will be allocated
+// one for commands, the other for results
+#define ADAPTER_EIP93_SEPARATE_RINGS //if no seperate rings, Crypto Engine will die when SmartBits uses more that 30M of flow speed --Trey
+
+
+// activates interrupts for EIP,
+// when disabled, polling will be used
+#define VDRIVER_INTERRUPTS
+
+
+// if not activated, this will switch on bounce-buffer support for all DMA services
+// if activated, then bounce buffers will not be created
+#define ADAPTER_REMOVE_BOUNCEBUFFERS  //if no BounceBuffer, dma_cache_wback_inv() is needed before kicking off crypto engine --Trey
+
+// when activated, disables all strict-args checking
+// and reduces logging to a Critical-only
+//#define VDRIVER_PERFORMANCE
+
+
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_csEip93.h b/drivers/net/cryptoDriver/include/mtk_csEip93.h
new file mode 100755
index 0000000..366503b
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_csEip93.h
@@ -0,0 +1,25 @@
+#ifndef EIP93_CS_EIP93_H
+#define EIP93_CS_EIP93_H
+
+/*---------------------------------------------------------------------------
+ * flag to control paramater check
+ */
+#ifndef VDRIVER_PERFORMANCE
+#define EIP93_STRICT_ARGS 1  //uncomment when paramters check needed
+#endif
+
+
+
+//  Enable these flags for swapping PD, SA, DATA or register read/writes
+//  by packet engine
+
+//#define  EIP93_ENABLE_SWAP_PD
+//#define  EIP93_ENABLE_SWAP_SA
+//#define  EIP93_ENABLE_SWAP_DATA
+//#define  EIP93_ENABLE_SWAP_REG_DATA
+
+// Size of buffer for Direct Host Mode
+#define EIP93_RAM_BUFFERSIZE_BYTES 256 //for EIP93-IESW
+// #define EIP93_RAM_BUFFERSIZE_BYTES 2048 - for EIP93-I
+
+#endif
diff --git a/drivers/net/cryptoDriver/include/mtk_csHwPci.h b/drivers/net/cryptoDriver/include/mtk_csHwPci.h
new file mode 100755
index 0000000..22741df
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_csHwPci.h
@@ -0,0 +1,62 @@
+
+#ifndef EIP93_CS_HW_PCI_H
+#define EIP93_CS_HW_PCI_H
+
+// we accept a few settings from the top-level configuration file
+#include "mtk_csDriver.h"
+
+
+//use rt_dump_register(0xfff) to dump all registers
+//use rt_dump_register(register_offset) to dump a specific register
+#define RT_DUMP_REGISTER
+
+
+// Define this to appropriate device ID
+#define HWPAL_PCI_DEVICE_ID 0x93
+
+// Name string for the driver, used while loading the module
+#define HWPAL_PCI_DRIVER_NAME "SafeXcel_EIP_93"
+
+// Set the correct address space size of the PCI device
+#define HWPAL_PCI_DEVICE_ADDRESS_SPACE_SIZE 0x7ffff
+
+// definition of static resources inside the PCI device
+// Refer to the data sheet of device for the correct values
+//                   Name        Start     Last     Flags (see below)
+#define HWPAL_DEVICES \
+    HWPAL_DEVICE_ADD("eip93",  0x00000,  0xFFC, 3)
+
+// Flags:
+//   bit0 = Trace reads  (requires HWPAL_TRACE_DEVICE_READ)
+//   bit1 = Trace writes (requires HWPAL_TRACE_DEVICE_WRITE)
+//   bit2 = Swap word endianess (requires HWPAL_DEVICE_ENABLE_SWAP)
+
+#ifndef VDRIVER_PERFORMANCE
+#define HWPAL_DEVICE_MAGIC   54333
+#endif
+
+#define HWPAL_REMAP_ADDRESSES \
+    HWPAL_REMAP_ONE(0x71004, 0x71204);
+
+// logging / tracing control
+#ifndef VDRIVER_PERFORMANCE
+//#define HWPAL_TRACE_DEVICE_FIND
+//#define HWPAL_TRACE_DEVICE_READ
+//#define HWPAL_TRACE_DEVICE_WRITE
+#define HWPAL_TRACE_DMARESOURCE_LEAKS
+//#define HWPAL_TRACE_DMARESOURCE_READ
+//#define HWPAL_TRACE_DMARESOURCE_WRITE
+//#define HWPAL_TRACE_DMARESOURCE_PREPOSTDMA
+#endif
+
+// enable code that looks at flag bit2 and performs actual endianess swap
+//#define HWPAL_DEVICE_ENABLE_SWAP
+
+
+/*Define this for verbose output of log information*/
+#define HWPAL_ENABLE_INFO_LOGS
+
+// Use sleepable or non-sleepable lock ?
+//#define HWPAL_LOCK_SLEEPABLE
+
+#endif
diff --git a/drivers/net/cryptoDriver/include/mtk_descp.h b/drivers/net/cryptoDriver/include/mtk_descp.h
new file mode 100755
index 0000000..4693052
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_descp.h
@@ -0,0 +1,92 @@
+
+#ifndef EIP93_DESCRIPTOR_H
+#define EIP93_DESCRIPTOR_H
+
+#include "mtk_baseDefs.h"
+#include "mtk_hwAccess.h"
+
+
+/*----------------------------------------------------------------------------
+ * Command descriptor control fields
+ */
+typedef struct
+{
+    //Packet tail allignment boundary,Bit map with only one bit or
+    //none set.
+    uint8_t PadControl;
+    //next header value
+    uint8_t NextHeaderValue;
+    //finalize hash operation
+    bool fHashFinal;
+
+} EIP93_CommandDescriptor_Control_t;
+
+
+/*----------------------------------------------------------------------------
+ * Result descriptor status fields
+ */
+typedef struct
+{
+    //count of pad bytes inserted/detected
+    uint8_t PadStatus;
+    //Pad value;
+    uint8_t PadValue;
+    // raw status field
+    uint8_t RawStatus;
+
+    // extended error or notification code
+    unsigned int ExtendedErrorCode;
+    // indicates the validity of above error or notification codes
+    bool fErrorORNotificationValid;
+    //sequence number fault or overflow
+    bool fSequenceNumberFail;
+    //pad miss match
+    bool fCryptoPadFail;
+    //ICV doesn't mactch
+    bool fAuthenticationFail;
+
+} EIP93_ResultDescriptor_Status_t;
+
+
+/*----------------------------------------------------------------------------
+ *                         Helper functions API
+ *----------------------------------------------------------------------------
+ */
+
+/*----------------------------------------------------------------------------
+ * EIP93_CommandDescriptor_Control_MakeWord
+ *
+ * This function returns Control Word for EIP93 Command descriptor.
+ *
+ * CommandCtrl_p (input)
+ *      control fields that have to be packed in the EIP93 specific format
+ *
+ * Returns:
+ *      a 32bit word containing all control fields in EIP93 specific format
+ */
+uint32_t
+EIP93_CommandDescriptor_Control_MakeWord(
+        const EIP93_CommandDescriptor_Control_t * const  CommandCtrl_p);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ResultDescriptor_Status_InterpretWord
+ *
+ * This function returns Status info interpretted from
+ * a status word of the EIP93 Result descriptor.
+ *
+ * StatusWord (input)
+ *      status fields packed in the EIP93 specific format
+ *
+ * ResultStatus_p (output):
+ *      a data structure instance containing all status fields
+ *      interpretted from the EIP93 specific format
+ */
+void
+EIP93_ResultDescriptor_Status_InterpretWord(
+        const uint32_t StatusWord,
+        EIP93_ResultDescriptor_Status_t * const  ResultStatus_p);
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_dmaBuf.h b/drivers/net/cryptoDriver/include/mtk_dmaBuf.h
new file mode 100755
index 0000000..64e1967
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_dmaBuf.h
@@ -0,0 +1,167 @@
+
+#ifndef EIP93_DMA_BUF_H
+#define EIP93_DMA_BUF_H
+
+#include "mtk_baseDefs.h"
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Handle_t
+ *
+ * This handle is a reference to a DMA buffer. It is returned when a buffer
+ * is allocated or registered and it remains valid until the buffer is freed
+ * or de-registered.
+ */
+typedef struct
+{
+    void * p;
+} DMABuf_Handle_t;
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_HostAddress_t
+ *
+ * Buffer address that can be used by the host to access the buffer. This
+ * address has been put in a data structure to make it type-safe.
+ */
+typedef struct
+{
+    void * p;
+} DMABuf_HostAddress_t;
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Status_t
+ *
+ * Return values for all the API functions.
+ */
+typedef enum
+{
+    DMABUF_STATUS_OK,
+    DMABUF_ERROR_BAD_ARGUMENT,
+    DMABUF_ERROR_INVALID_HANDLE,
+    DMABUF_ERROR_OUT_OF_MEMORY
+} DMABuf_Status_t;
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Properties_t
+ *
+ * Buffer properties. When allocating a buffer, these are the requested
+ * properties for the buffer. When registering an externally allocated buffer,
+ * these properties describe the buffer.
+ *
+ * For both uses, the data structure should be initialized to all zeros
+ * before filling in some or all of the fields. This ensures forward
+ * compatibility in case this structure is extended with more fields.
+ *
+ * Example usage:
+ *     DMABuf_Properties_t Props = {0};
+ *     Props.fIsCached = true;
+ */
+typedef struct
+{
+    uint32_t Size;       // size of the buffer
+    uint8_t Alignment;   // buffer start address alignment, for example
+                         // 4 for 32bit
+    uint8_t Bank;        // can be used to indicate on-chip memory
+    bool fCached;        // true = SW needs to do coherency management
+} DMABuf_Properties_t;
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Alloc
+ *
+ * Allocate a buffer of requested size that can be used for device DMA.
+ *
+ * RequestedProperties
+ *     Requested properties of the buffer that will be allocated, including
+ *     the size, start address alignment, etc. See above.
+ *
+ * Buffer_p (output)
+ *     Pointer to the memory location where the address of the buffer will be
+ *     written by this function when allocation is successful. This address
+ *     can then be used to access the driver on the host in the domain of the
+ *     driver.
+ *
+ * Handle_p (output)
+ *     Pointer to the memory location when the handle will be returned.
+ *
+ * Return Values
+ *     DMABUF_STATUS_OK: Success, Handle_p was written.
+ *     DMABUF_ERROR_BAD_ARGUMENT
+ *     DMABUF_ERROR_OUT_OF_MEMORY: Failed to allocate a buffer or handle.
+ */
+DMABuf_Status_t
+DMABuf_Alloc(
+        const DMABuf_Properties_t RequestedProperties,
+        DMABuf_HostAddress_t * const Buffer_p,
+        DMABuf_Handle_t * const Handle_p);
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Register
+ *
+ * This function must be used to register an "alien" buffer that was allocated
+ * somewhere else. The caller guarantees that this buffer can be used for DMA.
+ *
+ * ActualProperties (input)
+ *     Properties that describe the buffer that is being registered.
+ *
+ * Buffer_p (input)
+ *     Pointer to the buffer. This pointer must be valid to use on the host
+ *     in the domain of the driver.
+ *
+ * Alternative_p (input)
+ *     Some allocators return two addresses. This parameter can be used to
+ *     pass this second address to the driver. The type is pointer to ensure
+ *     it is always large enough to hold a system address, also in LP64
+ *     architecture. Set to NULL if not used.
+ *
+ * AllocatorRef (input)
+ *     Number to describe the source of this buffer. The exact numbers
+ *     supported is implementation specitic. This provides some flexibility
+ *     for a specific implementation to support a number of "alien" buffers
+ *     from different allocator and propertly interpret and use the
+ *     Alternative_p parameter when translating the address to the device
+ *     memory map. Set to zero if not used.
+ *
+ * Handle_p (output)
+ *     Pointer to the memory location when the handle will be returned.
+ *
+ * Return Values
+ *     DMABUF_STATUS_OK: Success, Handle_p was written.
+ *     DMABUF_ERROR_BAD_ARGUMENT
+ *     DMABUF_ERROR_OUT_OF_MEMORY: Failed to allocate a handle.
+ */
+DMABuf_Status_t
+DMABuf_Register(
+        const DMABuf_Properties_t ActualProperties,
+        void * Buffer_p,
+        void * Alternative_p,
+        const char AllocatorRef,
+        DMABuf_Handle_t * const Handle_p);
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Release
+ *
+ * This function will close the handle that was returned by DMABuf_Alloc or
+ * DMABuf_Register, meaning it must not be used anymore.
+ * If the buffer was allocated through DMABuf_Alloc, this function will also
+ * free the buffer, meaning it must not be accessed anymore.
+ *
+ * Handle (input)
+ *     The handle that may be released.
+ *
+ * Return Values
+ *     DMABUF_STATUS_OK
+ *     DMABUF_ERROR_INVALID_HANDLE
+ */
+DMABuf_Status_t
+DMABuf_Release(
+        DMABuf_Handle_t Handle);
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_eip93.h b/drivers/net/cryptoDriver/include/mtk_eip93.h
new file mode 100755
index 0000000..09af73a
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_eip93.h
@@ -0,0 +1,348 @@
+
+#ifndef EIP93_EIP93_H
+#define EIP93_EIP93_H
+
+#include "mtk_baseDefs.h"
+#include "mtk_hwAccess.h"
+
+/*----------------------------------------------------------------------------
+ * Physical (bus) address used by EIP93 device
+ */
+typedef struct
+{
+    // 32bit physical bus address
+    uint32_t Addr;
+
+    // upper 32bit part of a 64bit physical address
+    // Note: this value has to be provided only for 64bit addresses,
+    // in this case Addr field provides the lower 32bit part
+    // of the 64bit address, for 32bit addresses this field is ignored,
+    // and should be set to 0.
+    uint32_t UpperAddr;
+} EIP93_DeviceAddress_t;
+
+
+/*----------------------------------------------------------------------------
+ * ERROR codes returned by the API
+ * EIP93_STATUS_OK : successful completion of the call.
+ * EIP93_ERROR_BAD_ARGUMENT :  invalid argument for  function parameter.
+ * EIP93_ERROR_BUSY_RETRY_LATER : Device is busy.
+ * EIP93_ERROR_UNSUPPORTED_IN_THIS_STATE : a function cannot be called
+ * EIP93_ERROR_NOT_IMPLEMENTED: functionality not implemented yet in this
+ *                              state.
+ * EIP93_ERROR_TOO_MUCH_DATA: trying to write more data than provided.
+ *                            command descriptor length filed. Valid in
+ *                            DHM only.
+ * EIP93_ERROR_NO_MORE_DATA: trying read when there is no data  or all have
+ *                           been.Valid in DHM only.
+ * EIP93_ERROR_MEMORY_INSUFFICIENT: when provided buffer no enough to all data.
+ *                                  Valid in DHM only.
+ */
+
+typedef enum
+{
+    EIP93_STATUS_OK = 0,
+    EIP93_ERROR_BAD_ARGUMENT,
+    EIP93_ERROR_BUSY_RETRY_LATER,
+    EIP93_ERROR_UNSUPPORTED_IN_THIS_STATE,
+    EIP93_ERROR_NOT_IMPLEMENTED,
+    EIP93_ERROR_TOO_MUCH_DATA,
+    EIP93_ERROR_NO_MORE_DATA,
+    EIP93_ERROR_MEMORY_INSUFFICIENT
+} EIP93_Status_t;
+
+
+/*----------------------------------------------------------------------------
+ * Capabilities Structure for EIP93
+ */
+typedef struct
+{
+    // DES and Triple DES encryption standard indicator.
+    uint8_t fDesTdes;
+    // ARC4 encryption standard indicator.
+    uint8_t fARC4;
+    // AES encryption standard indicator.
+    uint8_t fAes;
+    //AES with 128 bit key indicator.
+    uint8_t fAes128;
+    //AES with 192 bit key indicator.
+    uint8_t fAes192;
+    //AES with 256 bit key indicator.
+    uint8_t fAes256;
+    // Kasumi f8 encryption standard indicator.
+    uint8_t fKasumiF8;
+    // DES OFB1-8-64 and CFB1-8-64 mode indicator.
+    uint8_t fDesOfgCfb;
+    // AES CFB1-8-128 mode indicator.
+    uint8_t fAesCfb;
+    // MD5 hash algorithm indicator.
+    uint8_t fMd5;
+    // SHA-1 hash algorithm indicator.
+    uint8_t fSha1;
+    // SHA-2 224 hash algorithm indicator.
+    uint8_t fSha224;
+    // SHA-2 256 hash algorithm indicator.
+    uint8_t fSha256;
+    // SHA-2 384 hash algorithm indicator.
+    uint8_t fSha384;
+    // SHA-2 512 hash algorithm indicator.
+    uint8_t fSha512;
+    // Kasumi f9 encryption standard indicator.
+    uint8_t fKasumiF9;
+    // 128-Bit AES-XCBC-MAC and AES-CCM mode indicator.
+    uint8_t fAesXcbc;
+    // Galois HASH and AES Galois Counter Mode (GCM) indicator
+    uint8_t fGcm;
+    // AES-Galois Message Authentication Code (GMAC) indicator.
+    uint8_t fGmac;
+    // AES CBC MAC indicator
+    uint8_t fAesCbcMac;
+    // AES CBC MAC with 128-bit key indicator
+    uint8_t fAesCbcMac128;
+    // AES CBC MAC with 192-bit key indicator
+    uint8_t fAesCbcMac192;
+    // AES CBC MAC with 256-bit key indicator
+    uint8_t fAesCbcMac256;
+    // Type of external interface.
+    uint8_t IntFaceType;
+    // 64-Bit Address indicator.
+    uint8_t f64BitAddress;
+    // Interrupt controller indicator.
+    uint8_t fExtInterrupt;
+    // Pseudo Random Number Generator indicator.
+    uint8_t fPrng;
+    // SA Revision 1 indicator.
+    uint8_t fSARev1;
+    // SA Revision 2 indicator.
+    uint8_t fSARev2;
+    // Dynamic SA indicator.
+    uint8_t fDynamicSA;
+    // extended sequence numner
+    uint8_t fEsn;
+    // ESP for IPv4 IPSec and IPv6 IPSec indicator.
+    uint8_t fEsp;
+    // AH for IPv4 and IPv6 IPSec indicator.
+    uint8_t fAh;
+    // Security Socket Layer (SSL)
+    uint8_t fSsl;
+    // Transport Layer Security (TLS) v1.0 or 1.1 indicator.
+    uint8_t fTls;
+    // Datagram Transport Layer Security (DTLS) 1.0
+    uint8_t fDtls;
+    // Secures Real-Time Protocol (SRTP)
+    uint8_t fSrtp;
+    // Media Access Control Security (MACSec)
+    uint8_t fMacsec;
+    // The basic EIP number.
+    uint8_t EipNumber;
+    // The complement of the basic EIP number.
+    uint8_t ComplmtEipNumber;
+    // Hardware Patch Level.
+    uint8_t HWPatchLevel;
+    // Minor Hardware revision.
+    uint8_t MinHWRevision;
+    // Major Hardware revision.
+    uint8_t MajHWRevision;
+} EIP93_Capabilities_t;
+
+
+#define EIP93_IOAREA_REQUIRED_SIZE  32
+typedef struct
+{
+    uint32_t placeholder[EIP93_IOAREA_REQUIRED_SIZE];
+} EIP93_IOArea_t;
+
+
+/*----------------------------------------------------------------------------
+ *                         Common API
+ *----------------------------------------------------------------------------
+ */
+/*----------------------------------------------------------------------------
+ * EIP93_HWRevision_Get
+ *
+ * This function returns hardware revision information in three components.
+ * Each can have a value in the range 0-9.
+ *
+ */
+EIP93_Status_t
+EIP93_HWRevision_Get(
+        EIP93_IOArea_t * const  IOArea_p,
+        EIP93_Capabilities_t * const Capabilities_p);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_Initialize
+ *
+ * Intialize the hardware platform for EIP93 register access.
+ *
+ * This function is only allowed to be called from the 'reset' state.
+ * This function puts the device into the 'initialized' state.
+ *
+ * IOArea_p - the EIP93 Driver Library API external storage context data.
+ * It has to be allocated by the user.
+ *
+ * (input)Device - a static resource handle obtained with HWPAL_Device_Find().
+ */
+EIP93_Status_t
+EIP93_Initialize(
+        EIP93_IOArea_t * const IOArea_p,
+        const HWPAL_Device_t Device);
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_Deactivate
+ *
+ * This function is only allowed to be called from
+ * 'ARM activated', or 'DHM activated' states, to which
+ * the device can be put by corresponding _Activate functions.
+ * This function puts the device back to the 'initialized' state.
+ */
+EIP93_Status_t
+EIP93_Deactivate(
+        EIP93_IOArea_t * const IOArea_p);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_Shutdown
+ *
+ * This function is allowed to be called from any state.
+ * This function puts the device in the 'reset' state, i.e. stops the device.
+ */
+EIP93_Status_t
+EIP93_Shutdown(
+        EIP93_IOArea_t * const IOArea_p);
+
+
+/*----------------------------------------------------------------------------
+ *                         Common Interrupt Service
+ *----------------------------------------------------------------------------
+ */
+
+/*----------------------------------------------------------------------------
+ * Interrupts of EIP93
+ */
+typedef enum
+{
+    EIP93_INT_PE_CDRTHRESH_REQ =   BIT_0,
+    EIP93_INT_PE_RDRTHRESH_REQ =   BIT_1,
+    EIP93_INT_PE_OPERATION_DONE =  BIT_9,
+    EIP93_INT_PE_INBUFTHRESH_REQ = BIT_10,
+    EIP93_INT_PE_OUTBURTHRSH_REQ = BIT_11,
+    EIP93_INT_PE_ERR_REG =         BIT_13,
+    EIP93_INT_PE_RD_DONE_IRQ =     BIT_16
+
+} EIP93_InterruptSource_t;
+
+/*----------------------------------------------------------------------------
+ * Bitmask for a set of interrupts of EIP93
+ * This represents an 'OR'-ed combination of EIP93_InterruptSource_t values
+ */
+typedef uint32_t EIP93_INT_SourceBitmap_t;
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_Mask
+ *
+ * Masks  certain interrupt lines.
+ *
+ * WhichIntSources
+ *      Specifies which interrupt sources to mask:
+ *      '0' - means an interrupt source is left as is.
+ *      '1' - means an interrupt source is masked (disabled)
+ */
+EIP93_Status_t
+EIP93_INT_Mask(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_INT_SourceBitmap_t WhichIntSources);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_UnMask
+ *
+ * Unmasks certain interrupt lines.
+ *
+ * WhichIntSources
+ *      Specifies which interrupt sources to Unmask:
+ *      '0' - means an interrupt source is left as is.
+ *      '1' - means an interrupt source is Unmasked (enabled)
+ */
+EIP93_Status_t
+EIP93_INT_UnMask(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_INT_SourceBitmap_t WhichIntSources);
+
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_IsRawActive
+ *
+ * Reads the raw status of all interrupt sources.
+ * Raw means the status is provided before an interrupt mask is applied.
+ *
+ * PendingIntSources_p
+ *      is the output parameter that on return contains the following
+ *      status for each interrupt source:
+ *      '0' - interrupt is not pending (inactive, not present)
+ *      '1' - interrupt is pending (active, present)
+ */
+EIP93_Status_t
+EIP93_INT_IsRawActive(
+        EIP93_IOArea_t * const IOArea_p,
+        EIP93_INT_SourceBitmap_t * const PendingIntSources_p);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_IsActive
+ *
+ * Reads the status of all interrupt sources.
+ * In this case the status is provided after an interrupt mask is applied.
+ * So this means that although a raw interrupt might be pending, but it is
+ * masked (disabled), this function will indicate that the interrupt is
+ * not pending (inactive).
+ *
+ * PendingIntSources_p
+ *      is the output parameter that on return contains the following
+ *      status for each interrupt source:
+ *      '0' - interrupt is not pending (inactive, not present)
+ *      '1' - interrupt is pending (active, present)
+ */
+EIP93_Status_t
+EIP93_INT_IsActive(
+        EIP93_IOArea_t * const IOArea_p,
+        EIP93_INT_SourceBitmap_t * const PendingIntSources_p);
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_Acknowledge
+ *
+ * Acknowledges certain interrupt lines.
+ *
+ * WhichIntSources
+ *      Specifies which interrupt sources to acknowledge (to clear):
+ *      '0' - means an interrupt source is not acknowledged
+ *           (status is unchanged)
+ *      '1' - means an interrupt source is acknowledged (status is cleared)
+ */
+EIP93_Status_t
+EIP93_INT_Acknowledge(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_INT_SourceBitmap_t WhichIntSources);
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_Configure
+ *
+ * sets the type- pulse or level, for the interrupt output;
+ * enable/disable auto clearing functionality of the interrupts.
+ *
+ */
+EIP93_Status_t
+EIP93_INT_Configure(
+        EIP93_IOArea_t * const IOArea_p,
+        const bool fPulsedInt,
+        const bool fAutoClear);
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_hwAccess.h b/drivers/net/cryptoDriver/include/mtk_hwAccess.h
new file mode 100755
index 0000000..80316dc
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_hwAccess.h
@@ -0,0 +1,280 @@
+
+#ifndef EIP93_HW_ACCESS_H
+#define EIP93_HW_ACCESS_H
+
+#include "mtk_baseDefs.h"     // bool, uint32_t, inline
+#include "mtk_csHwPci.h"
+
+
+/*----------------------------------------------------------------------------
+ * rt_dump_register
+ *
+ * This function dumps an Crypto Engine's register.
+ * (define RT_DUMP_REGISTER in mtk_csHwPci.h before use it!)
+ *
+ * Use rt_dump_register(0xfff) to dump all registers.
+ * Use rt_dump_register(register_offset) to dump a specific register.
+ * The register_offset can be referred in Programmer-Manual.pdf
+ */
+void
+rt_dump_register(
+		unsigned int offset);
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Initialize
+ *
+ * This function must be called exactly once to initialize the HWPAL
+ * implementation before any other API function may be used.
+ *
+ * CustomInitData_p
+ *     This anonymous parameter can be used to pass information from the caller
+ *     to the driver framework implementation.
+ *
+ * Return Value
+ *     true   Success
+ *     false  Failed to initialize
+ */
+bool
+HWPAL_Initialize(
+        void * CustomInitData_p);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_UnInitialize
+ *
+ * This function can be called to shut down the HWPAL implementation. The
+ * caller must make sure none of the other API functions are called after or
+ * during the invokation of this UnInitialize function. After this call
+ * returns the API state is back in "uninitialized" and the HWPAL_Initialize
+ * function may be used anew.
+ *
+ * Return Value
+ *     None
+ */
+void
+HWPAL_UnInitialize(void);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_SwapEndian32
+ *
+ * This function can be used to swap the byte order of a 32bit integer. The
+ * implementation could use custom CPU instructions, if available.
+ */
+static inline uint32_t
+HWPAL_SwapEndian32(
+        const uint32_t Value)
+{
+#ifdef HWPAL_SWAP_SAFE
+    return (((Value & 0x000000FFU) << 24) |
+            ((Value & 0x0000FF00U) <<  8) |
+            ((Value & 0x00FF0000U) >>  8) |
+            ((Value & 0xFF000000U) >> 24));
+#else
+    // reduced typically unneeded AND operations
+    return ((Value << 24) |
+            ((Value & 0x0000FF00U) <<  8) |
+            ((Value & 0x00FF0000U) >>  8) |
+            (Value >> 24));
+#endif
+}
+
+
+/*****************************************************************************
+ * HWPAL_Device
+ *
+ * These functions can be used to transfer a single 32bit word, or an array of
+ * such words to or from a device. The device, typically a single hardware
+ * block within a chip, is represented by the handle.
+ *
+ * The handles are typically defined statically and can be retrieved by the
+ * caller using the HWPAL_Device_Find function.
+ *
+ * The driver libraries use the handle to allow one chip to contain multiple
+ * instances of a device type and reuse the driver for each instance.
+ * The driver libraries will access the device resources (registers and RAM)
+ * using offsets.
+ *
+ * Each device has its own configuration, including the endianess swapping
+ * need for the words transferred. Endianess swapping can thus be performed on
+ * the fly and transparent to the caller.
+ */
+
+typedef void * HWPAL_Device_t;
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Find
+ *
+ * This function must be used to retrieve a handle for a certain device that
+ * is identified by a string. The exact strings supported is decided by the
+ * implementation of driver framework and can differ from product to product.
+ * Note that this function may be called more than once to retrieve the same
+ * handle for the same device.
+ *
+ * DeviceName_p (input)
+ *     Pointer to the (zero-terminated) string that represents the device.
+ *
+ * Device_p (output)
+ *     Pointer to the memory location where the device handle will be written
+ *     when it is found.
+ *
+ * Return Value
+ *     true   Success, handle was written.
+ *     false  Device is not supported.
+ */
+bool
+HWPAL_Device_Find(
+        const char * DeviceName_p,
+        HWPAL_Device_t * const Device_p);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Init
+ *
+ * This is an initialization point for the device instance. It must be called
+ * exactly once before the device handle may be used to read or write the
+ * device resources. It is typically called from the Driver Library.
+ *
+ * Device
+ *     Handle for the device instance as returned by HWPAL_Device_Find.
+ *
+ * Return Value
+ *     None
+ */
+void
+HWPAL_Device_Init(
+        HWPAL_Device_t Device);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Read32
+ *
+ * This function can be used to read one 32bit resource inside a device
+ * (typically a register or memory location). Since reading registers can have
+ * side effects, the implementation must guarantee that the resource will be
+ * read only once and no neighbouring resources will be accessed.
+ *
+ * If required (decided based on internal configuration), on the fly endianess
+ * swapping of the value read will be performed before it is returned to the
+ * caller.
+ *
+ * Device (input)
+ *     Handle for the device instance as returned by HWPAL_Device_Find.
+ *
+ * ByteOffset (input)
+ *     The byte offset within the device for the resource to read.
+ *
+ * Return Value
+ *     The value read.
+ *
+ * When the Device or Offset parameters are invalid, the implementation will
+ * return an unspecified value.
+ */
+uint32_t
+HWPAL_Device_Read32(
+        HWPAL_Device_t Device,
+        const unsigned int ByteOffset);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Write32
+ *
+ * This function can be used to write one 32bit resource inside the device
+ * (typically a register or memory location). Since writing registers can
+ * have side effects, the implementation must guarantee that the resource will
+ * be written only once and no neighbouring resources will be accessed.
+ *
+ * If required (decided based on internal configuration), on the fly endianess
+ * swapping of the value to be written will be performed.
+ *
+ * Device (input)
+ *     Handle for the device instance as returned by HWPAL_Device_Find.
+ *
+ * ByteOffset (input)
+ *     The byte offset within the device for the resource to write.
+ *
+ * Value (input)
+ *     The 32bit value to write.
+ *
+ * Return Value
+ *     None
+ *
+ * The write can only be successful when the Device and ByteOffset parameters
+ * are valid.
+ */
+void
+HWPAL_Device_Write32(
+        HWPAL_Device_t Device,
+        const unsigned int ByteOffset,
+        const uint32_t Value);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Read32Array
+ *
+ * This function perform the same task as HWPAL_Device_Read32 for a
+ * consecutive array of 32bit words, allowing the implementation to use a
+ * more optimal burst-read.
+ *
+ * See HWPAL_Device_Read32 for a more detailed description.
+ *
+ * Device (input)
+ *     Handle for the device instance as returned by HWPAL_Device_Find.
+ *
+ * ByteOffset (input)
+ *     Byte offset of the first resource to read. This value is incremented
+ *     by 4 for each following resource.
+ *
+ * MemoryDst_p (output)
+ *     Pointer to the memory where the retrieved words will be stored.
+ *
+ * Count (input)
+ *     The number of 32bit words to transfer.
+ *
+ * Return Value
+ *     None.
+ */
+void
+HWPAL_Device_Read32Array(
+        HWPAL_Device_t Device,
+        unsigned int ByteOffset,
+        uint32_t * MemoryDst_p,
+        const int Count);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Write32Array
+ *
+ * This function perform the same task as HWPAL_Device_Write32 for a
+ * consecutive array of 32bit words, allowing the implementation to use a
+ * more optimal burst-write.
+ *
+ * See HWPAL_Device_Write32 for a more detailed description.
+ *
+ * Device (input)
+ *     Handle for the device instance as returned by HWPAL_Device_Find.
+ *
+ * ByteOffset (input)
+ *     Byte offset of the first resource to write. This value is incremented
+ *     by 4 for each following resource.
+ *
+ * MemorySrc_p (input)
+ *     Pointer to the memory where the values to be written are located.
+ *
+ * Count (input)
+ *     The number of 32bit words to transfer.
+ *
+ * Return Value
+ *     None.
+ */
+void
+HWPAL_Device_Write32Array(
+        HWPAL_Device_t Device,
+        unsigned int ByteOffset,
+        const uint32_t * MemorySrc_p,
+        const int Count);
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_hwDmaAccess.h b/drivers/net/cryptoDriver/include/mtk_hwDmaAccess.h
new file mode 100755
index 0000000..3921013
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_hwDmaAccess.h
@@ -0,0 +1,332 @@
+
+#ifndef EIP93_HW_DMA_ACCESS_H
+#define EIP93_HW_DMA_ACCESS_H
+
+#include "mtk_baseDefs.h"         // bool, uint32_t, inline
+
+
+/*****************************************************************************
+ * HWPAL_DMAResource
+ *
+ * These functions are related to management of memory buffers that can be
+ * accessed by the host as well as a device, using Direct Memory Access (DMA).
+ * A driver must typically support many of these shared resources. This API
+ * helps with administrating these resources, but does not allocate the actual
+ * memory buffer.
+ *
+ * This API maintains administration records that the caller can read and
+ * write directly. A handle is also provided, to abstract the record.
+ * The handle cannot be used to directly access the buffer and is therefore
+ * considered safe to pass around in the system, even to applications.
+ *
+ * Another important aspect of this API is to provide a point where buffers
+ * can be handed over between the host and the device. The driver library or
+ * adapter must call the PreDMA and PostDMA functions to indicate the hand over
+ * of access right between the host and the device for an entire buffer,or
+ * part thereof. The implementation can use these calls to manage the
+ * data coherency for the buffer, for example in a cached system.
+ *
+ * Memory buffers are different from HWPAL_Device resources, which represent
+ * static device-internal resources with possible read and write side-effects.
+ *
+ * On the fly endianess swapping for words is supported for DMA Resources by
+ * means of the Read32 and Write32 functions.
+ *
+ * Note: If multiple devices with a different memory view need to use the same
+ * DMAResource, then the caller should consider separate records for each
+ * device (for the same buffer).
+ */
+
+typedef void * HWPAL_DMAResource_Handle_t;
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Record_t
+ *
+ * This type is the record that describes a DMAResource. The caller shall use
+ * HWPAL_DMAResource_Create to instantiate a record and get a handle to that
+ * record.
+ * Use HWPAL_DMAResource_Handle2RecordPtr to get a pointer to the actual
+ * record (as shown below) and to manipulate the fields in the record.
+ */
+
+#include "mtk_hwDmaRecord.h"   // HWPAL_DMAResource_Record_t definition
+
+
+bool
+HWPAL_DMAResource_Init(
+        const unsigned int MaxHandles);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_UnInit
+ *
+ * This function can be used to uninitialize the DMAResource administration.
+ * The caller must make sure that handles will not be used after this function
+ * returns. If memory was allocated by HWPAL_DMAResource_Init, this function
+ * will free it.
+ */
+void
+HWPAL_DMAResource_UnInit(void);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Create
+ *
+ * This function can be used to create a record. The function returns a handle
+ * for the record. Use HWPAL_DMAResource_Handle2RecordPtr to access the record.
+ * Destroy the record when no longer required, see HWPAL_DMAResource_Destroy.
+ * This function initializes the record to all zeros.
+ *
+ * Return Values
+ *     Handle for the DMA Resource.
+ *     NULL is returned when the creation failed.
+ */
+HWPAL_DMAResource_Handle_t
+HWPAL_DMAResource_Create(void);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Destroy
+ *
+ * This function can be used to delete a record. This deletes all the fields
+ * and invalidates the handle.
+ *
+ * Handle
+ *     A valid handle that was once returned by HWPAL_DMAResource_Create.
+ *
+ * Return Values
+ *     None
+ */
+void
+HWPAL_DMAResource_Destroy(
+        HWPAL_DMAResource_Handle_t Handle);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_IsValidHandle
+ *
+ * This function validates a handle.
+ *
+ * Handle
+ *     A valid handle that was once returned by HWPAL_DMAResource_Create.
+ *
+ * Return Value
+ *     true  The handle is valid
+ *     false The handle is NOT valid
+ */
+bool
+HWPAL_DMAResource_IsValidHandle(
+        HWPAL_DMAResource_Handle_t Handle);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Handle2RecordPtr
+ *
+ * This function can be used to get a pointer to the DMA Resource record
+ * (HWPAL_DMAResourceRecord_t) for the handle. The pointer is valid until
+ * the handle is destroyed with HWPAL_DMAResource_Destroy.
+ *
+ * Handle
+ *     A valid handle that was once returned by HWPAL_DMAResource_Create.
+ *
+ * Return Value
+ *     Pointer to the HWPAL_DMAResource_Record_t memory for this handle.
+ *     NULL is returned if the handle is invalid.
+ */
+HWPAL_DMAResource_Record_t *
+HWPAL_DMAResource_Handle2RecordPtr(
+        HWPAL_DMAResource_Handle_t Handle);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Read32
+ *
+ * This function can be used to read one 32bit word from the DMA Resource
+ * buffer.
+ * If required (decided by HWPAL_DMAResource_Record_t.device.fSwapEndianess),
+ * on the fly endianess swapping of the value read will be performed before it
+ * is returned to the caller.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to read from.
+ *
+ * Return Value
+ *     The value read.
+ *
+ * When the Handle and WordOffset parameters are not valid, the implementation
+ * will return an unspecified value.
+ */
+uint32_t
+HWPAL_DMAResource_Read32(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Write32
+ *
+ * This function can be used to write one 32bit word to the DMA Resource.
+ * If required (decided by HWPAL_DMAResource_Record_t.device.fSwapEndianess),
+ * on the fly endianess swapping of the value to be written will be performed.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to write to.
+ *
+ * Value (input)
+ *     The 32bit value to write.
+ *
+ * Return Value
+ *     None
+ *
+ * The write can only be successful when the Handle and WordOffset
+ * parameters are valid.
+ */
+void
+HWPAL_DMAResource_Write32(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const uint32_t Value);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Read32Array
+ *
+ * This function perform the same task as HWPAL_DMAResource_Read32 for a
+ * consecutive array of 32bit words.
+ *
+ * See HWPAL_DMAResource_Read32 for a more detailed description.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to start
+ *     reading from.
+ *
+ * WordCount (input)
+ *     The number of 32bit words to transfer.
+ *
+ * Values_p (input)
+ *     Memory location to write the retrieved values to.
+ *     Note the ability to let Values_p point inside the DMAResource that is
+ *     being read from, allowing for in-place endianess conversion.
+ *
+ * Return Value
+ *     None.
+ *
+ * The read can only be successful when the Handle and WordOffset
+ * parameters are valid.
+ */
+void
+HWPAL_DMAResource_Read32Array(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const unsigned int WordCount,
+        uint32_t * Values_p);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Write32Array
+ *
+ * This function perform the same task as HWPAL_DMAResource_Write32 for a
+ * consecutive array of 32bit words.
+ *
+ * See HWPAL_DMAResource_Write32 for a more detailed description.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to start
+ *     writing from.
+ *
+ * WordCount (input)
+ *     The number of 32bit words to transfer.
+ *
+ * Values_p (input)
+ *     Pointer to the memory where the values to be written are located.
+ *     Note the ability to let Values_p point inside the DMAResource that is
+ *     being written to, allowing for in-place endianess conversion.
+ *
+ * Return Value
+ *     None.
+ *
+ * The write can only be successful when the Handle and WordOffset
+ * parameters are valid.
+ */
+void
+HWPAL_DMAResource_Write32Array(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const unsigned int WordCount,
+        const uint32_t * Values_p);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_PreDMA
+ *
+ * This function must be called when the host has finished accessing the
+ * DMA Resource and the device (using its DMA) is the next to access it.
+ * It is possible to hand off the entire DMA Resource, or only a selected part
+ * of it by describing the part with a start offset and count.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to (partially) hand off.
+ *
+ * ByteOffset (input)
+ *     Start offset within the DMA resource for the selected part to hand off
+ *     to the device.
+ *
+ * ByteCount (input)
+ *     Number of bytes from ByteOffset for the part of the DMA Resource to
+ *     hand off to the device.
+ *     Set to zero to hand off the entire DMA Resource.
+ *
+ * The driver framework implementation must use this call to ensure the data
+ * coherency of the DMA Resource.
+ */
+void
+HWPAL_DMAResource_PreDMA(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int ByteOffset,
+        const unsigned int ByteCount);
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_PostDMA
+ *
+ * This function must be calle when the device has finished accessing the
+ * DMA Resource and the host can reclaim ownership and access it.
+ * It is possible to reclaim ownership for the entire DMA Resource, or only a
+ * selected part of it by describing the part with a start offset and count.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to (partially) hand off.
+ *
+ * ByteOffset (input)
+ *     Start offset within the DMA resource for the selected part to reclaim.
+ *
+ * ByteCount (input)
+ *     Number of bytes from ByteOffset for the part of the DMA Resource to
+ *     reclaim.
+ *     Set to zero to reclaim the entire DMA Resource.
+ *
+ * The driver framework implementation must use this call to ensure the data
+ * coherency of the DMA Resource.
+ */
+void
+HWPAL_DMAResource_PostDMA(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int ByteOffset,
+        const unsigned int ByteCount);
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_hwDmaRecord.h b/drivers/net/cryptoDriver/include/mtk_hwDmaRecord.h
new file mode 100755
index 0000000..d566861
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_hwDmaRecord.h
@@ -0,0 +1,64 @@
+
+#ifndef EIP93_HW_DMA_RECORD_H
+#define EIP93_HW_DMA_RECORD_H
+
+#include "mtk_dmaBuf.h"
+
+typedef struct
+{
+    uint32_t Magic;     // signature used to validate handles
+
+    struct
+    {
+        // for freeing the buffer
+        void * AllocatedAddr_p;
+        unsigned int AllocatedSize;     // in bytes
+
+        void * Alternative_p;
+        char AllocatorRef;
+
+        // for separating SoC memory from main memory
+        uint8_t MemoryBank;
+
+    } alloc;
+
+    struct
+    {
+        // alignment used for HostAddr_p
+        uint8_t Alignment;
+
+        // aligned start-address, data starts here
+        void * HostAddr_p;
+
+        // maximum data amount that can be stored from HostAddr_p
+        unsigned int BufferSize;        // in bytes
+
+        // true = memory is cached
+        bool fCached;
+    } host;
+
+    struct
+    {
+        // used by Read/Write32[Array]
+        bool fSwapEndianess;
+
+        // address as seen by device
+        // (must point to same buffer as HostAddr_p)
+        // 0 = not yet translated
+        uint32_t DeviceAddr32;
+
+    } device;
+
+#ifndef ADAPTER_REMOVE_BOUNCEBUFFERS
+    struct
+    {
+        // bounce buffer for DMABuf_Register'ed buffers
+        // note: used only when concurrency is impossible
+        //       (PE source packets allow concurrency!!)
+        DMABuf_Handle_t Bounce_Handle;
+    } bounce;
+#endif
+
+} HWPAL_DMAResource_Record_t;
+
+#endif
diff --git a/drivers/net/cryptoDriver/include/mtk_hwInterface.h b/drivers/net/cryptoDriver/include/mtk_hwInterface.h
new file mode 100755
index 0000000..a0e9b2e
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_hwInterface.h
@@ -0,0 +1,201 @@
+
+#ifndef EIP93_HW_INTERFACE_H
+#define EIP93_HW_INTERFACE_H
+
+#define EIP93_REG_WIDTH     4
+/*-----------------------------------------------------------------------------
+ * Register Map
+ */
+#define DESP_BASE                     0x0000000
+#define EIP93_REG_PE_CTRL_STAT      ((DESP_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_SOURCE_ADDR    ((DESP_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_DEST_ADDR      ((DESP_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_SA_ADDR        ((DESP_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_ADDR           ((DESP_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_USER_ID        ((DESP_BASE)+(0x06 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_LENGTH         ((DESP_BASE)+(0x07 * EIP93_REG_WIDTH))
+
+//PACKET ENGINE RING configuartion registers
+#define PE_RNG_BASE                0X0000080
+
+#define EIP93_REG_PE_CDR_BASE        ((PE_RNG_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RDR_BASE        ((PE_RNG_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RING_CONFIG     ((PE_RNG_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RING_THRESH     ((PE_RNG_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_CD_COUNT        ((PE_RNG_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RD_COUNT        ((PE_RNG_BASE)+(0x05 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RING_RW_PNTR    ((PE_RNG_BASE)+(0x06 * EIP93_REG_WIDTH))
+
+
+//PACKET ENGINE  configuartion registers
+#define PE_CONF_BASE                 0X0000100
+#define EIP93_REG_PE_CONFIG         ((PE_CONF_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_STATUS         ((PE_CONF_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_BUF_THRESH     ((PE_CONF_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_INBUF_COUNT    ((PE_CONF_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_OUTBUF_COUNT   ((PE_CONF_BASE)+(0x05 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_BUF_RW_PNTR    ((PE_CONF_BASE)+(0x06 * EIP93_REG_WIDTH))
+
+//PACKET ENGINE endian config
+#define END_CONF_BASE                      0x00001CC
+#define EIP93_REG_PE_ENDIAN_CONFIG  ((END_CONF_BASE)+(0x00 * EIP93_REG_WIDTH))
+
+//EIP93 CLOCK control registers
+#define CLOCK_BASE        0X01E8
+#define EIP93_REG_PE_CLOCK_CTRL     ((CLOCK_BASE)+(0x00 * EIP93_REG_WIDTH))
+
+
+//EIP93 Device Option and Revision Register
+#define REV_BASE        0X01F4
+#define EIP93_REG_PE_OPTION_1        ((REV_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_OPTION_0        ((REV_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_REVISION        ((REV_BASE)+(0x02 * EIP93_REG_WIDTH))
+
+
+//EIP93 Interrupt Control Register
+#define INT_BASE        0x0200
+#define EIP93_REG_INT_UNMASK_STAT    ((INT_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_MASK_STAT      ((INT_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_CLR            ((INT_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_MASK           ((INT_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_CFG            ((INT_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_MASK_ENABLE        ((INT_BASE)+(0X04 * EIP93_REG_WIDTH))
+#define EIP93_REG_MASK_DISABLE       ((INT_BASE)+(0X05 * EIP93_REG_WIDTH))
+
+
+
+//EIP93 SA Record register
+#define SA_BASE         0X0400
+#define EIP93_REG_SA_CMD_0         ((SA_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_SA_CMD_1         ((SA_BASE)+(0x01 * EIP93_REG_WIDTH))
+
+
+//#define EIP93_REG_SA_READY         ((SA_BASE)+(31 * EIP93_REG_WIDTH))
+
+
+
+//State save register
+#define STATE_BASE      0x0500
+#define EIP93_REG_STATE_IV_0        ((STATE_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_STATE_IV_1        ((STATE_BASE)+(0x01 * EIP93_REG_WIDTH))
+
+#define EIP93_PE_ARC4STATE_BASEADDR_REG 0x0700
+
+
+//RAM buffer start address
+#define EIP93_INPUT_BUFFER             0x0800
+#define EIP93_OUTPUT_BUFFER            0x0800
+
+
+//EIP93 PRNG Configuration Register
+#define PRNG_BASE                      0X300
+#define EIP93_REG_PRNG_STAT          ((PRNG_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_CTRL          ((PRNG_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_0        ((PRNG_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_1        ((PRNG_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_2        ((PRNG_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_3        ((PRNG_BASE)+(0x05 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_0         ((PRNG_BASE)+(0x06 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_1         ((PRNG_BASE)+(0x07 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_2         ((PRNG_BASE)+(0x08 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_3         ((PRNG_BASE)+(0x09 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_0         ((PRNG_BASE)+(0x0A * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_1         ((PRNG_BASE)+(0x0B * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_2         ((PRNG_BASE)+(0x0C * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_3         ((PRNG_BASE)+(0x0D * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_LFSR_0        ((PRNG_BASE)+(0x0E * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_LFSR_1        ((PRNG_BASE)+(0x0F * EIP93_REG_WIDTH))
+
+
+/*-----------------------------------------------------------------------------
+ * Constants & masks
+ */
+
+#define EIP93_SUPPORTED_INTERRUPTS_MASK      0xffff7f00
+#define EIP93_PRNG_DT_TEXT_LOWERHALF         0xDEAD
+#define EIP93_PRNG_DT_TEXT_UPPERHALF         0xC0DE
+#define EIP93_10BITS_MASK                    0X3FF
+#define EIP93_12BITS_MASK                   0XFFF
+#define EIP93_4BITS_MASK                    0X04
+#define EIP93_20BITS_MASK            0xFFFFF
+
+#define EIP93_MIN_DESC_DONE_COUNT    0
+#define EIP93_MAX_DESC_DONE_COUNT    15
+
+#define EIP93_MIN_DESC_PENDING_COUNT  0
+#define EIP93_MAX_DESC_PENDING_COUNT  1023
+
+#define EIP93_MIN_TIMEOUT_COUNT      0
+#define EIP93_MAX_TIMEOUT_COUNT      15
+
+
+#define EIP93_MIN_PE_INPUT_THRESHOLD   1
+#define EIP93_MAX_PE_INPUT_THRESHOLD   511
+
+#define EIP93_MIN_PE_OUTPUT_THRESHOLD   1
+#define EIP93_MAX_PE_OUTPUT_THRESHOLD   432
+
+#define EIP93_MIN_PE_RING_SIZE          1
+#define EIP93_MAX_PE_RING_SIZE          1023
+
+#define EIP93_MIN_PE_DESCRIPTOR_SIZE    7
+#define EIP93_MAX_PE_DESCRIPTOR_SIZE    15
+
+//3DES keys,seed,known data and its result
+#define EIP93_KEY_0             0x133b3454
+#define EIP93_KEY_1             0x5e5b890b
+#define EIP93_KEY_2             0x5eb30757
+#define EIP93_KEY_3             0x93ab15f7
+#define EIP93_SEED_0            0x62c4bf5e
+#define EIP93_SEED_1            0x972667c8
+#define EIP93_SEED_2            0x6345bf67
+#define EIP93_SEED_3            0Xcb3482bf
+#define EIP93_LFSR_0            0xDEADC0DE
+#define EIP93_LFSR_1            0xBEEFF00D
+
+
+/*-----------------------------------------------------------------------------
+ * EIP93 device initialization specifics
+ */
+
+/*----------------------------------------------------------------------------
+ * Byte Order Reversal Mechanisms Supported in EIP93
+ * EIP93_BO_REVERSE_HALF_WORD : reverse the byte order within a half-word
+ * EIP93_BO_REVERSE_WORD :  reverse the byte order within a word
+ * EIP93_BO_REVERSE_DUAL_WORD : reverse the byte order within a dual-word
+ * EIP93_BO_REVERSE_QUAD_WORD : reverse the byte order within a quad-word
+ */
+typedef enum
+{
+    EIP93_BO_REVERSE_HALF_WORD = 1,
+    EIP93_BO_REVERSE_WORD = 2,
+    EIP93_BO_REVERSE_DUAL_WORD = 4,
+    EIP93_BO_REVERSE_QUAD_WORD = 8,
+} EIP93_Byte_Order_Value_t;
+
+/*----------------------------------------------------------------------------
+ * Byte Order Reversal Mechanisms Supported in EIP93 for Target Data
+ * EIP93_BO_REVERSE_HALF_WORD : reverse the byte order within a half-word
+ * EIP93_BO_REVERSE_WORD :  reverse the byte order within a word
+ */
+typedef enum
+{
+    EIP93_BO_REVERSE_HALF_WORD_TD = 1,
+    EIP93_BO_REVERSE_WORD_TD = 2,
+} EIP93_Byte_Order_Value_TD_t;
+
+
+// BYTE_ORDER_CFG register values
+#define EIP93_BYTE_ORDER_PD         EIP93_BO_REVERSE_WORD
+#define EIP93_BYTE_ORDER_SA         EIP93_BO_REVERSE_WORD
+#define EIP93_BYTE_ORDER_DATA       EIP93_BO_REVERSE_WORD
+#define EIP93_BYTE_ORDER_TD         EIP93_BO_REVERSE_WORD_TD
+
+// INT_CFG register values
+#define EIP93_INT_HOST_OUTPUT_TYPE  0
+#define EIP93_INT_PULSE_CLEAR       0
+
+
+#endif
+
+
diff --git a/drivers/net/cryptoDriver/include/mtk_internal.h b/drivers/net/cryptoDriver/include/mtk_internal.h
new file mode 100755
index 0000000..a11fe50
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_internal.h
@@ -0,0 +1,158 @@
+
+#ifndef EIP93_INTERNAL_H
+#define EIP93_INTERNAL_H
+
+#include "mtk_hwAccess.h"
+#include "mtk_hwDmaAccess.h"
+#include "mtk_eip93.h"
+#include "mtk_arm.h"
+#include "mtk_ring.h"
+#include "mtk_csEip93.h"
+
+#define VALID_INTERRUPT_MASK (  \
+                      (EIP93_INT_PE_CDRTHRESH_REQ ) | \
+                          (EIP93_INT_PE_RDRTHRESH_REQ ) | \
+                          (EIP93_INT_PE_OPERATION_DONE) | \
+                              (EIP93_INT_PE_INBUFTHRESH_REQ)| \
+                              (EIP93_INT_PE_OUTBURTHRSH_REQ)| \
+                              (EIP93_INT_PE_ERR_REG) \
+                     )
+
+typedef enum
+{
+    EIP93_MODE_RESET = 0,
+    EIP93_MODE_INITIALIZED,
+    EIP93_MODE_ARM,
+    EIP93_MODE_DHM
+} EIP93_Mode_t;
+
+
+
+// ARM fields
+typedef struct
+{
+    HWPAL_DMAResource_Handle_t CommandRingHandle;
+    HWPAL_DMAResource_Handle_t ResultRingHandle;
+    RingHelper_t RingHelper;
+    RingHelper_CallbackInterface_t RingHelperCallbacks;
+    EIP93_ARM_Settings_t Settings;
+} EIP93_ARM_Mode_t;
+
+// DHM fields
+typedef struct
+{
+    unsigned int OutBufferCyclicCounter;
+    unsigned int InBufferCyclicCounter;
+} EIP93_DHM_Mode_t;
+
+
+
+typedef struct
+{
+    // common fields:
+
+    HWPAL_Device_t Device;
+    EIP93_Mode_t CurrentMode;
+    // etc
+
+    union
+    {
+        // ARM fields
+        EIP93_ARM_Mode_t ARM_mode;
+
+        // DHM fields
+        EIP93_DHM_Mode_t DHM_mode;
+
+    } extras;
+
+} EIP93_Device_t;
+
+
+#ifdef EIP93_STRICT_ARGS
+
+#define EIP93_CHECK_DEVICE_IS_READY \
+    EIP93_CHECK_POINTER(Device_p); \
+    if (Device_p->CurrentMode != EIP93_MODE_INITIALIZED) \
+    { \
+        res = EIP93_ERROR_UNSUPPORTED_IN_THIS_STATE; \
+        goto FUNC_RETURN; \
+    }
+
+#define EIP93_CHECK_DEVICE_IS_RESET \
+    EIP93_CHECK_POINTER(Device_p); \
+    if (Device_p->CurrentMode != EIP93_MODE_RESET) \
+    { \
+        res = EIP93_ERROR_UNSUPPORTED_IN_THIS_STATE; \
+        goto FUNC_RETURN; \
+    }
+
+#define EIP93_CHECK_DEVICE_IS_NOT_RESET \
+    EIP93_CHECK_POINTER(Device_p); \
+    if (Device_p->CurrentMode == EIP93_MODE_RESET) \
+    { \
+        res = EIP93_ERROR_UNSUPPORTED_IN_THIS_STATE; \
+        goto FUNC_RETURN; \
+    }
+
+#define EIP93_CHECK_POINTER(_p) \
+    if (NULL == (_p)) \
+    { \
+        res = EIP93_ERROR_BAD_ARGUMENT; \
+        goto FUNC_RETURN; \
+    }
+
+#define EIP93_CHECK_HANDLE(_p) \
+    if (!HWPAL_DMAResource_IsValidHandle(_p)) \
+    { \
+        res = EIP93_ERROR_BAD_ARGUMENT; \
+        goto FUNC_RETURN; \
+    }
+#define EIP93_CHECK_INT_ATLEAST(_i,_min) \
+    if ((_i) < (_min)) \
+    { \
+        res =  EIP93_ERROR_BAD_ARGUMENT; \
+        goto FUNC_RETURN; \
+    }
+#define EIP93_CHECK_INT_INRANGE(_i, _min, _max) \
+    if ((_i) < (_min) || (_i) > (_max)) \
+        return EIP93_ERROR_BAD_ARGUMENT;
+#define EIP93_CHECK_VALID_INTERRUPT(_i) \
+    if ((_i) & (~VALID_INTERRUPT_MASK))  \
+        return EIP93_ERROR_BAD_ARGUMENT;
+
+
+#else
+
+#define EIP93_CHECK_ARM_IS_READY
+#define EIP93_CHECK_DEVICE_IS_READY
+#define EIP93_CHECK_DEVICE_IS_RESET
+#define EIP93_CHECK_DEVICE_IS_NOT_RESET
+#define EIP93_CHECK_POINTER(_p)                  IDENTIFIER_NOT_USED(_p)
+#define EIP93_CHECK_HANDLE(_p)                   IDENTIFIER_NOT_USED(_p)
+#define EIP93_CHECK_INT_ATLEAST(_i,_min)         IDENTIFIER_NOT_USED(_i)
+#define EIP93_CHECK_INT_INRANGE(_i, _min, _max)  IDENTIFIER_NOT_USED(_i)
+#define EIP93_CHECK_VALID_INTERRUPT(_i)          IDENTIFIER_NOT_USED(_i)
+
+#endif
+
+
+#define EIP93_INSERTCODE_FUNCTION_EXIT_CODE \
+    goto FUNC_RETURN; \
+    FUNC_RETURN: \
+        return res;
+
+
+/*-----------------------------------------------------------------------------
+ * PRNG Internal Required Defines
+ */
+#define EIP93_PRNG_MANUAL_OFF   0
+#define EIP93_PRNG_MANUAL_ON    1
+
+#define EIP93_PRNG_AUTO_ON      1
+
+#define EIP93_PRNG_RESULT64     0
+
+
+#endif
+
+
diff --git a/drivers/net/cryptoDriver/include/mtk_interrupts.h b/drivers/net/cryptoDriver/include/mtk_interrupts.h
new file mode 100755
index 0000000..e07e794
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_interrupts.h
@@ -0,0 +1,21 @@
+
+#ifndef EIP93_INTERRUPTS_H
+#define EIP93_INTERRUPTS_H
+
+// EIP93 interrupt signals
+// assigned values represent interrupt source bit numbers
+enum
+{
+    IRQ_CDR_THRESH_IRQ = 0,
+    IRQ_RDR_THRESH_IRQ = 1,
+    IRQ_OPERATION_DONE_IRQ = 9,
+    IRQ_INBUF_THRESH_IRQ = 10,
+    IRQ_OUTBUF_THRESH_IRQ = 11,
+    IRQ_PRNG_IRQ=12,
+    IQ_PE_ERR_IRQ = 13
+};
+
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_ipsec.h b/drivers/net/cryptoDriver/include/mtk_ipsec.h
new file mode 100755
index 0000000..f0ecfd0
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_ipsec.h
@@ -0,0 +1,92 @@
+
+#ifndef MTK_EIP93_IPSEC_H
+#define MTK_EIP93_IPSEC_H
+
+
+typedef union
+{
+	struct
+	{
+		unsigned int opCode			: 3;
+		unsigned int direction		: 1;
+		unsigned int opGroup		: 2;
+		unsigned int padType		: 2;
+		unsigned int cipher			: 4;
+		unsigned int hash			: 4;
+		unsigned int reserved2		: 1;
+		unsigned int scPad			: 1;
+		unsigned int extPad			: 1;
+		unsigned int hdrProc		: 1;
+		unsigned int digestLength	: 4;
+		unsigned int ivSource		: 2;
+		unsigned int hashSource		: 2;
+		unsigned int saveIv			: 1;
+		unsigned int saveHash		: 1;
+		unsigned int reserved1		: 2;
+	} bits;
+	unsigned int word;
+
+} saCmd0_t;
+
+typedef union
+{
+	struct
+	{
+		unsigned int copyDigest		: 1;
+		unsigned int copyHeader		: 1;
+		unsigned int copyPayload	: 1;
+		unsigned int copyPad		: 1;
+		unsigned int reserved4		: 4;
+		unsigned int cipherMode		: 2;
+		unsigned int reserved3		: 1;
+		unsigned int sslMac			: 1;
+		unsigned int hmac			: 1;
+		unsigned int byteOffset		: 1;
+		unsigned int reserved2		: 2;
+		unsigned int hashCryptOffset: 8;
+#if 1
+		unsigned int arc4KeyLen		: 5;
+		unsigned int seqNumCheck	: 1;
+		unsigned int reserved1		: 2;
+#else
+		unsigned int aesKeyLen		: 3;
+		unsigned int reserved1		: 1;
+		unsigned int aesDecKey		: 1;
+		unsigned int seqNumCheck	: 1;
+		unsigned int reserved0		: 2;
+#endif
+
+	} bits;
+	unsigned int word;
+
+} saCmd1_t;
+
+typedef struct saRecord_s
+{
+	saCmd0_t	 saCmd0;
+	saCmd1_t	 saCmd1;
+	unsigned int saKey[8];
+	unsigned int saIDigest[8];
+	unsigned int saODigest[8];
+	unsigned int saSpi;
+	unsigned int saSeqNum[2];
+	unsigned int saSeqNumMask[2];
+	unsigned int saNonce;
+
+} saRecord_t;
+
+typedef struct saState_s
+{
+	unsigned int stateIv[4];
+	unsigned int stateByteCnt[2];
+	unsigned int stateIDigest[8];
+
+} saState_t;
+
+
+
+
+
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/include/mtk_pecApi.h b/drivers/net/cryptoDriver/include/mtk_pecApi.h
new file mode 100755
index 0000000..92109e3
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_pecApi.h
@@ -0,0 +1,154 @@
+
+#ifndef EIP93_PEC_API_H
+#define EIP93_PEC_API_H
+
+#include "mtk_baseDefs.h"
+#include "mtk_dmaBuf.h"         // DMABuf_Handle_t
+
+/*----------------------------------------------------------------------------
+ *         Dependency on DMA Buffer Allocat API (mtk_dmaBuf.h)
+ *
+ * This API requires the use of the DMA Buffer Allocation API. All buffers
+ * are passed through this API as handles.
+ */
+
+
+/*----------------------------------------------------------------------------
+ * PEC_Status_t
+ */
+typedef enum
+{
+    PEC_STATUS_OK = 0,
+    PEC_ERROR_BAD_PARAMETER,
+    PEC_ERROR_BAD_HANDLE,
+    PEC_ERROR_BAD_USE_ORDER,
+    PEC_ERROR_INTERNAL,
+    PEC_ERROR_NOT_IMPLEMENTED
+
+} PEC_Status_t;
+
+
+/*----------------------------------------------------------------------------
+ * PEC_InitBlock_t
+ *
+ * This structure contains service initialization parameters that are passed
+ * to the PEC_Init call.
+ *
+ * For forward-compatibility with future extensions, please zero-init the
+ * data structure before setting the fields and providing it to PEC_Init.
+ * Example: PEC_InitBlock_t InitBlock = {0};
+ */
+typedef struct
+{
+    bool fUseDynamicSA;             // true = use variable-size SA format
+
+    // the following fields are related to Scatter/Gather
+    // not all engines support this
+    unsigned int FixedScatterFragSizeInBytes;
+
+} PEC_InitBlock_t;
+
+
+/*----------------------------------------------------------------------------
+ * PEC_CommandDescriptor_t
+ *
+ * This data structure describes a transform request that will be queued up
+ * for processing by the transform engine. It refers to the input and output
+ * data buffers, the SA buffer(s) and contains parameters that describe the
+ * transform, like the length of the data.
+ */
+typedef struct
+{
+    // the pointer that will be returned in the related result descriptor
+    void * User_p;
+
+    // data buffers
+    DMABuf_Handle_t SrcPkt_Handle;
+    DMABuf_Handle_t DstPkt_Handle;
+    unsigned int SrcPkt_ByteCount;
+    unsigned int Bypass_WordCount;
+
+    // SA reference
+    uint32_t SA_WordCount;
+    DMABuf_Handle_t SA_Handle1;
+    DMABuf_Handle_t SA_Handle2;
+
+    // Engine specific control fields
+    // with Transform specific values
+    uint32_t Control1;
+    uint32_t Control2;
+
+} PEC_CommandDescriptor_t;
+
+
+/*----------------------------------------------------------------------------
+ * PEC_ResultDescriptor_t
+ *
+ * This data structure contains the result of the transform request. The user
+ * can match the result to a command using the User_p field.
+ *
+ * A number of parameters from the command descriptor are also returned, as a
+ * courtesy service.
+ */
+typedef struct
+{
+    // the pointer that from the related command descriptor
+    void * User_p;
+
+    // data buffers
+    DMABuf_Handle_t SrcPkt_Handle;
+    DMABuf_Handle_t DstPkt_Handle;
+    uint32_t DstPkt_ByteCount;
+    void * DstPkt_p;
+
+    unsigned int Bypass_WordCount;
+
+    // Engine specific status fields
+    // with Transform specific values
+    uint32_t Status1;
+    uint32_t Status2;
+
+} PEC_ResultDescriptor_t;
+
+
+/*----------------------------------------------------------------------------
+ * PEC_NotifyFunction_t
+ *
+ * This type specifies the callback function prototype for the function
+ * PEC_CommandNotify_Request and PEC_ResultNotify_Request.
+ * The notification will occur only once.
+ *
+ * NOTE: The exact context in which the callback function is invoked and the
+ *       allowed actions in that callback are implementation specific. The
+ *       intention is that all API functions can be used, except PEC_UnInit.
+ */
+typedef void (* PEC_NotifyFunction_t)(void);
+
+
+
+/*----------------------------------------------------------------------------
+ * PEC_Init
+ *
+ * This function must be used to initialize the service. No API function may
+ * be used before this function has returned.
+ */
+PEC_Status_t
+PEC_Init(
+        const PEC_InitBlock_t * const InitBlock_p);
+
+
+/*----------------------------------------------------------------------------
+ * PEC_UnInit
+ *
+ * This call un-initializes the service. Use only when there are no pending
+ * transforms. The caller must make sure that no API function is used while or
+ * after this function executes.
+ */
+PEC_Status_t
+PEC_UnInit(void);
+
+
+
+#endif
+
+
diff --git a/drivers/net/cryptoDriver/include/mtk_prngL0.h b/drivers/net/cryptoDriver/include/mtk_prngL0.h
new file mode 100755
index 0000000..0f3ceec
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_prngL0.h
@@ -0,0 +1,71 @@
+
+#ifndef EIP93_PRNG_L0_H
+#define EIP93_PRNG_L0_H
+
+#include "mtk_baseDefs.h"             // BIT definitions, bool, uint32_t
+#include "mtk_hwAccess.h"              // Read32, Write32, HWPAL_Device_t
+#include "mtk_hwDmaAccess.h"          // Read32, Write32, HWPAL_DMAResource_t
+#include "mtk_hwInterface.h"   // the HW interface (register map)
+
+
+
+/*-----------------------------------------------------------------------------
+ * PRNG register routines
+ *
+ * These routines write/read register values in PRNG register
+ * in HW specific format.
+ *
+ * Note: if a function argument implies a flag ('f' is a prefix),
+ *       then only the values 0 or 1 are allowed for this argument.
+ */
+
+static inline void
+EIP93_Read32_PRNG_STATUS(
+        HWPAL_Device_t Device,
+        uint8_t * const fBusy,
+        uint8_t * const fResultReady)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PRNG_STAT);
+    if(fBusy)
+        *fBusy = (word) & 1;
+    if(fResultReady)
+        *fResultReady = (word >> 1) & 1;
+}
+
+/*-----------------------------------------------------------------------------
+ * PRNG_CTRL - Read/Write
+ */
+static inline void
+EIP93_Write32_PRNG_CTRL(
+        HWPAL_Device_t Device,
+        const uint8_t fEnableManual,
+        const uint8_t fAuto,
+        const uint8_t fResult128)
+{
+    EIP93_Write32(Device, EIP93_REG_PRNG_CTRL,
+            ((fEnableManual & 1) << 0) |
+            ((fAuto & 1) << 1) |
+            ((fResult128 & 1) << 2));
+}
+
+
+static inline void
+EIP93_Read32_PRNG_CTRL(
+        HWPAL_Device_t Device,
+        uint8_t * const fEnableManual,
+        uint8_t * const fAuto,
+        uint8_t * const fResult128)
+{
+    uint32_t word = EIP93_Read32(Device, EIP93_REG_PRNG_CTRL);
+    if(fEnableManual)
+        *fEnableManual = word & BIT_0;
+    if(fAuto)
+        *fAuto = (word >> 1) & 1;
+    if(fResult128)
+        *fResult128 = (word >> 2) & 1;
+}
+
+
+#endif
+
+
diff --git a/drivers/net/cryptoDriver/include/mtk_ring.h b/drivers/net/cryptoDriver/include/mtk_ring.h
new file mode 100755
index 0000000..38a064d
--- /dev/null
+++ b/drivers/net/cryptoDriver/include/mtk_ring.h
@@ -0,0 +1,375 @@
+
+#ifndef EIP93_RING_H
+#define EIP93_RING_H
+
+#include "mtk_baseDefs.h"
+
+/*----------------------------------------------------------------------------
+ * RingHelperCB_WriteFunc_t
+ *
+ * This routine must write a limited number of descriptors to the command ring
+ * and hand these off to the device for processing, using the mechanism
+ * supported by the device.
+ *
+ * If this is a command-only ring (not shared with resutls) AND the
+ * implementation of the callback interface is unable to provide the read
+ * position of the device in the command ring (see RingHelperCB_StatusFunc_t)
+ * then the Ring Helper module cannot know if the ring is almost full.
+ * Therefore, under these conditions, the implementation of this callback
+ * is also required to:
+ * - check that the descriptor position to be written is indeed free and does
+ *   not contain an unprocessed command descriptor (this happens when the ring
+ *   becomes full).
+ *
+ * This function can be called in response to invoking the RingHelper_Put API
+ * function and is expected to be fully re-entrant. If this is not possible,
+ * the caller must avoid the re-entrance of the RingHelper_Put API function.
+ *
+ * CallbackParam1_p
+ * CallbackParam2
+ *     These parameters are anonymous for the Ring Helper and were provided by
+ *     the caller during the ring initialization. They have meaning for the
+ *     the module that is invoked by this callback.
+ *
+ * WriteIndex
+ *     Zero-based index number in the command ring from where the descriptors
+ *     must be written. The caller guarantees that the descriptors can be
+ *     written sequentially and no index number wrapping will be required.
+ *     The implementation is expected to know the address of the command ring
+ *     and size of a descriptor.
+ *
+ * WriteCount
+ *     The number of descriptors to immediately add to the command ring.
+ *
+ * AvailableSpace
+ *     The currently available number of free positions in the command ring
+ *     to where the descriptors can be written.
+ *     The following always holds:
+ *
+ *     WriteCount <= AvailableSpace
+ *
+ *
+ * Descriptors_p
+ *     Pointer to the memory where the descriptors are currently stored.
+ *     The descriptors are available sequentially and back-to-back.
+ *
+ * DescriptorCount
+ *     The total number of descriptors that were requested to be added
+ *     to the command ring by the caller of the RingHelper_Put function.
+ *     When a write operation is split in two (due to index number wrapping),
+ *     this parameter is greater than WriteCount. Also if there is not enough
+ *     space available in the ring, this paramater is greater than WriteCount.
+ *     So the following holds:
+ *
+ *     DescriptorCount == WriteCount, if no index number wrapping occured
+ *                        in the caller's decision before calling this routine,
+ *                        and there is enough space in the ring;
+ *     DescriptorCount > WriteCount, if an index number wrapping occured
+ *                       in the caller's decision before calling this routine
+ *                       or there is not enough space in the ring;
+ *
+ * DescriptorSkipCount
+ *     The number of descriptors from Descriptors_p already copied. These
+ *     descriptors must be skipped. This parameter is required because the Ring
+ *     Helper does not know the size of a descriptor.
+ *     When an operation is split in two (due to index number wrapping),
+ *     the first call has this parameter set to zero,
+ *     and the second has it set to the number of descriptors written
+ *     by the first call.
+ *
+ * Return Value
+ *     <0  Failure code, this can be a Driver Library specific error code.
+ *      0  No descriptors could be written, but no explicit error
+ *     >0  Actual number of descriptors written
+ *
+ * It should be noted that returning a failure code will cause synchronization
+ * with the device to be lost and probably requires a reset of the device to
+ * recover.
+ */
+typedef int (* RingHelperCB_WriteFunc_t)(
+                    void * const CallbackParam1_p,
+                    const int CallbackParam2,
+                    const unsigned int WriteIndex,
+                    const unsigned int WriteCount,
+                    const unsigned int AvailableSpace,
+                    const void * Descriptors_p,
+                    const int DescriptorCount,
+                    const unsigned int DescriptorSkipCount);
+
+
+/*----------------------------------------------------------------------------
+ * RingHelperCB_ReadFunc_t
+ *
+ * This routine is expected to read a limited number of descriptors from the
+ * result ring and then mark these positions as free, allowing new result
+ * descriptors (separate rings) or command descriptors (shared ring) to be
+ * written to these position. The exact method used depends on the device
+ * implementation.
+ *
+ * This function can be called in response to invoking the RingHelper_Get API
+ * function and is expected to be fully re-entrant. If this is not possible,
+ * the caller must avoid the re-entrance of the RingHelper_Get API function.
+ *
+ * CallbackParam1_p
+ * CallbackParam2
+ *     These parameters are anonymous for the Ring Helper and were provided by
+ *     the caller during the ring initialization. They have meaning for the
+ *     the module that is invoked by this callback.
+ *
+ * ReadLimit
+ *     The maximum number of descriptors that fit in Descriptors_p.
+ *     Also the maximum number of descriptors that can be read sequentially
+ *     without having to wrap the ReadIndex.
+ *     Also the maximum number of descriptors that are ready, if this was
+ *     indicated by the ReadyCount parameter in the call to RingHelper_Get.
+ *
+ * ReadIndex
+ *     Zero-based position in the result ring where the first descriptor can be
+ *     read. The caller guarantees that up to ReadLimit descriptors can be read
+ *     sequentially from this position without having to wrap the ReadIndex.
+ *     The implementation is expected to know the address of the command ring
+ *     and size of a descriptor.
+ *
+ * Descriptors_p
+ *     Pointer to the block of memory where up to ReadLimit whole descriptors
+ *     can be written back-to-back by the implementation.
+ *
+ * DescriptorSkipCount
+ *     The number of descriptors already stored from Descriptors_p. This memory
+ *     must be skipped. This parameter is required because the Ring Helper does
+ *     not know the size of a descriptor.
+ *     When an operation is split in two, the first call has this parameter set
+ *     to zero, and the second has it set to the number of descriptors returned
+ *     by the first call.
+ *
+ * Return Value
+ *    <0  Failure code, this can be a Driver Library specific error code.
+ *     0  No ready descriptors were available in the result ring.
+ *    >0  Actual number of descriptors copied from the result ring to the
+ *        buffer pointed to by Descriptors_p.
+ *
+ * It should be noted that returning a failure code will cause synchronization
+ * with the device to be lost and probably requires a reset of the device to
+ * recover.
+ */
+typedef int (* RingHelperCB_ReadFunc_t)(
+                    void * const CallbackParam1_p,
+                    const int CallbackParam2,
+                    const unsigned int ReadIndex,
+                    const unsigned int ReadLimit,
+                    void * Descriptors_p,
+                    const unsigned int DescriptorSkipCount);
+
+
+/*----------------------------------------------------------------------------
+ * RingHelperCB_StatusFunc_t
+ *
+ * This routine reads and return the ring status from the device.
+ *
+ * This function can be called in response to invoking the RingHelper_Put API
+ * function and is expected to be fully re-entrant. If this is not possible,
+ * the caller must avoid the re-entrance of the RingHelper_Put API function.
+ *
+ * CallbackParam1_p
+ * CallbackParam2
+ *     These parameters are anonymous for the Ring Helper and were provided by
+ *     the caller during the ring initialization. They have meaning for the
+ *     the module that is invoked by this callback.
+ *
+ * DeviceReadPos_p
+ *     Pointer to the output parameter that will receive the most recent read
+ *     position used by the device. The value is the zero-based descriptor
+ *     index in the command ring. The caller will assume that the device has
+ *     not yet processed this descriptor.
+ *     The value -1 must be returned when the device cannot provide this info.
+ *     The implementation is expected to consistently return this value and
+ *     not to return -1 selectively. When the function has returned -1 once,
+ *     it is assumed not to support this functionality and will not be called
+ *     anew thereafter.
+ *
+ * Return Value
+ *    <0  Failure code, this can be a Driver Library specific error code.
+ *     0  Success  (also to be used when *DeviceReadPos_p was set to -1)
+ *
+ * It should be noted that returning a failure code will cause synchronization
+ * with the device to be lost and probably requires a reset of the device to
+ * recover.
+ */
+typedef int (* RingHelperCB_StatusFunc_t)(
+                    void * const CallbackParam1_p,
+                    const int CallbackParam2,
+                    int * const DeviceReadPos_p);
+
+
+/*----------------------------------------------------------------------------
+ * RingHelper_CallbackInterface_t
+ *
+ * Data structure containing pointers to callback functions that will be used
+ * by the Ring Helper Library to manipulate descriptors in the ring.
+ */
+typedef struct
+{
+    // pointers to the functions that form the Callback Interface
+    // see type definitions above for details
+
+    // note: all three API functions are mandatory to provide
+    RingHelperCB_WriteFunc_t  WriteFunc_p;
+    RingHelperCB_ReadFunc_t   ReadFunc_p;
+    RingHelperCB_StatusFunc_t StatusFunc_p;
+
+    // the following two parameters will be used as parameters when invoking
+    // the above callback functions. The example usage is shown below.
+    void * CallbackParam1_p;        // typically I/O Area pointer
+    int CallbackParam2;             // typically Ring Number
+
+} RingHelper_CallbackInterface_t;
+
+
+/*----------------------------------------------------------------------------
+ * RingHelper_t
+ *
+ * Data structure used to hold the ring administration data. The caller must
+ * maintain an instance of this data structure for each ring.
+ *
+ * The caller should not access this data structure directly.
+ *
+ * For currency analysis, the following details have been specified:
+ * - RingHelper_Init writes all fields.
+ * - RingHelper_Put and RingHelper_Get do NOT write shared fields and can
+ *   therefore be used concurrently.
+ * - RingHelper_Get and RingHelper_Notify are multiple exlusive use by design.
+ */
+typedef struct
+{
+    unsigned int IN_Size;
+    unsigned int IN_Tail;               // written by Put
+
+    unsigned int OUT_Size;
+    unsigned int OUT_Head;              // written by Get
+
+    bool fSeparate;
+    bool fSupportsDeviceReadPos;        // written by Put
+
+    // callback interface
+    RingHelper_CallbackInterface_t CB;
+
+} RingHelper_t;
+
+
+/*----------------------------------------------------------------------------
+ * RingHelper_Init
+ *
+ * This routine must be called once to initialize a ring.
+ *
+ * The Ring Helper module will start to use the ring(s) from index zero. The
+ * caller must make sure the device is configured accordingly.
+ *
+ * Ring_p
+ *     Pointer to the ring administration data.
+ *
+ * CallbackIF_p
+ *     References to the callback functions and parameters that will be used
+ *     by the Ring Helper to request manipulation of the descriptors.
+ *     The entire structure pointed to by this parameters will be copied.
+ *
+ * fSeparateRings
+ *     This parameter indicates whether the command and result rings share one
+ *     ring (one block of memory) or use separate rings (two memory blocks).
+ *
+ * MaxDescriptors_CommandRing
+ * MaxDescriptors_ResultRing
+ *     The maximum number of descriptors that fit in each of the rings.
+ *     The MaxDescriptors_ResultRing is ignored when fSeparateRings is false.
+ *
+ * Return value
+ *    <0  Failure code
+ *     0  Success
+ *
+ * None of the other API functions may be called for this Ring_p before this
+ * function returns with a success return value.
+ */
+int
+RingHelper_Init(
+        RingHelper_t * const Ring_p,
+        const RingHelper_CallbackInterface_t * const CallbackIF_p,
+        const bool fSeparateRings,
+        const unsigned int MaxDescriptors_CommandRing,
+        const unsigned int MaxDescriptors_ResultRing);
+
+
+/*----------------------------------------------------------------------------
+ * RingHelper_Put
+ *
+ * This routine can be used to add one or more descriptors to a specific
+ * command ring.
+ *
+ * Ring_p
+ *     Pointer to the ring administration data.
+ *
+ * Descriptors_p
+ *     Pointer to where to read the array of descriptors.
+ *
+ * DescriptorCount
+ *     Number of descriptors stored back-to-back in the array pointed to by
+ *     Descriptors_p.
+ *
+ * Return Value
+ *     <0  Failure code, this can be a Driver Library specific error code
+ *         returned from the RingHelperCB_WriteFunc_t callback function.
+ *     >0  Number of descriptors actually added to the command ring.
+ *      0  The command ring is full, no descriptors could be added
+ *         The caller should retry when the device has indicated that some
+ *         descriptors have been processed.
+ *
+ * This function is not re-entrant for the same Ring_p. It is allowed to call
+ * RingHelper_Get concurrently, even for the same Ring_p.
+ */
+int
+RingHelper_Put(
+        RingHelper_t * const Ring_p,
+        const void * Descriptors_p,
+        const int DescriptorCount);
+
+/*----------------------------------------------------------------------------
+ * RingHelper_Get
+ *
+ * This routine can be used to read one or more descriptors from a specific
+ * result ring.
+ *
+ * Ring_p
+ *     Pointer to the ring administration data.
+ *
+ * ReadyCount
+ *     The number of descriptors the caller guarantees are available in the
+ *     result ring. This information is available from some devices.
+ *     Use -1 if this information is not availalble. In this case the
+ *     implementation of the read function (part of the callback interface)
+ *     must check this information when retrieving the descriptors.
+ *
+ * Descriptors_p
+ *     Pointer to the buffer where the descriptors will be written.
+ *
+ * DescriptorsLimit
+ *     The size of the buffer pointed to by Descriptors_p, expressed in the
+ *     maximum number of whole descriptors that fit into the buffer.
+ *     Or, if smaller than the buffer size, the maximum number of whole
+ *     descriptors that will be retrieved during this call.
+ *
+ * Return Value
+ *     <0 Failure code, this can be a Driver Library specific error code
+ *         returned from the RingHelperCB_ReadFunc_t callback function.
+ *      0 No descriptors ready to be retrieved, retry later
+ *     >0 Number of descriptors actually written from Descriptors_p
+ *
+ * This function is not re-entrant for the same Ring_p. It is allowed to call
+ * RingHelper_Put concurrently, even for the same Ring_p.
+ */
+int
+RingHelper_Get(
+        RingHelper_t * const Ring_p,
+        const int ReadyCount,
+        void * Descriptors_p,
+        const int DescriptorsLimit);
+
+#endif
+
diff --git a/drivers/net/cryptoDriver/source/mtk_eip93Init.c b/drivers/net/cryptoDriver/source/mtk_eip93Init.c
new file mode 100755
index 0000000..d6e8d59
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/mtk_eip93Init.c
@@ -0,0 +1,549 @@
+
+#include "mtk_cAdapter.h"
+#include "mtk_AdapterInternal.h"
+#include "mtk_interrupts.h"
+#include "mtk_arm.h"
+
+#include "mtk_addrTrans.h"      // AddrTrans_*
+#include <asm/io.h>                 // for virt_to_bus
+
+#define   K1_TO_PHYSICAL(x) (((u32)(x)) & 0x1fffffff)
+
+EIP93_IOArea_t Adapter_EIP93_IOArea;
+
+#ifdef MTK_CRYPTO_DRIVER
+unsigned int *pCmdRingBase, *pResRingBase;
+#endif
+
+static DMABuf_Handle_t Adapter_EIP93_CmdRing_Handle;
+#ifdef ADAPTER_EIP93_SEPARATE_RINGS
+static DMABuf_Handle_t Adapter_EIP93_ResRing_Handle;
+#endif
+
+static const DMABuf_Properties_t Adapter_EIP93_RingProps =
+{
+    ADAPTER_EIP93_RINGSIZE_BYTES, //defined in cs_adaptor.h
+    4,          // Alignment
+    0,          // Bank
+    false       // fCached
+};
+
+typedef enum
+{
+    ADAPTER_EIP93_MODE_DISABLED,
+    ADAPTER_EIP93_MODE_IDLE,
+    ADAPTER_EIP93_MODE_ARM,
+    ADAPTER_EIP93_MODE_DHM
+} Adapter_EIP93_Mode_t;
+
+static Adapter_EIP93_Mode_t Adapter_EIP93_Mode;
+unsigned int Adapter_EIP93_MaxDescriptorsInRing;
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_EIP93_SetMode_Idle
+ *
+ * Return Value
+ *     true  Success
+ *     false Failed
+ */
+bool
+Adapter_EIP93_SetMode_Idle(void)
+{
+
+   EIP93_Status_t res93 ;
+
+    switch (Adapter_EIP93_Mode)
+    {
+        case ADAPTER_EIP93_MODE_DISABLED:
+            // cannot use EIP93
+            return false;
+
+        case ADAPTER_EIP93_MODE_IDLE:
+            // already idle
+            return true;
+
+        case ADAPTER_EIP93_MODE_DHM:
+            res93 = EIP93_Deactivate(&Adapter_EIP93_IOArea);
+            if (res93 != EIP93_STATUS_OK)
+            {
+                printk(
+                    "Adapter_EIP93_SetMode_Idle: "
+                    "EIP93_Deactivate returned %d\n",
+                    res93);
+            }
+
+
+            printk("Adapter: Successfully deactivated EIP93 \n");
+            Adapter_EIP93_Mode = ADAPTER_EIP93_MODE_IDLE;
+            printk("Adapter: Successfully deactivated EIP93 \n");
+            return true;
+
+        case ADAPTER_EIP93_MODE_ARM:
+
+            res93 = EIP93_Deactivate(&Adapter_EIP93_IOArea);
+            if (res93 != EIP93_STATUS_OK)
+            {
+                printk(
+                    "Adapter_EIP93_SetMode_Idle: "
+                    "EIP93_Deactivate returned %d\n",
+                     res93);
+            }
+            // free the ring memory blocks
+            DMABuf_Release(Adapter_EIP93_CmdRing_Handle);
+#ifdef ADAPTER_EIP93_SEPARATE_RINGS
+            DMABuf_Release(Adapter_EIP93_ResRing_Handle);
+#endif
+
+            Adapter_EIP93_Mode = ADAPTER_EIP93_MODE_IDLE;
+            printk("Adapter: Successfully deactivated EIP93v2\n");
+            return true;
+
+
+        default:
+            break;
+    } // switch
+
+    printk("Adapter_EIP93_SetMode_Idle: Unexpected mode %d\n",
+            Adapter_EIP93_Mode);
+
+    return false;
+}
+
+/*----------------------------------------------------------------------------
+ * Adapter_EIP93_SetMode_ARM
+ *
+ * Return Value
+ *     true  Success
+ *     false Failed
+ */
+bool
+Adapter_EIP93_SetMode_ARM(
+        const bool fEnableDynamicSA)
+{
+#ifndef ADAPTER_EIP93_PE_MODE_ARM
+    IDENTIFIER_NOT_USED(fEnableDynamicSA);
+    return false;
+#else
+    EIP93_ARM_Settings_t Settings = {0};
+    EIP93_ARM_RingMemory_t RingMemory = {0};
+    EIP93_Status_t res93;
+
+    if (Adapter_EIP93_Mode != ADAPTER_EIP93_MODE_IDLE)
+    {
+        printk("Adapter_EIP93_SetMode_ARM: Not possible in mode %d\n",
+            Adapter_EIP93_Mode);
+        return false;
+    }
+
+/**** allocate memory for the ring ****/
+
+    ZEROINIT(RingMemory);
+    // bytes to words conversion from ADAPTER_EIP93_RINGSIZE_BYTES
+    RingMemory.RingSizeInWords = Adapter_EIP93_RingProps.Size >> 2;
+
+    {
+        DMABuf_Status_t dmares;
+        DMABuf_HostAddress_t HostAddr;
+
+        dmares = DMABuf_Alloc(
+                        Adapter_EIP93_RingProps,
+                        &HostAddr,
+                        &Adapter_EIP93_CmdRing_Handle);
+
+ 	#ifdef MTK_CRYPTO_DRIVER
+		pCmdRingBase = (unsigned int*)HostAddr.p; //store command descriptor ring base address (uncached memory address)
+	#endif
+
+        if (dmares != DMABUF_STATUS_OK)
+        {
+            printk(
+                "Adapter_EIP93_Init: "
+                "DMABuf_Alloc (Command Ring) returned %d\n",
+                dmares);
+
+            return false;
+        }
+
+        printk(
+            "Adapter_EIP93_Init: "
+            "CmdRing_Handle=%p\n",
+            Adapter_EIP93_CmdRing_Handle.p);
+
+        Adapter_GetEIP93PhysAddr(
+                Adapter_EIP93_CmdRing_Handle,
+                &RingMemory.CommandRingHandle,
+                &RingMemory.CommandRingAddr);
+
+        if (RingMemory.CommandRingAddr.Addr == 0)
+        {
+            printk(
+                "Adapter_EIP93_Init: "
+                "Failed to get command ring physical address\n");
+
+            // free the command ring memory
+            DMABuf_Release(Adapter_EIP93_CmdRing_Handle);
+
+            return false;       // ## RETURN ##
+        }
+    }
+
+#ifndef ADAPTER_EIP93_SEPARATE_RINGS
+    // not separate rings
+    RingMemory.fSeparateRings = false;
+#else
+    // separat rings
+    RingMemory.fSeparateRings = true;
+
+    {
+        DMABuf_Status_t dmares;
+        DMABuf_HostAddress_t HostAddr;
+
+        dmares = DMABuf_Alloc(
+                        Adapter_EIP93_RingProps,
+                        &HostAddr,
+                        &Adapter_EIP93_ResRing_Handle);
+
+ 	#ifdef MTK_CRYPTO_DRIVER
+		pResRingBase = (unsigned int*)HostAddr.p; //store result descriptor ring base address (uncached memory address)
+ 	#endif
+
+        if (dmares != DMABUF_STATUS_OK)
+        {
+            printk(
+                    "Adapter_EIP93_Init: "
+                    "DMABuf_Alloc (Result Ring) returned %d\n",
+                    dmares);
+
+            // free the command ring memory
+            DMABuf_Release(Adapter_EIP93_CmdRing_Handle);
+
+            return false;
+        }
+
+        printk(
+            "Adapter_EIP93_Init: "
+            "ResRing_Handle=%p\n",
+            Adapter_EIP93_ResRing_Handle.p);
+
+        Adapter_GetEIP93PhysAddr(
+                Adapter_EIP93_ResRing_Handle,
+                &RingMemory.ResultRingHandle,
+                &RingMemory.ResultRingAddr);
+
+        if (RingMemory.ResultRingAddr.Addr == 0)
+        {
+            printk(
+                "Adapter_EIP93_Init: "
+                "Failed to get result ring physical address\n");
+
+            // free the ring memories
+            DMABuf_Release(Adapter_EIP93_CmdRing_Handle);
+            DMABuf_Release(Adapter_EIP93_ResRing_Handle);
+
+            return false;
+        }
+    }
+#endif /* ADAPTER_EIP93_SEPARATE_RINGS */
+
+    // create the engine settings block
+    Settings.nPEInputThreshold = ADAPTER_EIP93_DMATHRESHOLD_INPUT;
+    Settings.nPEOutputThreshold = ADAPTER_EIP93_DMATHRESHOLD_OUTPUT;
+    Settings.nDescriptorDoneCount = ADAPTER_EIP93_DESCRIPTORDONECOUNT;
+    Settings.nDescriptorDoneTimeout = ADAPTER_EIP93_DESCRIPTORDONETIMEOUT;
+    Settings.nDescriptorPendingCount= ADAPTER_EIP93_DESCRIPTORPENDINGCOUNT;
+    Settings.nDescriptorSize = 8 ;
+//    Settings.nRingPollDivisor = ADAPTER_EIP93_RINGPOLLDIVISOR;
+
+    Adapter_EIP93_MaxDescriptorsInRing =
+            RingMemory.RingSizeInWords /
+            EIP93_ARM_DESCRIPTOR_SIZE();
+
+    res93 = EIP93_ARM_Activate(
+                &Adapter_EIP93_IOArea,
+                &Settings,
+                &RingMemory);
+
+    if (res93 != EIP93_STATUS_OK)
+    {
+        printk(
+            "Adapter_EIP93_Init: "
+            "EIP93_ARM_Activate returned %d\n",
+            res93);
+
+        // free the ring memory blocks
+        DMABuf_Release(Adapter_EIP93_CmdRing_Handle);
+#ifdef ADAPTER_EIP93_SEPARATE_RINGS
+        DMABuf_Release(Adapter_EIP93_ResRing_Handle);
+#endif
+        return false;
+    }
+
+    Adapter_EIP93_Mode = ADAPTER_EIP93_MODE_ARM;
+
+    printk("Adapter: Successfully initialized EIP93v2 in ARM mode\n");
+
+    return true;
+#endif /* ADAPTER_EIP93_PE_MODE_ARM */
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_EIP93_Init
+ */
+bool
+Adapter_EIP93_Init(void)
+{
+    HWPAL_Device_t Device; //void*
+    EIP93_Status_t res93;
+
+    Adapter_EIP93_Mode = ADAPTER_EIP93_MODE_DISABLED;
+
+    if (!HWPAL_Device_Find("eip93", &Device))
+    {
+        printk("Adapter_EIP93_Init: Failed to find EIP93 device\n");
+        return false;
+    }
+
+    res93 = EIP93_Initialize(
+                &Adapter_EIP93_IOArea,
+                Device);
+
+    if (res93 != EIP93_STATUS_OK)
+    {
+        printk(
+            "Adapter_EIP93_Init: "
+            "EIP93_Initialize returned %d\n",
+            res93);
+        return false;
+    }
+
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+    // Configure level of Interrupts
+    res93 = EIP93_INT_Configure(
+                &Adapter_EIP93_IOArea,
+                false,
+                false);
+
+    if (res93 != EIP93_STATUS_OK)
+    {
+        printk(
+            "Adapter_EIP93_Init: "
+            "EIP93_INT_Configure returned %d\n",
+            res93);
+
+        return false;
+    }
+
+#endif // ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+
+
+
+    Adapter_EIP93_Mode = ADAPTER_EIP93_MODE_IDLE;
+
+    return true;
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_EIP93_UnInit
+ */
+void
+Adapter_EIP93_UnInit(void)
+{
+    EIP93_Status_t res93;
+
+    res93 = EIP93_Shutdown(&Adapter_EIP93_IOArea);
+
+    if (res93 != EIP93_STATUS_OK)
+    {
+        printk(
+            "Adapter_EIP93_UnInit: "
+            "EIP93_Shutdown returned %d\n",
+            res93);
+    }
+
+    if (Adapter_EIP93_Mode == ADAPTER_EIP93_MODE_ARM)
+    {
+        // free the ring memory blocks
+        DMABuf_Release(Adapter_EIP93_CmdRing_Handle);
+#ifdef ADAPTER_EIP93_SEPARATE_RINGS
+        DMABuf_Release(Adapter_EIP93_ResRing_Handle);
+#endif
+    }
+
+    Adapter_EIP93_Mode = ADAPTER_EIP93_MODE_DISABLED;
+}
+
+
+/*----------------------------------------------------------------------------
+ * AddrTrans_Translate
+ */
+AddrTrans_Status_t
+AddrTrans_Translate(
+        const AddrTrans_Pair_t PairIn,
+        const unsigned int AlternativeRef,
+        AddrTrans_Domain_t DestDomain,
+        AddrTrans_Pair_t * const PairOut_p)
+{
+    // we only support 1:1 translation from driver to device domain
+    if (PairOut_p == NULL)
+        return ADDRTRANS_ERROR_BAD_ARGUMENT;
+
+    if (DestDomain != ADDRTRANS_DOMAIN_DEVICE_PE)
+        return ADDRTRANS_ERROR_CANNOT_TRANSLATE;
+
+    PairOut_p->Domain = DestDomain;
+
+    if (PairIn.Domain == ADDRTRANS_DOMAIN_ALTERNATIVE &&
+        AlternativeRef == ADAPTER_DMABUF_ALLOCATORREF_KMALLOC)
+    {
+#ifdef RT_EIP93_DRIVER
+        PairOut_p->Address_p = (void *)K1_TO_PHYSICAL(PairIn.Address_p);
+#else
+        // linux kmalloc allocated address
+        // we can use virt_to_bus on this one
+        PairOut_p->Address_p = (void *)virt_to_bus(PairIn.Address_p);
+#endif
+        return ADDRTRANS_STATUS_OK;
+    }
+
+    PairOut_p->Domain = ADDRTRANS_DOMAIN_UNKNOWN;
+    PairOut_p->Address_p = 0;
+
+    return ADDRTRANS_ERROR_CANNOT_TRANSLATE;
+}
+
+/*----------------------------------------------------------------------------
+ * Adapter_GetEIP93PhysAddr
+ *
+ * This routine checks if we have already translated the address for EIP93
+ * DMA. If not, we translate it now and cache it in the DMAResource Record.
+ * We then return the address.
+ *
+ * Handle
+ *     Must be a valid handle.
+ *
+ * Return Value
+ *     Physical address for the start of the buffer referred to by Handle,
+ *     or zero if address translation was not possible.
+ */
+void
+Adapter_GetEIP93PhysAddr(
+        DMABuf_Handle_t Handle,
+        HWPAL_DMAResource_Handle_t * const DMAHandle_p,
+        EIP93_DeviceAddress_t * const EIP93PhysAddr_p)
+{
+    HWPAL_DMAResource_Handle_t DMAHandle;
+    HWPAL_DMAResource_Record_t * Rec_p = NULL;
+
+    if (EIP93PhysAddr_p == NULL)
+    {
+        printk("Adapter_GetEIP93PhysAddr: PANIC\n");
+        return;
+    }
+
+    // initialize the output parameters
+    if (DMAHandle_p)
+        *DMAHandle_p = NULL;
+
+    EIP93PhysAddr_p->Addr = 0;
+    EIP93PhysAddr_p->UpperAddr = 0;
+
+    if (!Adapter_DMABuf_IsValidHandle(Handle))
+        return;
+
+    {
+        // translate the handle
+        DMAHandle = Adapter_DMABuf_Handle2DMAResourceHandle(Handle);
+
+        // get the record belonging to this handle
+        Rec_p = HWPAL_DMAResource_Handle2RecordPtr(DMAHandle);
+    }
+
+    if (Rec_p == NULL)
+        return;
+
+    if (DMAHandle_p)
+        *DMAHandle_p = DMAHandle;
+
+    if (Rec_p->device.DeviceAddr32 > 1)
+        goto PHYS_DONE;
+
+    if (0 == Rec_p->device.DeviceAddr32)
+    {
+        // first time, so translate
+        AddrTrans_Pair_t PairIn;
+        AddrTrans_Pair_t PairOut;
+        AddrTrans_Status_t res;
+
+        // assume address translation will fail
+        Rec_p->device.DeviceAddr32 = 1;
+                 // value used inside this function only
+
+        if (Rec_p->alloc.AllocatorRef == ADAPTER_DMABUF_ALLOCATORREF_KMALLOC)
+        {
+            // kmalloc-allocated buffer
+
+            // address translator needs to know this through alternative-ref
+            PairIn.Address_p = Rec_p->host.HostAddr_p;
+            PairIn.Domain = ADDRTRANS_DOMAIN_ALTERNATIVE;
+
+            res = AddrTrans_Translate(
+                            PairIn,
+                            ADAPTER_DMABUF_ALLOCATORREF_KMALLOC,
+                            ADDRTRANS_DOMAIN_DEVICE_PE,
+                            &PairOut);
+
+            if (res == ADDRTRANS_STATUS_OK)
+            {
+                // support for 32bit addresses only
+
+                // unsigned long will be 64bit only on 64bit systems
+                unsigned long Addr64or32 = (unsigned long)PairOut.Address_p;
+                unsigned long HighAddr = Addr64or32;
+                HighAddr >>= 16;  // shift in two steps avoids
+                HighAddr >>= 16;  // side-effect with failing 32bit shift
+                if (HighAddr)
+                {
+                    printk(
+                        "Adapter_EIP93: "
+                        "Physical Address too > 4GB not supported!"
+                        " (handle=%p)\n",
+                        Handle.p);
+                    return;     // ## RETURN ##
+                }
+
+                Rec_p->device.DeviceAddr32 = (uint32_t)Addr64or32;
+
+#ifdef ADAPTER_EIP93_ARMRING_ENABLE_SWAP
+                Rec_p->device.fSwapEndianess = true;
+#endif
+
+                goto PHYS_DONE;
+            }
+            else
+            {
+                printk(
+                "Adapter_GetEIP93PhysAddr: AddrTrans_Translate returned %d\n",
+                res);
+            }
+        }
+
+        if (1 == Rec_p->device.DeviceAddr32)
+        {
+            printk(
+            "Adapter_GetEIP93PhysAddr: Address translation not possible\n");
+        }
+    }
+
+    if (1 == Rec_p->device.DeviceAddr32)
+    {
+        // address translation tried before and failed
+        return;
+    }
+
+PHYS_DONE:
+    EIP93PhysAddr_p->Addr = Rec_p->device.DeviceAddr32;
+}
+
diff --git a/drivers/net/cryptoDriver/source/mtk_init.c b/drivers/net/cryptoDriver/source/mtk_init.c
new file mode 100755
index 0000000..3d23427
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/mtk_init.c
@@ -0,0 +1,156 @@
+
+#include "mtk_baseDefs.h"
+#include "mtk_hwAccess.h"
+#include "mtk_AdapterInternal.h"
+#include "mtk_hwDmaAccess.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <asm/mach-ralink/surfboardint.h>
+#include "mtk_pecApi.h"
+#include <net/mtk_esp.h>
+#include <linux/proc_fs.h>
+
+static struct proc_dir_entry *entry;
+
+extern void
+mtk_ipsec_init(
+	void
+);
+
+static bool Adapter_IsInitialized = false;
+
+
+static bool
+Adapter_Init(
+	void
+)
+{
+    if (Adapter_IsInitialized != false)
+    {
+        printk("Adapter_Init: Already initialized\n");
+        return true;
+    }
+
+
+    if (!HWPAL_DMAResource_Init(1024))
+    {
+		printk("HWPAL_DMAResource_Init failed\n");
+       return false;
+    }
+
+    if (!Adapter_EIP93_Init())
+    {
+        printk("Adapter_EIP93_Init failed\n");
+		return false;
+    }
+
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+    Adapter_Interrupts_Init(SURFBOARDINT_CRYPTO);
+#endif
+
+    Adapter_IsInitialized = true;
+
+    return true;
+}
+
+
+static void
+Adapter_UnInit(
+	void
+)
+{
+    if (!Adapter_IsInitialized)
+    {
+        printk("Adapter_UnInit: Adapter is not initialized\n");
+        return;
+    }
+
+    Adapter_IsInitialized = false;
+
+
+
+    Adapter_EIP93_UnInit();
+
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+    Adapter_Interrupts_UnInit();
+#endif
+
+    HWPAL_DMAResource_UnInit();
+}
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
+static int mcrypto_proc_read(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+    int len, i;
+    if (off > 0)
+    {
+        return 0;
+    }
+
+    len = sprintf(buf, "expand : %d\n", mcrypto_proc.copy_expand_count);
+    len += sprintf(buf + len, "nolinear packet : %d\n", mcrypto_proc.nolinear_count);
+    len += sprintf(buf + len, "oom putpacket : %d\n", mcrypto_proc.oom_in_put);
+    for (i = 0; i < 4; i++)
+    	len += sprintf(buf + len, "skbq[%d] : %d\n", i, mcrypto_proc.qlen[i]);
+    for (i = 0; i < 10; i++)
+    	len += sprintf(buf + len, "dbgpt[%d] : %d\n", i, mcrypto_proc.dbg_pt[i]);
+    return len;
+}
+#endif
+
+int
+VDriver_Init(
+	void
+)
+{
+
+    if (!Adapter_Init())
+    {
+		printk("\n !Adapter_Init failed! \n");
+        return -1;
+    }
+
+	if (PEC_Init(NULL) == PEC_ERROR_BAD_USE_ORDER)
+	{
+		printk("\n !PEC is initialized already! \n");
+		return -1;
+	}
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
+	entry = create_proc_entry(PROCNAME, 0666, NULL);
+	if (entry == NULL)
+	{
+		printk("HW Crypto : unable to create /proc entry\n");
+		return -1;
+	}
+	entry->read_proc = mcrypto_proc_read;
+	entry->write_proc = NULL;
+#endif
+	memset(&mcrypto_proc, 0, sizeof(mcrypto_proc_type));
+
+	mtk_ipsec_init();
+
+    return 0;   // success
+}
+
+
+
+void
+VDriver_Exit(
+	void
+)
+{
+    Adapter_UnInit();
+
+	PEC_UnInit();
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
+	remove_proc_entry(PROCNAME, entry);
+#endif
+}
+
+MODULE_LICENSE("Proprietary");
+
+module_init(VDriver_Init);
+module_exit(VDriver_Exit);
diff --git a/drivers/net/cryptoDriver/source/mtk_interruptHelper.c b/drivers/net/cryptoDriver/source/mtk_interruptHelper.c
new file mode 100755
index 0000000..9cfe423
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/mtk_interruptHelper.c
@@ -0,0 +1,438 @@
+#include <asm/uaccess.h>
+#include <asm/addrspace.h>
+#include <asm/mach-ralink/surfboard.h>
+#include <asm/mach-ralink/surfboardint.h>
+#include <asm/mach-ralink/rt_mmap.h>
+
+#include "mtk_AdapterInternal.h"
+#include "mtk_baseDefs.h"
+#include "mtk_hwAccess.h"
+
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/spinlock.h>        // spinlock_*
+#include "mtk_interrupts.h"
+#include "mtk_eip93.h"
+
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+
+
+
+#define ADAPTER_MAX_INTERRUPTS 32
+
+
+static int Adapter_Interrupts_IRQ = -1;
+static Adapter_InterruptHandler_t
+        Adapter_Interrupts_HandlerFunctions[ADAPTER_MAX_INTERRUPTS];
+static spinlock_t Adapter_Interrupts_ConcurrencyLock;
+
+#define INTERRUPT_PIN 1
+
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_TEST_RAW_STATUS
+static bool RawInterruptTestStatus = true ;
+#endif
+
+#define VPint *(volatile unsigned int *)
+
+//#define ADAPTER_EIP93PE_INTERRUPTS_TEST_RAW_STATUS
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupts_GetActiveIntNr
+ *
+ * Returns 0..31 depending on the lowest '1' bit.
+ * Returns 32 when all bits are zero
+ *
+ * Using binary break-down algorithm.
+ */
+static inline int
+Adapter_Interrupts_GetActiveIntNr(
+        uint32_t Sources)
+{
+    unsigned int IntNr = 0;
+    unsigned int R16, R8, R4, R2;
+
+    if (Sources == 0)
+        return 32;
+
+    // if the lower 16 bits are empty, look at the upper 16 bits
+    R16 = Sources & 0xFFFF;
+    if (R16 == 0)
+    {
+        IntNr += 16;
+        R16 = Sources >> 16;
+    }
+
+    // if the lower 8 bits are empty, look at the high 8 bits
+    R8 = R16 & 0xFF;
+    if (R8 == 0)
+    {
+        IntNr += 8;
+        R8 = R16 >> 8;
+    }
+
+    R4 = R8 & 0xF;
+    if (R4 == 0)
+    {
+        IntNr += 4;
+        R4 = R8 >> 4;
+    }
+
+    R2 = R4 & 3;
+    if (R2 == 0)
+    {
+        IntNr += 2;
+        R2 = R4 >> 2;
+    }
+
+    // last two bits are trivial
+    // 00 => cannot happen
+    // 01 => +0
+    // 10 => +1
+    // 11 => +0
+    if (R2 == 2)
+        IntNr++;
+
+    return IntNr;
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupts_TopHalfHandler
+ */
+static irqreturn_t
+Adapter_Interrupts_Top_Half_Handler (
+        int irq,
+        void * dev_id
+)
+{
+    EIP93_INT_SourceBitmap_t Sources;
+
+    if (irq != Adapter_Interrupts_IRQ)
+        return IRQ_NONE;
+
+    if (Adapter_Interrupts_IRQ == -1)
+    {
+        printk(
+         "\nAdapter_Interrupts_Top_Half_Handler: Interrupts not initialized\n");
+        return IRQ_NONE ;
+    }
+
+    //get EIP93_REG_INT_MASK_STAT register
+    EIP93_INT_IsActive(&Adapter_EIP93_IOArea,
+                &Sources);
+
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_TEST_RAW_STATUS
+    {
+        EIP93_INT_SourceBitmap_t Sources_Raw= 0 ;
+        EIP93_Status_t res ;
+
+
+        res = EIP93_INT_IsRawActive(
+                   &Adapter_EIP93_IOArea,
+                &Sources_Raw );
+
+        if( RawInterruptTestStatus != false)
+        {
+            if( ( (Sources_Raw & Sources) != Sources) ||
+                    ( res != EIP93_STATUS_OK )
+                )
+            {
+                  RawInterruptTestStatus = false ;
+
+
+            }
+        }
+
+    }
+
+#endif // ADAPTER_EIP93PE_INTERRUPTS_TEST_RAW_STATUS
+    // EIP93_INT_Acknowledge(&Adapter_EIP93_IOArea,
+    //    Sources);
+
+    // Disable the active interrupt sources
+    EIP93_INT_Mask(&Adapter_EIP93_IOArea, Sources);
+
+    if (Sources )
+    {
+    #ifndef RT_EIP93_DRIVER
+        printk("Adapter_Interrupts_Top_Half_Handler: Sources=0x%08x\n", Sources);
+    #endif
+    }
+
+    // now figure out which sources are active and call
+    // the appropriate interrupt handlers that are installed
+    while(Sources)
+    {
+		//Sources is 0x2 and IntNr is 1 in our case. --Trey
+        int IntNr = Adapter_Interrupts_GetActiveIntNr(Sources);
+
+        // now remove that bit from Sources
+        Sources ^= (1 << IntNr);
+
+        // verify we have a handler
+        {
+            Adapter_InterruptHandler_t H;
+
+            H = Adapter_Interrupts_HandlerFunctions[IntNr];
+
+            if (H)
+            {
+                // invoke the handler
+            #ifndef RT_EIP93_DRIVER
+                printk("\nAdapter_Interrupts_Top_Half_Handler: calling Handler for interrupt: %d \n",IntNr );
+            #endif
+
+                H();
+            }
+            else
+            {
+                printk(
+                    "Adapter_Interrupts_Top_Half_Handler: "
+                    "Disabling interrupt %d with missing handler\n",
+                    IntNr);
+
+                EIP93_INT_Mask( //set EIP93_REG_MASK_DISABLE
+                &Adapter_EIP93_IOArea,(EIP93_INT_SourceBitmap_t)(1 << IntNr));
+
+            }
+        }
+    } // while
+
+  return IRQ_HANDLED;
+}
+
+
+
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupt_SetHandler
+ */
+void
+Adapter_Interrupt_SetHandler(
+        const int nIRQ,
+        Adapter_InterruptHandler_t HandlerFunction)
+{
+    if (nIRQ >= ADAPTER_MAX_INTERRUPTS)
+        return;
+
+    // continue only we have the IRQ hooked
+    if (Adapter_Interrupts_IRQ != -1)
+    {
+    #ifndef RT_EIP93_DRIVER
+        printk("Adapter_Interrupt_SetHandler: HandlerFnc=%p for interrupt %d\n", HandlerFunction, nIRQ);
+    #endif
+        Adapter_Interrupts_HandlerFunctions[nIRQ] = HandlerFunction;
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupt_Enable
+ */
+void
+Adapter_Interrupt_Enable(
+        const int nIRQ)
+{
+    if (nIRQ >= ADAPTER_MAX_INTERRUPTS)
+        return;
+
+    // continue only we have the IRQ hooked
+    if (Adapter_Interrupts_IRQ != -1)
+    {
+        unsigned long flags;
+        const EIP93_INT_SourceBitmap_t Sources = 1 << nIRQ;
+
+    #ifndef RT_EIP93_DRIVER
+        printk("Adapter_Interrupt_Enable: Enabling interrupt %d\n", nIRQ);
+    #endif
+        spin_lock_irqsave(&Adapter_Interrupts_ConcurrencyLock, flags);
+        //set EIP93_REG_MASK_ENABLE register
+        EIP93_INT_UnMask(&Adapter_EIP93_IOArea, Sources );
+
+        spin_unlock_irqrestore(&Adapter_Interrupts_ConcurrencyLock, flags);
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupt_ClearAndEnable
+ */
+void
+Adapter_Interrupt_ClearAndEnable(
+        const int nIRQ)
+{
+    if (nIRQ >= ADAPTER_MAX_INTERRUPTS)
+        return;
+
+    // continue only we have the IRQ hooked
+    if (Adapter_Interrupts_IRQ != -1)
+    {
+        unsigned long flags;
+        const EIP93_INT_SourceBitmap_t Sources = 1 << nIRQ;
+#ifndef RT_EIP93_DRIVER
+        printk(
+            "Adapter_Interrupt_ClearAndEnable: "
+            "Enabling interrupt %d\n",
+            nIRQ);
+#endif
+
+        spin_lock_irqsave(&Adapter_Interrupts_ConcurrencyLock, flags);
+
+        // acknowledge before enable
+        // this ensures we do not get an old and remembered detected edge
+        // when we enable the interrupt
+        EIP93_INT_Acknowledge(
+                &Adapter_EIP93_IOArea,
+                Sources );
+
+        EIP93_INT_UnMask(
+                &Adapter_EIP93_IOArea,
+                Sources );
+
+        spin_unlock_irqrestore(&Adapter_Interrupts_ConcurrencyLock, flags);
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupt_Disable
+ *
+ * This function must be called from a sleepable context!
+ */
+void
+Adapter_Interrupt_Disable(
+        const int nIRQ)
+{
+#ifndef RT_EIP93_DRIVER
+    printk("Adapter_Interrupt_Disable: Disabling interrupt: 0x%x\n", nIRQ);
+#endif
+    if (nIRQ >= ADAPTER_MAX_INTERRUPTS)
+        return;
+
+    // continue only we have the IRQ hooked
+    if (Adapter_Interrupts_IRQ != -1)
+    {
+        unsigned long flags;
+        const EIP93_INT_SourceBitmap_t Sources = 1 << nIRQ;
+
+   #ifndef RT_EIP93_DRIVER
+        printk("Adapter_Interrupt_Disable: Disabling interrupt %d\n", nIRQ);
+   #endif
+        spin_lock_irqsave(&Adapter_Interrupts_ConcurrencyLock, flags);
+        //set EIP93_REG_MASK_DISABLE redister
+          EIP93_INT_Mask(&Adapter_EIP93_IOArea, Sources );
+
+        spin_unlock_irqrestore(&Adapter_Interrupts_ConcurrencyLock, flags);
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_TEST_RAW_STATUS
+        if( RawInterruptTestStatus == false )
+        {
+            printk("\n Raw Interrupt Status Mask Test : Failed \n");
+        }
+        else
+            printk("\n Raw Interrupt Status Mask Test : Passed \n");
+#endif
+    }
+}
+
+#ifdef MTK_CRYPTO_DRIVER
+DECLARE_TASKLET( \
+mtk_interrupt_BH_result, mtk_BH_handler_resultGet, 0);
+
+void mtk_interruptHandler_descriptorDone(void)
+{
+	tasklet_schedule(&mtk_interrupt_BH_result);
+}
+#endif
+
+
+#ifdef RT_EIP93_DRIVER
+static void crypto_irq_dispatch(void)
+{
+    do_IRQ(SURFBOARDINT_CRYPTO);
+}
+#endif
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupts_Init
+ */
+bool
+Adapter_Interrupts_Init(
+         const int nIRQ  )
+{
+   ZEROINIT(Adapter_Interrupts_HandlerFunctions);
+
+   spin_lock_init(&Adapter_Interrupts_ConcurrencyLock);
+
+   if (nIRQ != -1)
+   {
+        int res;
+
+#ifdef RT_EIP93_DRIVER
+        //set_vi_handler(nIRQ, crypto_irq_dispatch);
+#endif
+
+        // install the top-half interrupt handler for the given IRQ
+        res = request_irq(
+                        nIRQ,
+                        Adapter_Interrupts_Top_Half_Handler,
+                        /*irqflags:*/0,
+                        ADAPTER_DRIVER_NAME,
+                        NULL);
+
+        if (res)
+        {
+            printk(
+                "Adapter_Interrupts_Init: "
+                "request_irq returned %d\n",
+                res);
+        }
+        else //success
+        {
+            printk(
+                "Adapter_Interrupts_Init: "
+                "Successfully hooked IRQ %d\n",
+                nIRQ);
+
+            Adapter_Interrupts_IRQ = nIRQ;
+        }
+   }
+
+
+
+   printk(
+   "\nAdapter_Interrupts_Init: call back registered" );
+   Adapter_Interrupts_IRQ = nIRQ;
+
+   return true;
+}
+
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_Interrupts_UnInit
+ */
+void
+Adapter_Interrupts_UnInit(void)
+{
+    if (Adapter_Interrupts_IRQ != -1)
+    {
+        // disable all interrupts
+
+        EIP93_INT_Mask(&Adapter_EIP93_IOArea, 0xffffffff );
+         // unhook the interrupt
+        free_irq(Adapter_Interrupts_IRQ, NULL);
+        Adapter_Interrupts_IRQ = -1;
+
+        printk(
+   "\nAdapter_Interrupts_UnInit: call back un-registered with VTBAL" );
+
+    }
+}
+
+#else
+ ;
+#endif // #ifdef ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+
+
diff --git a/drivers/net/cryptoDriver/source/mtk_pecInit.c b/drivers/net/cryptoDriver/source/mtk_pecInit.c
new file mode 100755
index 0000000..73d8fd0
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/mtk_pecInit.c
@@ -0,0 +1,317 @@
+
+#include "mtk_cAdapter.h"
+#ifdef ADAPTER_EIP93_PE_MODE_ARM
+
+#include "mtk_baseDefs.h"         // uint32_t
+#include "mtk_pecApi.h"   // PEC_* (the API we implement here)
+#include "mtk_dmaBuf.h"         // DMABuf_*
+#include "mtk_hwDmaAccess.h"      // HWPAL_Resource_*
+#include "mtk_cLib.h"               // memcpy
+#include "mtk_AdapterInternal.h"
+#include "mtk_eip93.h"
+#include "mtk_interrupts.h"
+#include "mtk_arm.h"        // driver library API we will use
+#include "mtk_descp.h" // for parsing result descriptor
+#include <linux/kernel.h>
+
+
+static bool PEC_IsInitialized = false;
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_PRNG_Init_ARM
+ *
+ * This function initializes the PE PRNG for the ARM mode.
+ *
+ * Return Value
+ *      true: PRNG is initialized
+ *     false: PRNG initialization failed
+ */
+static bool
+Adapter_PRNG_Init_ARM(const bool fLongSA)
+{
+    int i;
+    EIP93_Status_t res93;
+    EIP93_ARM_CommandDescriptor_t EIP93_CmdDscr;
+    EIP93_ARM_ResultDescriptor_t EIP93_ResDscr;
+    DMABuf_Status_t dmares;
+    DMABuf_HostAddress_t HostAddr;
+    DMABuf_Properties_t DMAProp;
+    DMABuf_Handle_t DMAHandle;
+    EIP93_ResultDescriptor_Status_t EIP93ResDscrStatus;
+    HWPAL_DMAResource_Handle_t DMAResHandle;
+    unsigned int PutCount = 0;
+    int LoopLimiter = 1000;
+    EIP93_DeviceAddress_t EIP93PhysAddress = {0};
+
+    DMAProp.Alignment = 4;        // used as uint32_t array
+    DMAProp.Bank = 0;
+    DMAProp.fCached = false;
+    DMAProp.Size = 128;
+
+    // Allocate DMA-safe buffer for SA record
+    dmares = DMABuf_Alloc(DMAProp, &HostAddr, &DMAHandle);
+    if (dmares != DMABUF_STATUS_OK)
+    {
+        printk(
+            "Adapter_PRNG_Init_ARM: "
+            "Failed to alloc DMA buffer (error %d)\n",
+            dmares);
+
+        return false;   // failure
+    }
+
+    // Fill in SA for PRNG Init
+    *(((uint32_t*)HostAddr.p))   = 0x00001307;   // SA word 0
+    *(((uint32_t*)HostAddr.p)+1) = 0x02000000;   // SA word 1
+    if(fLongSA)
+    {
+        // 32-word SA
+        const uint32_t PRNGKey[]      = {0xe0fc631d, 0xcbb9fb9a,
+                                         0x869285cb, 0xcbb9fb9a,
+                                         0, 0, 0, 0};
+        const uint32_t PRNGSeed[]     = {0x758bac03, 0xf20ab39e,
+                                         0xa569f104, 0x95dfaea6,
+                                         0, 0, 0, 0};
+        const uint32_t PRNGDateTime[] = {0, 0, 0, 0, 0, 0, 0, 0};
+
+        for(i = 0; i < 8; i++)
+        {
+            *(((uint32_t*)HostAddr.p)+i+2)   = PRNGKey[i];
+            *(((uint32_t*)HostAddr.p)+i+10)  = PRNGSeed[i];
+            *(((uint32_t*)HostAddr.p)+i+18)  = PRNGDateTime[i];
+        }// for
+    }
+    else
+    {
+        // 24-word SA
+        const uint32_t PRNGKey[]      = {0xe0fc631d, 0xcbb9fb9a,
+                                         0x869285cb, 0xcbb9fb9a,
+                                         0, 0};
+        const uint32_t PRNGSeed[]     = {0x758bac03, 0xf20ab39e,
+                                         0xa569f104, 0x95dfaea6,
+                                         0};
+        const uint32_t PRNGDateTime[] = {0, 0, 0, 0, 0};
+
+        // Write key data to SA
+        for(i = 0; i < 6; i++)
+        {
+
+            *(((uint32_t*)HostAddr.p)+i+2)   = PRNGKey[i];
+        }// for
+
+        // Write Seed and Date&Time data to SA
+        for(i = 0; i < 5; i++)
+        {
+            *(((uint32_t*)HostAddr.p)+i+8)   = PRNGSeed[i];
+            *(((uint32_t*)HostAddr.p)+i+13)  = PRNGDateTime[i];
+        }// for
+    }
+
+    Adapter_GetEIP93PhysAddr(DMAHandle, &DMAResHandle, &EIP93PhysAddress);
+
+    // In-place copy to ensure correct endianness format
+    {
+        HWPAL_DMAResource_Record_t * const Rec_p =
+            HWPAL_DMAResource_Handle2RecordPtr(DMAResHandle);
+
+        HWPAL_DMAResource_Write32Array(
+                    DMAResHandle,
+                    0,
+                    Rec_p->host.BufferSize / 4,
+                    Rec_p->host.HostAddr_p);
+    }
+
+    // ask the EIP93 DrvLib to finalize the SA
+    // (fill in some fields it is responsible for)
+    res93 = EIP93_ARM_FinalizeSA(&Adapter_EIP93_IOArea, DMAResHandle);
+    if (res93 != EIP93_STATUS_OK)
+    {
+        printk(
+            "Adapter_PRNG_Init_ARM: "
+            "EIP93_ARM_FinalizeSA returned %d\n",
+            res93);
+
+        goto fail;     // failure
+    }
+
+    // now use DMAResource to ensure the engine
+    // can read the memory blocks using DMA
+    HWPAL_DMAResource_PreDMA(DMAResHandle, 0, 0);     // 0,0 = "entire buffer"
+
+    ZEROINIT(EIP93_CmdDscr);
+    ZEROINIT(EIP93_ResDscr);
+
+    // Fill in command descriptor
+    EIP93_CmdDscr.ControlWord = 0x40;   // PRNG Init function
+    EIP93_CmdDscr.SADataAddr.Addr = EIP93PhysAddress.Addr;
+
+    res93 = EIP93_ARM_PacketPut(
+                &Adapter_EIP93_IOArea,
+                &EIP93_CmdDscr,
+                1,
+                &PutCount);
+    if (res93 != EIP93_STATUS_OK)
+    {
+        printk(
+            "Adapter_PRNG_Init_ARM: "
+            "EIP93_ARM_PacketPut returned %d\n", res93);
+
+        goto fail;       // failure
+    }
+
+    if (PutCount == 0)
+        goto fail;       // failure
+
+    // now wait for the result descriptor
+    // normally this will we get the result descriptors in no-time
+    while(LoopLimiter > 0)
+    {
+        unsigned int GetCount = 0;
+
+        res93 = EIP93_ARM_PacketGet(
+                    &Adapter_EIP93_IOArea,
+                    &EIP93_ResDscr,
+                    1,
+                    &GetCount);
+        if (res93 != EIP93_STATUS_OK)
+        {
+            printk(
+                "Adapter_PRNG_Init_ARM: "
+                "EIP93_ARM_PacketGet returned %d\n", res93);
+
+            goto fail;       // failure
+        }
+
+        if (GetCount > 0)
+            break;
+
+        LoopLimiter--;
+        // note: we might not be in a sleepable context
+        // so no sleep call here!
+    } // while
+
+    if (LoopLimiter <= 0)
+    {
+        printk(
+            "Adapter_PRNG_Init_ARM: "
+            "EIP93_ARM_PacketGet could not retrieve a result descriptor\n");
+
+        goto fail;       // failure
+    }
+
+    EIP93_ResultDescriptor_Status_InterpretWord(EIP93_ResDscr.StatusWord,
+                                                &EIP93ResDscrStatus);
+
+    if (EIP93ResDscrStatus.RawStatus != 0)
+    {
+        printk(
+            "Adapter_PRNG_Init_ARM: "
+            "EIP93_ARM_PacketGet returned with status code 0x%08x\n",
+            EIP93_ResDscr.StatusWord);
+
+        goto fail;       // failure
+    }
+
+    DMABuf_Release(DMAHandle);
+    return true; // success
+
+fail:
+    DMABuf_Release(DMAHandle);
+    return false;
+}
+
+
+/*----------------------------------------------------------------------------
+ * PEC_Init
+ */
+PEC_Status_t
+PEC_Init(
+     const   PEC_InitBlock_t * const InitBlock_p)
+{
+    // ensure we init only once
+    if (PEC_IsInitialized)
+        return PEC_ERROR_BAD_USE_ORDER;
+
+
+	if (!Adapter_EIP93_SetMode_ARM(0))
+	{
+        return PEC_ERROR_INTERNAL;      // ## RETURN ##
+	}
+
+    // Initialize PRNG if present
+    {
+        EIP93_Status_t res93;
+        EIP93_Capabilities_t Capabilities;
+        bool fLongSA = false;
+
+        res93 = EIP93_HWRevision_Get(
+                        &Adapter_EIP93_IOArea,
+                        &Capabilities);
+        if (res93 != EIP93_STATUS_OK)
+        {
+            printk(
+                "PEC_Init: "
+                "EIP93_HWRevision_Get returns error: %d\n",
+                res93);
+
+            return PEC_ERROR_INTERNAL;
+        }
+
+        if(Capabilities.fPrng)
+        {
+            if(Capabilities.fAes256 ||
+               Capabilities.fSha224 ||
+               Capabilities.fSha256)
+                fLongSA = true;
+
+            if (!Adapter_PRNG_Init_ARM(fLongSA))
+            {
+                // PRNG init failed, so shutdown and return an error code
+                printk("PEC_Init: PRNG initialization failed!\n");
+
+                Adapter_EIP93_SetMode_Idle();
+                return PEC_ERROR_INTERNAL;
+            }
+            else
+            {
+                printk("PEC_Init: PRNG is initialized\n");
+            }
+        }
+    }
+
+
+    PEC_IsInitialized = true;
+
+
+    return PEC_STATUS_OK;
+}
+
+
+/*----------------------------------------------------------------------------
+ * PEC_UnInit
+ */
+PEC_Status_t
+PEC_UnInit(void)
+{
+    // ensure we un-init only once
+    if (PEC_IsInitialized)
+    {
+        Adapter_EIP93_SetMode_Idle();
+
+#ifdef ADAPTER_EIP93PE_INTERRUPTS_ENABLE
+        Adapter_Interrupt_Disable(IRQ_RDR_THRESH_IRQ);
+        Adapter_Interrupt_Disable(IRQ_CDR_THRESH_IRQ);
+#endif
+
+        PEC_IsInitialized = false;
+    }
+
+    return PEC_STATUS_OK;
+}
+
+
+#else
+;       // avoids "empty translation unit" warning
+#endif /* ADAPTER_EIP93_PE_MODE_ARM */
+
diff --git a/drivers/net/cryptoDriver/source/mtk_pktProcess.c b/drivers/net/cryptoDriver/source/mtk_pktProcess.c
new file mode 100755
index 0000000..5ca527f
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/mtk_pktProcess.c
@@ -0,0 +1,1007 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/sched.h>
+
+#include <linux/delay.h>
+#include <linux/string.h>
+
+#include <net/ip.h>
+#include <asm/io.h>
+#include <asm/mach-ralink/rt_mmap.h>
+#include "mtk_cAdapter.h"
+#include "mtk_baseDefs.h"         // uint32_t
+#include "mtk_pecApi.h"            // PEC_* (the API we implement here)
+#include "mtk_dmaBuf.h"         // DMABuf_*
+#include "mtk_hwDmaAccess.h"      // HWPAL_Resource_*
+#include "mtk_cLib.h"               // memcpy
+#include "mtk_AdapterInternal.h"
+#include "mtk_interrupts.h"
+#include "mtk_arm.h"        // driver library API we will use
+#include "mtk_descp.h" // for parsing result descriptor
+
+#include <net/mtk_esp.h>
+#include "mtk_ipsec.h"
+#include <linux/skbuff.h>
+
+
+extern unsigned int *pCmdRingBase, *pResRingBase; //uncached memory address
+extern void mtk_interruptHandler_descriptorDone(void);
+
+#define EIP93_RING_SIZE		((ADAPTER_EIP93_RINGSIZE_BYTES)>>5)
+#define EIP93_REG_BASE		(RALINK_CRYPTO_ENGINE_BASE)
+#define PE_CTRL_STAT			0x00000000
+#define PE_CD_COUNT			0x00000090
+#define	PE_RD_COUNT			0x00000094
+#define PE_RING_PNTR		0x00000098
+#define PE_CONFIG			0x00000100
+#define PE_DMA_CONFIG			0x00000120
+#define PE_ENDIAN_CONFIG	0x000001d0
+//#define dma_cache_wback_inv(start, size) _dma_cache_wback_inv(start,size)
+#define K1_TO_PHY(x)		(((unsigned int)x) & 0x1fffffff)
+#define WORDSWAP(a)     	((((a)>>24)&0xff) | (((a)>>8)&0xff00) | (((a)<<8)&0xff0000) | (((a)<<24)&0xff000000))
+#define DESCP_SIZE			32
+#define EIP93_RING_BUFFER	24
+
+static unsigned int cmdRingIdx, resRingIdx;
+static uint32_t *pEip93RegBase = (uint32_t *)EIP93_REG_BASE;
+
+static spinlock_t 			putlock, getlock;
+
+#ifdef WORKQUEUE_BH
+static DECLARE_WORK(mtk_interrupt_BH_result_wq, mtk_BH_handler_resultGet);
+#else
+static DECLARE_TASKLET( \
+mtk_interrupt_BH_result_tsk, mtk_BH_handler_resultGet, 0);
+#endif
+static void mtk_interruptHandler_done(void);
+
+#ifdef CONFIG_L2TP
+#define BUFFER_MEMCPY	1
+#define SKB_HEAD_SHIFT	1
+#endif
+
+#ifdef MCRYPTO_DBG
+#define ra_dbg 	printk
+#else
+#define ra_dbg(fmt, arg...) do {}while(0)
+#endif
+
+static int pskb_alloc_head(struct sk_buff *skb, u8* data, u32 size, int offset);
+int copy_data_head(struct sk_buff *skb, int offset);
+int copy_data_bottom(struct sk_buff *skb, int offset);
+static int DMAAlign = 0;
+
+#ifdef MCRYPTO_DBG
+static void skb_dump(struct sk_buff* sk, const char* func,int line) {
+        unsigned int i;
+
+        ra_dbg("(%d)skb_dump: [%s] with len %d (%08X) headroom=%d tailroom=%d\n",
+                line,func,sk->len,sk,
+                skb_headroom(sk),skb_tailroom(sk));
+
+        for(i=(unsigned int)sk->head;i<=(unsigned int)sk->data + sk->len;i++) {
+                if((i % 16) == 0)
+                        ra_dbg("\n");
+                if(i==(unsigned int)sk->data) printk("{");
+                //if(i==(unsigned int)sk->h.raw) printk("#");
+                //if(i==(unsigned int)sk->nh.raw) printk("|");
+                //if(i==(unsigned int)sk->mac.raw) printk("*");
+                ra_dbg("%02x ",*((unsigned char*)i));
+                if(i==(unsigned int)(sk->tail)-1) printk("}");
+        }
+        ra_dbg("\n");
+}
+#else
+#define skb_dump(x,y,z) do {}while(0)
+#endif
+
+/************************************************************************
+*              P R I V A T E     F U N C T I O N S
+*************************************************************************
+*/
+static void
+mtk_cmdHandler_free(
+	eip93DescpHandler_t *cmdHandler
+)
+{
+	saRecord_t *saRecord;
+	saState_t *saState;
+	dma_addr_t	saPhyAddr, statePhyAddr;
+
+	saRecord = (saRecord_t *)cmdHandler->saAddr.addr;
+	saPhyAddr = (dma_addr_t)cmdHandler->saAddr.phyAddr;
+	saState = (saState_t *)cmdHandler->stateAddr.addr;
+	statePhyAddr = (dma_addr_t)cmdHandler->stateAddr.phyAddr;
+
+	dma_free_coherent(NULL, sizeof(saRecord_t), saRecord, saPhyAddr);
+	dma_free_coherent(NULL, sizeof(saState_t), saState, statePhyAddr);
+	kfree(cmdHandler);
+}
+
+/*_______________________________________________________________________
+**function name: ipsec_addrsDigestPreCompute_free
+**
+**description:
+*   free those structions that are created for Hash Digest Pre-Compute!
+*	Those sturctures won't be used anymore during encryption/decryption!
+**parameters:
+*   currAdapterPtr -- point to the structure that stores the addresses
+*		for those structures for Hash Digest Pre-Compute.
+**global:
+*   none
+**return:
+*   none
+**call:
+*   none
+**revision:
+*   1.Trey 20120209
+**_______________________________________________________________________*/
+static void
+mtk_addrsDigestPreCompute_free(
+	ipsecEip93Adapter_t *currAdapterPtr
+)
+{
+	unsigned int *ipad, *opad, *hashKeyTank;
+	unsigned int *pIDigest, *pODigest;
+	unsigned int blkSize;
+	saRecord_t *saRecord;
+	saState_t *saState, *saState2;
+	dma_addr_t	ipadPhyAddr, opadPhyAddr, saPhyAddr, statePhyAddr, statePhyAddr2;
+	eip93DescpHandler_t *cmdHandler;
+	addrsDigestPreCompute_t *addrsPreCompute;
+
+	addrsPreCompute = currAdapterPtr->addrsPreCompute;
+
+	if(addrsPreCompute == NULL)
+		return;
+
+	hashKeyTank = addrsPreCompute->hashKeyTank;
+	ipad		= (unsigned int *)addrsPreCompute->ipadHandler.addr;
+	ipadPhyAddr = addrsPreCompute->ipadHandler.phyAddr;
+	opad		= (unsigned int *)addrsPreCompute->opadHandler.addr;
+	opadPhyAddr = addrsPreCompute->opadHandler.phyAddr;
+	blkSize 	= addrsPreCompute->blkSize;
+	cmdHandler 	= addrsPreCompute->cmdHandler;
+	saRecord 	= (saRecord_t *)addrsPreCompute->saHandler.addr;
+	saPhyAddr 	= addrsPreCompute->saHandler.phyAddr;
+	saState 	= (saState_t *)addrsPreCompute->stateHandler.addr;
+	statePhyAddr = addrsPreCompute->stateHandler.phyAddr;
+	saState2 	= (saState_t *)addrsPreCompute->stateHandler2.addr;
+	statePhyAddr2 = addrsPreCompute->stateHandler2.phyAddr;
+	pIDigest 	= addrsPreCompute->pIDigest;
+	pODigest 	= addrsPreCompute->pODigest;
+
+	kfree(pODigest);
+	kfree(pIDigest);
+	dma_free_coherent(NULL, sizeof(saState_t), saState2, statePhyAddr2);
+	dma_free_coherent(NULL, sizeof(saState_t), saState, statePhyAddr);
+	dma_free_coherent(NULL, sizeof(saRecord_t), saRecord, saPhyAddr);
+	kfree(cmdHandler);
+	dma_free_coherent(NULL, blkSize, opad, opadPhyAddr);
+	dma_free_coherent(NULL, blkSize, ipad, ipadPhyAddr);
+	kfree(hashKeyTank);
+	kfree(addrsPreCompute);
+	addrsPreCompute->pODigest = NULL;
+	addrsPreCompute->pIDigest = NULL;
+	currAdapterPtr->addrsPreCompute = NULL;
+}
+
+static void
+mtk_hashDigests_get(
+	ipsecEip93Adapter_t *currAdapterPtr
+)
+{
+	eip93DescpHandler_t *cmdHandler;
+	saRecord_t *saRecord;
+	addrsDigestPreCompute_t* addrsPreCompute;
+	unsigned int i;
+
+	cmdHandler = currAdapterPtr->cmdHandler;
+	saRecord = (saRecord_t *)cmdHandler->saAddr.addr;
+	addrsPreCompute = currAdapterPtr->addrsPreCompute;
+
+	for (i = 0; i < (addrsPreCompute->digestWord); i++)
+	{
+		saRecord->saIDigest[i] = addrsPreCompute->pIDigest[i];
+		saRecord->saODigest[i] = addrsPreCompute->pODigest[i];
+	}
+}
+
+static void
+mtk_hashDigests_set(
+	ipsecEip93Adapter_t *currAdapterPtr,
+	unsigned int isInOrOut
+)
+{
+//resDescpHandler only has physical addresses, so we have to get saState's virtual address from addrsPreCompute.
+
+	addrsDigestPreCompute_t *addrsPreCompute;
+	saState_t *stateHandler;
+	unsigned int i, digestWord;
+
+
+	addrsPreCompute = (addrsDigestPreCompute_t*) currAdapterPtr->addrsPreCompute;
+	digestWord = addrsPreCompute->digestWord;
+
+	if (isInOrOut == 1) //for Inner Digests
+	{
+		stateHandler = (saState_t *) addrsPreCompute->stateHandler.addr;
+
+		for (i = 0; i < digestWord; i++)
+		{
+			addrsPreCompute->pIDigest[i] = stateHandler->stateIDigest[i];
+		}
+	}
+	else if (isInOrOut == 2) //for Outer Digests
+	{
+		stateHandler = (saState_t *) addrsPreCompute->stateHandler2.addr;
+
+		for (i = 0; i < digestWord; i++)
+		{
+			addrsPreCompute->pODigest[i] = stateHandler->stateIDigest[i];
+		}
+	}
+}
+
+static unsigned int
+mtk_eip93UserId_get(
+	eip93DescpHandler_t *resHandler
+)
+{
+/* In our case, during hash digest pre-compute, the userId will be
+ * currAdapterPtr; but during encryption/decryption, the userId
+ * will be skb
+ */
+	return resHandler->userId;
+}
+
+static unsigned int
+mtk_eip93HashFinal_get(
+	eip93DescpHandler_t *resHandler
+)
+{
+/* In our case, during hash digest pre-compute, the hashFinal bit
+ * won't be set; but during encryption/decryption, the hashFinal
+ * bit will be set
+ */
+	return resHandler->peCrtlStat.bits.hashFinal;
+}
+
+static unsigned int
+mtk_pktLength_get(
+	eip93DescpHandler_t *resHandler
+)
+{
+	return resHandler->peLength.bits.length;
+}
+
+static unsigned char
+mtk_espNextHeader_get(
+	eip93DescpHandler_t *resHandler
+)
+{
+	return resHandler->peCrtlStat.bits.padValue;
+}
+
+static void
+mtk_espNextHeader_set(
+	eip93DescpHandler_t *cmdHandler,
+	unsigned char protocol
+)
+{
+	cmdHandler->peCrtlStat.bits.padValue = protocol; //ipsec esp's next-header which is IPPROTO_IPIP for tunnel or ICMP/TCP/UDP for transport mode
+}
+
+static int
+mtk_preComputeIn_cmdDescp_set(
+	ipsecEip93Adapter_t *currAdapterPtr,
+	unsigned int direction
+)
+{
+	addrsDigestPreCompute_t* addrsPreCompute = currAdapterPtr->addrsPreCompute;
+	eip93DescpHandler_t *cmdHandler;
+	saRecord_t *saRecord;
+	saState_t *saState;
+	dma_addr_t	saPhyAddr, statePhyAddr;
+	int errVal;
+
+
+	cmdHandler = (eip93DescpHandler_t *) kzalloc(sizeof(eip93DescpHandler_t), GFP_KERNEL);
+	if (unlikely(cmdHandler == NULL))
+	{
+		printk("\n\n !!kmalloc for cmdHandler failed!! \n\n");
+		return -ENOMEM;
+	}
+	addrsPreCompute->cmdHandler = cmdHandler;
+
+	saRecord = (saRecord_t *) dma_alloc_coherent(NULL, sizeof(saRecord_t), &saPhyAddr, GFP_KERNEL);
+	if (unlikely(saRecord == NULL))
+	{
+		printk("\n\n !!dma_alloc for saRecord failed!! \n\n");
+		errVal = -ENOMEM;
+		goto free_cmdHandler;
+	}
+	memset(saRecord, 0, sizeof(saRecord_t));
+	addrsPreCompute->saHandler.addr = (unsigned int)saRecord;
+	addrsPreCompute->saHandler.phyAddr = saPhyAddr;
+
+	saState = (saState_t *) dma_alloc_coherent(NULL, sizeof(saState_t), &statePhyAddr, GFP_KERNEL);
+	if (unlikely(saState == NULL))
+	{
+		printk("\n\n !!dma_alloc for saState failed!! \n\n");
+		errVal = -ENOMEM;
+		goto free_saRecord;
+	}
+	memset(saState, 0, sizeof(saState_t));
+	addrsPreCompute->stateHandler.addr = (unsigned int)saState;
+	addrsPreCompute->stateHandler.phyAddr = statePhyAddr;
+
+
+	saRecord->saCmd0.bits.opCode = 0x3; //basic hash operation
+	saRecord->saCmd0.bits.hashSource = 0x3; //no load HASH_SOURCE
+	saRecord->saCmd0.bits.saveHash = 0x1;
+
+	if (addrsPreCompute->digestWord == 4)
+		saRecord->saCmd0.bits.hash = 0x0; //md5
+	else if (addrsPreCompute->digestWord == 5)
+		saRecord->saCmd0.bits.hash = 0x1; //sha1
+	else if (addrsPreCompute->digestWord == 8)
+		saRecord->saCmd0.bits.hash = 0x3; //sha256
+	else if (addrsPreCompute->digestWord == 0)
+		saRecord->saCmd0.bits.hash = 0xf; //null
+
+	if (direction == HASH_DIGEST_OUT)
+	{
+		saRecord->saCmd0.bits.direction = 0x0; //outbound
+	}
+	else if (direction == HASH_DIGEST_IN)
+	{
+		saRecord->saCmd0.bits.direction = 0x1; //inbound
+	}
+
+	//saRecord->saCmd0.bits.hash = hashAlg;
+
+	cmdHandler->peCrtlStat.bits.hostReady = 0x1;
+	cmdHandler->srcAddr.phyAddr = addrsPreCompute->ipadHandler.phyAddr;
+	cmdHandler->saAddr.phyAddr = saPhyAddr;
+	cmdHandler->stateAddr.phyAddr = statePhyAddr;
+	cmdHandler->peLength.bits.hostReady = 0x1;
+	cmdHandler->peLength.bits.length = (addrsPreCompute->blkSize) & (BIT_20 - 1);
+
+	//save needed info in EIP93's userID, so the needed info can be used by the tasklet which is raised by interrupt.
+	cmdHandler->userId = (unsigned int)currAdapterPtr;
+
+	return 1;
+
+
+free_saRecord:
+	dma_free_coherent(NULL, sizeof(saRecord_t), saRecord, saPhyAddr);
+free_cmdHandler:
+	kfree(cmdHandler);
+
+	return errVal;
+}
+
+static int
+mtk_preComputeOut_cmdDescp_set(
+	ipsecEip93Adapter_t *currAdapterPtr,
+	unsigned int direction
+)
+{
+	addrsDigestPreCompute_t* addrsPreCompute = currAdapterPtr->addrsPreCompute;
+	saState_t *saState2;
+	dma_addr_t	statePhyAddr2;
+	int errVal;
+	eip93DescpHandler_t *cmdHandler = addrsPreCompute->cmdHandler;
+
+
+	saState2 = (saState_t *) dma_alloc_coherent(NULL, sizeof(saState_t), &statePhyAddr2, GFP_KERNEL);
+	if (unlikely(saState2 == NULL))
+	{
+		printk("\n\n !!dma_alloc for saState2 failed!! \n\n");
+		errVal = -ENOMEM;
+		goto free_preComputeIn;
+	}
+	memset(saState2, 0, sizeof(saState_t));
+	addrsPreCompute->stateHandler2.addr = (unsigned int)saState2;
+	addrsPreCompute->stateHandler2.phyAddr = statePhyAddr2;
+
+
+	cmdHandler->srcAddr.phyAddr = addrsPreCompute->opadHandler.phyAddr;
+	cmdHandler->stateAddr.phyAddr = statePhyAddr2;
+
+	return 1;
+
+
+free_preComputeIn:
+	dma_free_coherent(NULL, sizeof(saState_t), (saState_t *)addrsPreCompute->stateHandler.addr, addrsPreCompute->stateHandler.phyAddr);
+	dma_free_coherent(NULL, sizeof(saRecord_t), (saRecord_t *)addrsPreCompute->saHandler.addr, addrsPreCompute->saHandler.phyAddr);
+	kfree(addrsPreCompute->cmdHandler);
+
+	return errVal;
+}
+
+static int
+mtk_cmdHandler_cmdDescp_set(
+	ipsecEip93Adapter_t *currAdapterPtr,
+	unsigned int direction,
+	unsigned int cipherAlg,
+	unsigned int hashAlg,
+	unsigned int digestWord,
+	unsigned int cipherMode,
+	unsigned int enHmac,
+	unsigned int aesKeyLen,
+	unsigned int *cipherKey,
+	unsigned int keyLen,
+	unsigned int spi,
+	unsigned int padCrtlStat
+)
+{
+	eip93DescpHandler_t *cmdHandler;
+	saRecord_t *saRecord;
+	saState_t *saState;
+	dma_addr_t saPhyAddr, statePhyAddr;
+	int errVal;
+	unsigned int keyWord, i;
+
+
+	cmdHandler = (eip93DescpHandler_t *) kzalloc(sizeof(eip93DescpHandler_t), GFP_KERNEL);
+	if (unlikely(cmdHandler == NULL))
+	{
+		printk("\n\n !!kmalloc for cmdHandler_prepare failed!! \n\n");
+		return -ENOMEM;
+	}
+
+	saRecord = (saRecord_t *) dma_alloc_coherent(NULL, sizeof(saRecord_t), &saPhyAddr, GFP_KERNEL);
+	if (unlikely(saRecord == NULL))
+	{
+		printk("\n\n !!dma_alloc for saRecord_prepare failed!! \n\n");
+		errVal = -ENOMEM;
+		goto free_cmdHandler;
+	}
+	memset(saRecord, 0, sizeof(saRecord_t));
+
+	saState = (saState_t *) dma_alloc_coherent(NULL, sizeof(saState_t), &statePhyAddr, GFP_KERNEL);
+	if (unlikely(saState == NULL))
+	{
+		printk("\n\n !!dma_alloc for saState_prepare failed!! \n\n");
+		errVal = -ENOMEM;
+		goto free_saRecord;
+	}
+	memset(saState, 0, sizeof(saState_t));
+
+
+	/* prepare SA */
+
+	if (direction == HASH_DIGEST_OUT)
+	{
+		currAdapterPtr->isEncryptOrDecrypt = 1; //encrypt
+		saRecord->saCmd0.bits.direction = 0x0; //outbound
+		saRecord->saCmd0.bits.ivSource = 0x3;//0x3; //load IV from PRNG
+		//if (cipherAlg == 0x3)
+			//saRecord->saCmd1.bits.aesDecKey = 0;
+	}
+	else if (direction == HASH_DIGEST_IN)
+	{
+		currAdapterPtr->isEncryptOrDecrypt = 2; //decrypt
+		saRecord->saCmd0.bits.direction = 0x1; //inbound
+		//if (cipherAlg == 0x3)
+			//saRecord->saCmd1.bits.aesDecKey = 1;
+	}
+
+	saRecord->saCmd0.bits.opGroup = 0x1;
+	saRecord->saCmd0.bits.opCode = 0x0; //esp protocol
+	saRecord->saCmd0.bits.cipher = cipherAlg;
+	saRecord->saCmd0.bits.hash = hashAlg;
+	saRecord->saCmd0.bits.hdrProc = 0x1; //header processing for esp
+	saRecord->saCmd0.bits.digestLength = digestWord;
+	saRecord->saCmd1.bits.cipherMode = cipherMode;
+	saRecord->saCmd1.bits.hmac = enHmac;
+	if (cipherAlg == 0x3) //aes
+		saRecord->saCmd1.bits.arc4KeyLen = aesKeyLen;
+		//saRecord->saCmd1.bits.aesKeyLen = aesKeyLen;
+
+	saRecord->saCmd1.bits.seqNumCheck = 1;
+
+	keyWord = keyLen >> 2;
+	for (i = 0; i < keyWord; i++)
+	{
+		//saRecord->saKey[i] = WORDSWAP(cipherKey[i]);
+		saRecord->saKey[i] = cipherKey[i];
+	}
+
+	saRecord->saSpi = WORDSWAP(spi); //esp spi
+
+	saRecord->saSeqNumMask[0] = 0xFFFFFFFF;
+	saRecord->saSeqNumMask[1] = 0x0;
+
+	/* prepare command descriptor */
+
+	cmdHandler->peCrtlStat.bits.hostReady = 0x1;
+	cmdHandler->peCrtlStat.bits.hashFinal = 0x1;
+	cmdHandler->peCrtlStat.bits.padCrtlStat = padCrtlStat; //pad boundary
+
+	cmdHandler->saAddr.addr = (unsigned int)saRecord;
+	cmdHandler->saAddr.phyAddr = saPhyAddr;
+	cmdHandler->stateAddr.addr = (unsigned int)saState;
+	cmdHandler->stateAddr.phyAddr = statePhyAddr;
+	cmdHandler->arc4Addr.addr = (unsigned int)saState;
+	cmdHandler->arc4Addr.phyAddr = statePhyAddr;
+	cmdHandler->peLength.bits.hostReady = 0x1;
+	cmdHandler->peCrtlStat.bits.peReady = 0;
+
+	/* restore cmdHandler for later use */
+	currAdapterPtr->cmdHandler = cmdHandler;
+	return 1;
+
+
+free_saRecord:
+	dma_free_coherent(NULL, sizeof(saRecord_t), saRecord, saPhyAddr);
+free_cmdHandler:
+	kfree(cmdHandler);
+	return errVal;
+}
+
+/*_______________________________________________________________________
+**function name: mtk_packet_put
+**
+**description:
+*   put command descriptor into EIP93's Command Descriptor Ring and
+*	then kick off EIP93.
+**parameters:
+*   cmdDescp -- point to the command handler that stores the needed
+*		info for the command descriptor.
+*	skb -- the packet for encryption/decryption
+**global:
+*   none
+**return:
+*   0 -- success.
+**call:
+*   none
+**revision:
+*   1.Trey 20120209
+**_______________________________________________________________________*/
+static int
+mtk_packet_put(
+	eip93DescpHandler_t *cmdDescp,
+	struct sk_buff *skb //skb == NULL when in digestPreCompute
+)
+{
+	unsigned int *pCrd = pCmdRingBase;
+	ipsecEip93Adapter_t *currAdapterPtr;
+	unsigned int addedLen;
+	unsigned int *addrCurrAdapter;
+	unsigned long flags;
+	u32* pData = NULL;
+	dma_addr_t pDataPhy;
+
+	//spin_lock_irqsave(&putlock, flags);
+
+	if(cmdRingIdx == EIP93_RING_SIZE)
+	{
+		cmdRingIdx = 0;
+	}
+	pCrd += (cmdRingIdx << 3); //cmdRingIdx*8 (a cmdDescp has 8 words!)
+	cmdRingIdx++;
+
+	pCrd[3] = cmdDescp->saAddr.phyAddr;
+	pCrd[4] = cmdDescp->stateAddr.phyAddr;
+	pCrd[5] = cmdDescp->arc4Addr.phyAddr;
+
+	if(likely(skb != NULL))
+	{
+		addrCurrAdapter = (unsigned int *) &(skb->cb[36]);
+		currAdapterPtr = (ipsecEip93Adapter_t *)(*addrCurrAdapter);
+		addedLen = currAdapterPtr->addedLen;
+
+		dma_cache_wback_inv((unsigned long)(skb->data), (skb->len + addedLen) & (BIT_20 - 1));
+
+#if defined (BUFFER_MEMCPY)
+		if ((u32)(skb->data)%DMAAlign)
+		{
+#if defined (SKB_HEAD_SHIFT)
+			int offset, alloc_size;
+			offset = DMAAlign-(u32)(skb->data)%DMAAlign;
+			pData = NULL;
+#else
+			pData = kmalloc(skb->len + addedLen, GFP_KERNEL);
+#endif
+			*(unsigned int *) &(skb->cb[40]) = (u32)pData;
+			if(pData==NULL)
+			{
+#if defined (SKB_HEAD_SHIFT)
+				pCrd[1] = K1_TO_PHY(skb->data);
+				pCrd[2] = K1_TO_PHY(skb->data+offset);
+#else
+				printk("mtk_packet_put allocate null\n");
+				pCrd[1] = K1_TO_PHY(skb->data);
+				pCrd[2] = K1_TO_PHY(skb->data);
+#endif
+			}
+			else
+			{
+				pDataPhy = dma_map_single(NULL, pData, skb->len + addedLen, PCI_DMA_FROMDEVICE);
+				if (pDataPhy==NULL)
+				{
+					printk("dma_map_single pDataPhy NULL\n");
+				}
+				pCrd[1] = K1_TO_PHY(skb->data);
+				pCrd[2] = pDataPhy;
+			}
+		}
+		else
+#endif
+		{
+			pCrd[1] = K1_TO_PHY(skb->data);
+			pCrd[2] = K1_TO_PHY(skb->data);
+		}
+
+		pCrd[6] = (unsigned int)skb;
+#if 0
+	    /*When encryption, it is necessary to consider when the packet size is greater than 200, and in tunnel mode (l2tpeth0),
+ 			before the packet length longer (+4), otherwise there will be untied.   */
+		if ((currAdapterPtr->isEncryptOrDecrypt==1) && (skb->len > 200) && !(skb->dev->name == NULL))
+		{
+			if(strcmp(skb->dev->name,"l2tpeth0") == 0)
+			{
+				pCrd[7] = ((skb->len+4) & (BIT_20 - 1)) | (cmdDescp->peLength.word & (~(BIT_22 - 1)));
+			}else{
+				pCrd[7] = ((skb->len) & (BIT_20 - 1)) | (cmdDescp->peLength.word & (~(BIT_22 - 1)));
+			}
+		}
+		else
+#endif
+		{
+			pCrd[7] = ((skb->len) & (BIT_20 - 1)) | (cmdDescp->peLength.word & (~(BIT_22 - 1)));
+		}
+
+	}
+	else
+	{
+		pCrd[1] = cmdDescp->srcAddr.phyAddr;
+		pCrd[2] = cmdDescp->srcAddr.phyAddr;
+		pCrd[6] = cmdDescp->userId;
+		pCrd[7] = cmdDescp->peLength.word;
+	}
+	pCrd[0] = cmdDescp->peCrtlStat.word;
+
+	//prevent from inconsistency of HW DMA and SW memory access
+	wmb();
+	iowrite32(1, pEip93RegBase + (PE_CD_COUNT >> 2)); //PE_CD_COUNT/4
+
+	//spin_unlock_irqrestore(&putlock, flags);
+
+	return 0; //success
+}
+
+/*_______________________________________________________________________
+**function name: mtk_packet_get
+**
+**description:
+*   get result descriptor from EIP93's Result Descriptor Ring.
+**parameters:
+*   resDescp -- point to the result handler that stores the needed
+*		info for the result descriptor.
+**global:
+*   none
+**return:
+*   0  -- EIP93 has no result yet.
+*   1  -- EIP93 has results ready.
+*   -1 -- the current result is wrong!
+**call:
+*   none
+**revision:
+*   1.Trey 20120209
+**_______________________________________________________________________*/
+static int
+mtk_packet_get(
+	eip93DescpHandler_t *resDescp
+)
+{
+	unsigned int *pRrd = pResRingBase;
+	unsigned int done1, done2, err_sts, PktCnt, timeCnt = 0;
+	unsigned long flags;
+	struct sk_buff *skb = NULL;
+	int retVal;
+
+	ipsecEip93Adapter_t *currAdapterPtr;
+	unsigned int *addrCurrAdapter;
+
+	spin_lock_irqsave(&getlock, flags);
+	PktCnt = ioread32(pEip93RegBase + (PE_RD_COUNT >> 2)) & (BIT_10 - 1); //PE_RD_COUNT/4
+
+	//don't wait for Crypto Engine in order to speed up!
+	if(PktCnt == 0)
+	{
+		spin_unlock_irqrestore(&getlock, flags);
+		return 0; //no result yet
+	}
+
+	if(resRingIdx == EIP93_RING_SIZE)
+	{
+		resRingIdx = 0;
+	}
+	pRrd += (resRingIdx << 3); //resRingIdx*8 (a resDescp has 8 words!)
+
+	while (1)
+	{
+
+		PktCnt = ioread32(pEip93RegBase + (PE_RD_COUNT >> 2)) & (BIT_10 - 1); //PE_RD_COUNT/4
+
+		resDescp->peCrtlStat.word 	= pRrd[0];
+		resDescp->userId		 	= pRrd[6];
+		resDescp->peLength.word 	= pRrd[7];
+		//the others are physical addresses, no need to be copied!
+		done1 = resDescp->peCrtlStat.bits.peReady;
+		done2 = resDescp->peLength.bits.peReady;
+		err_sts = resDescp->peCrtlStat.bits.errStatus;
+		resDescp->saAddr.phyAddr = pRrd[3];
+		if ((done1 == 1) && (done2 == 1))
+		{
+			if(unlikely(err_sts))
+			{
+				int cmdPktCnt = (ioread32(pEip93RegBase + (PE_CD_COUNT >> 2)) & (BIT_10 - 1));
+				skb = (struct sk_buff *)resDescp->userId;
+				addrCurrAdapter = (unsigned int *) &(skb->cb[36]);
+				currAdapterPtr = (ipsecEip93Adapter_t *)(*addrCurrAdapter);
+				printk("\n\n !PE Ring[%d] ErrCode=0x%x! status=%x rdn=%d cdn=%d encrypt=%d qlen=%d\n\n", resRingIdx, err_sts, ioread32(pEip93RegBase + (PE_CTRL_STAT >> 2)), PktCnt,\
+						cmdPktCnt,currAdapterPtr->isEncryptOrDecrypt, currAdapterPtr->skbQueue.qlen);
+				//for encryption/decryption case
+				//if (resDescp->peCrtlStat.bits.hashFinal == 0x1)
+				{
+#if defined (MCRYPTO_DBG)
+					if ((err_sts&0x1)==0x1)
+					{
+						{
+							int k;
+							int offset, alloc_size;
+							offset = DMAAlign-(u32)(skb->data)%DMAAlign;
+							printk("ICV[[");
+							for (k = 0; k < 12; k++)
+								printk("%02X ",skb->data[resDescp->peLength.bits.length-12+k+offset]);
+							printk("]]\n");
+						}
+					}
+#endif
+
+					if ((resDescp->userId>>31)&0x1)
+					{
+#if defined (BUFFER_MEMCPY)
+						addrCurrAdapter = (unsigned int *) &(skb->cb[36]);
+						currAdapterPtr = (ipsecEip93Adapter_t *)(*addrCurrAdapter);
+						if (pRrd[2]!=pRrd[1])
+						{
+							int offset, alloc_size;
+							u8* pData =  *(unsigned int *)&(skb->cb[40]);
+							offset = DMAAlign-(u32)(skb->data)%DMAAlign;
+							alloc_size = skb->end-skb->head+sizeof(struct skb_shared_info)+offset;
+#if defined (SKB_HEAD_SHIFT)
+#else
+							dma_unmap_single (NULL, pRrd[2], skb->len + currAdapterPtr->addedLen, PCI_DMA_FROMDEVICE);
+							kfree(pData);
+#endif
+						}
+#endif
+						kfree_skb(skb);
+					}
+					else
+						printk("resDescp->userId = 0x%x\n", resDescp->userId);
+				}
+				//else {
+
+				//}
+
+				retVal = -1;
+				break;
+			}
+			skb = (struct sk_buff *)resDescp->userId;
+#if defined (BUFFER_MEMCPY)
+			if((skb!=NULL)&&(resDescp->peCrtlStat.bits.hashFinal == 0x1))
+			{
+				addrCurrAdapter = (unsigned int *) &(skb->cb[36]);
+				currAdapterPtr = (ipsecEip93Adapter_t *)(*addrCurrAdapter);
+				if (pRrd[2]!=pRrd[1])
+				{
+#if defined (SKB_HEAD_SHIFT)
+					int offset, alloc_size;
+					offset = DMAAlign-(u32)(skb->data)%DMAAlign;
+					copy_data_head(skb, offset);
+#else
+					u8* pData =  *(unsigned int *)&(skb->cb[40]);
+					dma_cache_sync(NULL, pData, skb->len + currAdapterPtr->addedLen, DMA_FROM_DEVICE);
+					memcpy(skb->data, (u32)pData, resDescp->peLength.bits.length);
+					dma_unmap_single (NULL, pRrd[2], skb->len + currAdapterPtr->addedLen, PCI_DMA_FROMDEVICE);
+					kfree(pData);
+#endif
+				}
+
+			}
+#endif
+			retVal = 1;
+			break;
+		}
+		else
+		{
+			//if eip93 is done but the result is not ready yet, just reCkeckResult one more time!
+			if (timeCnt++ > 10)
+			{
+				printk("\n !wait eip93's result for too long! Drop it! \n");
+				printk("resRingIdx=%d\n",resRingIdx);
+				//if (resDescp->peCrtlStat.bits.hashFinal == 0x1)
+				{
+					skb = (struct sk_buff *)resDescp->userId;
+					if ((resDescp->userId>>31)&0x1)
+					{
+#if defined (BUFFER_MEMCPY)
+						addrCurrAdapter = (unsigned int *) &(skb->cb[36]);
+						currAdapterPtr = (ipsecEip93Adapter_t *)(*addrCurrAdapter);
+						if (pRrd[2]!=pRrd[1])
+						{
+							int offset, alloc_size;
+							u8* pData =  *(unsigned int *)&(skb->cb[40]);
+							offset = DMAAlign-(u32)(skb->data)%DMAAlign;
+							alloc_size = skb->end-skb->head+sizeof(struct skb_shared_info)+offset;
+#if defined (SKB_HEAD_SHIFT)
+#else
+							dma_unmap_single (NULL, pRrd[2], skb->len + currAdapterPtr->addedLen, PCI_DMA_FROMDEVICE);
+							kfree(pData);
+#endif
+						}
+#endif
+						kfree_skb(skb);
+					}
+					else
+						printk("resDescp->userId = 0x%x\n", resDescp->userId);
+				}
+
+				retVal = -1;
+				break;
+			}
+		}
+	} //end while(1)
+
+	//clear the peCrtlStat of the currrent resRingDescp, in case eip93 can't put the current result in resRingDescp on time!
+	pRrd[0] = 0;
+
+	wmb();
+	resRingIdx++;
+	iowrite32(1, pEip93RegBase + (PE_RD_COUNT >> 2)); //PE_RD_COUNT/4
+	spin_unlock_irqrestore(&getlock, flags);
+	return retVal;
+}
+
+
+static bool
+mtk_eip93CmdResCnt_check(
+	void
+)
+{
+	return (
+		((ioread32(pEip93RegBase + (PE_CD_COUNT >> 2)) & (BIT_10 - 1)) < EIP93_RING_SIZE) &&
+		((ioread32(pEip93RegBase + (PE_RD_COUNT >> 2)) & (BIT_10 - 1)) < (EIP93_RING_SIZE - EIP93_RING_BUFFER))
+	);
+}
+
+
+static unsigned int
+mtk_espSeqNum_get(
+	eip93DescpHandler_t *resHandler
+)
+{
+	saRecord_t *saRecord;
+	resHandler->saAddr.addr = (resHandler->saAddr.phyAddr|(0x5<<29));
+	saRecord = (saRecord_t *)resHandler->saAddr.addr;
+
+	return saRecord->saSeqNum[0];
+}
+/************************************************************************
+*              P U B L I C     F U N C T I O N S
+*************************************************************************
+*/
+void
+mtk_ipsec_init(
+	void
+)
+{
+	DMAAlign = 4;//dma_get_cache_alignment();
+	printk("== IPSEC Crypto Engine Driver : %s %s ==\n",__DATE__,__TIME__);
+	spin_lock_init(&putlock);
+	spin_lock_init(&getlock);
+	write_c0_config7((read_c0_config7()|(1<<8)));
+
+	ipsec_eip93_adapters_init();
+	ipsec_cryptoLock_init();
+
+	//function pointer init
+	ipsec_packet_put = mtk_packet_put;
+	ipsec_packet_get = mtk_packet_get;
+	ipsec_eip93CmdResCnt_check = mtk_eip93CmdResCnt_check;
+	ipsec_preComputeIn_cmdDescp_set = mtk_preComputeIn_cmdDescp_set;
+	ipsec_preComputeOut_cmdDescp_set = mtk_preComputeOut_cmdDescp_set;
+	ipsec_cmdHandler_cmdDescp_set = mtk_cmdHandler_cmdDescp_set;
+	ipsec_espNextHeader_set = mtk_espNextHeader_set;
+	ipsec_espNextHeader_get = mtk_espNextHeader_get;
+	ipsec_pktLength_get = mtk_pktLength_get;
+	ipsec_eip93HashFinal_get = mtk_eip93HashFinal_get;
+	ipsec_eip93UserId_get = mtk_eip93UserId_get;
+	ipsec_addrsDigestPreCompute_free = mtk_addrsDigestPreCompute_free;
+	ipsec_cmdHandler_free = mtk_cmdHandler_free;
+	ipsec_hashDigests_get = mtk_hashDigests_get;
+	ipsec_hashDigests_set = mtk_hashDigests_set;
+
+	ipsec_espSeqNum_get = mtk_espSeqNum_get;
+
+	//eip93 info init
+	cmdRingIdx = ioread32(pEip93RegBase + (PE_RING_PNTR >> 2)) & (BIT_10-1);
+	resRingIdx = (ioread32(pEip93RegBase + (PE_RING_PNTR >> 2)) >>16) & (BIT_10-1);
+#ifdef WORKQUEUE_BH
+	INIT_WORK(&mtk_interrupt_BH_result_wq, mtk_BH_handler_resultGet);
+#else
+	tasklet_init(&mtk_interrupt_BH_result_tsk, mtk_BH_handler_resultGet , 0);
+#endif
+	//eip93 interrupt mode init
+	Adapter_Interrupt_ClearAndEnable(IRQ_RDR_THRESH_IRQ);
+	Adapter_Interrupt_SetHandler(IRQ_RDR_THRESH_IRQ, mtk_interruptHandler_done);
+
+	//EndianSwap Setting for C.L.'s new POF for fix no_word_alignment  (put right b4 kick CryptoEngine)
+	iowrite32(0x00000700, pEip93RegBase + (PE_CONFIG >> 2));
+	iowrite32(0x00e400e4, pEip93RegBase + (PE_ENDIAN_CONFIG >> 2));
+
+}
+
+void mtk_BH_handler_resultGet(
+	unsigned long data
+)
+{
+	ipsec_BH_handler_resultGet();
+	Adapter_Interrupt_ClearAndEnable(IRQ_RDR_THRESH_IRQ);
+}
+
+static void mtk_interruptHandler_done(void)
+{
+#ifdef WORKQUEUE_BH
+	schedule_work(&mtk_interrupt_BH_result_wq);
+#else
+	tasklet_hi_schedule(&mtk_interrupt_BH_result_tsk);
+#endif
+}
+
+int copy_data_head(struct sk_buff *skb, int offset)
+{
+	unsigned int i;
+
+	if (skb_shinfo(skb)->nr_frags > 0)
+	{
+		printk("skb %08X has frags\n",skb);
+		return -1;
+	}
+	for(i=(unsigned int)(skb->data-1);i>=(unsigned int) skb->head;i--) {
+
+		*((unsigned char*)(i+offset)) = *((unsigned char*)(i));
+
+    }
+
+	skb->data += offset;
+
+	/* {transport,network,mac}_header and tail are relative to skb->head */
+	skb->tail	      += offset;
+	skb->transport_header += offset;
+	skb->network_header   += offset;
+	if (skb_mac_header_was_set(skb))
+		skb->mac_header += offset;
+	/* Only adjust this if it actually is csum_start rather than csum */
+	if (skb->ip_summed == CHECKSUM_PARTIAL)
+		skb->csum_start += 0;
+	skb->cloned   = 0;
+	skb->hdr_len  = 0;
+	skb->nohdr    = 0;
+
+	return 0;
+}
diff --git a/drivers/net/cryptoDriver/source/utils/mtk_arm.c b/drivers/net/cryptoDriver/source/utils/mtk_arm.c
new file mode 100755
index 0000000..0b5c4ec
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/utils/mtk_arm.c
@@ -0,0 +1,598 @@
+#include <asm/mach-ralink/rt_mmap.h>
+#include "mtk_baseDefs.h"        // uint8_t, IDENTIFIER_NOT_USED, etc.
+#include "mtk_hwAccess.h"         // HW access API
+#include "mtk_arm.h"       // the API we will implement
+#include "mtk_cEip93.h"         // configration options
+#include "mtk_armL0.h" // macros and functions to access EIP93 reg
+#include "mtk_internal.h"  // internal API
+
+#ifdef EIP93_STRICT_ARGS
+
+#define EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM \
+    EIP93_Status_t res = EIP93_STATUS_OK; \
+    EIP93_Device_t* Device_p = NULL; \
+    EIP93_ARM_Mode_t* ARM_p = NULL; \
+    EIP93_CHECK_POINTER(IOArea_p); \
+    Device_p = (EIP93_Device_t*)IOArea_p; \
+    ARM_p = &Device_p->extras.ARM_mode; \
+    IDENTIFIER_NOT_USED(ARM_p);
+
+#define EIP93_CHECK_ARM_IS_READY \
+    EIP93_CHECK_POINTER(Device_p); \
+    if (Device_p->CurrentMode != EIP93_MODE_ARM) \
+    { \
+        res = EIP93_ERROR_UNSUPPORTED_IN_THIS_STATE; \
+        goto FUNC_RETURN; \
+    }
+
+#else
+
+#define EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM \
+    EIP93_Status_t res = EIP93_STATUS_OK; \
+    EIP93_Device_t* Device_p = (EIP93_Device_t*)IOArea_p; \
+    EIP93_ARM_Mode_t* ARM_p = &Device_p->extras.ARM_mode; \
+    IDENTIFIER_NOT_USED(ARM_p);
+
+#define EIP93_CHECK_ARM_IS_READY
+
+#endif //EIP93_STRICT_ARGS
+
+#ifdef RT_EIP93_DRIVER
+#define VPint *(volatile unsigned int *)
+#include "mtk_csDriver.h"  //to include VDRIVER_INTERRUPTS macro
+#endif
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_WriteCB
+ * A write callback for the Ring Helper
+ */
+static int
+EIP93_WriteCB(
+        void * const CallbackParam1_p,
+        const int CallbackParam2,
+        const unsigned int WriteIndex,
+        const unsigned int WriteCount,
+    const unsigned int AvailableSpace,
+        const void * Descriptors_p,
+    const int DescriptorCount,
+        const unsigned DescriptorSkipCount)
+{
+    unsigned int nDescrSize;
+    unsigned int i;
+#ifdef RT_EIP93_DRIVER_DEBUG
+    unsigned int *p2;
+#endif
+    int nWritten = 0;
+
+    EIP93_IOArea_t * IOArea_p = (EIP93_IOArea_t *) CallbackParam1_p;
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_ARM_IS_READY;
+    EIP93_CHECK_POINTER(Descriptors_p);
+
+    nDescrSize = ARM_p->Settings.nDescriptorSize; //8 (words)
+
+    IDENTIFIER_NOT_USED(CallbackParam2);
+    //IDENTIFIER_NOT_USED(fKeepTogether);
+
+    /*** first we write all descriptors we can to CDR ***/
+
+    if (ARM_p->RingHelper.fSeparate) // separate rings
+    {
+        for(i = WriteIndex; i < WriteIndex + WriteCount; i++)
+        {
+            // write without checking ownership bits
+            EIP93_ARM_Level0_WriteDescriptor(
+                    ARM_p->CommandRingHandle,
+                    i*nDescrSize,
+                    ((const EIP93_ARM_CommandDescriptor_t *)Descriptors_p) +
+                    DescriptorSkipCount + nWritten);
+
+            nWritten++;
+        }
+    }
+    else // combined rings
+    {
+        for(i = WriteIndex; i < WriteIndex + WriteCount; i++)
+        {
+            // just always write it
+            EIP93_ARM_Level0_WriteDescriptor(
+                ARM_p->CommandRingHandle,
+                i*nDescrSize,
+                ((const EIP93_ARM_CommandDescriptor_t *)Descriptors_p) +
+                DescriptorSkipCount + nWritten);
+            nWritten++;
+        }
+    }
+
+    // now we call PreDMA to provide descriptors written for
+    // the EIP93 DMA Master
+    if (nWritten > 0)
+    {
+
+        HWPAL_DMAResource_PreDMA(ARM_p->CommandRingHandle,
+                                 WriteIndex*nDescrSize*4,
+                                 nWritten*nDescrSize*4);
+
+#ifdef RT_EIP93_DRIVER_DEBUG
+    p2 = (unsigned int*)(VPint(RALINK_CRYPTO_ENGINE_BASE+0x80) | (0xa0000000));
+    printk("\n[EIP93_WriteCB], CD_BASE:0x%p (B4 kcik PE):\n", p2);
+    printk("CD_Control:0x%08x\n", *p2);
+    printk("CD_SrcPktAddr:0x%08x\n", *(p2+1));
+    printk("CD_DstPktAddr:0x%08x\n", *(p2+2));
+    printk("CD_SADataAddr:0x%08x\n", *(p2+3));
+    printk("CD_SAStateAddr:0x%08x\n", *(p2+4));
+    printk("CD_SAStateAddr:0x%08x\n", *(p2+5));
+    printk("CD_UserIdAddr:0x%08x\n", *(p2+6));
+    printk("CD_Length:0x%08x\n", *(p2+7));
+    printk("\n");
+#endif
+
+#ifdef RT_EIP93_DRIVER
+    //EndianSwap Setting for C.L.'s new POF for fix no_word_alignment  (put right b4 kick CryptoEngine)
+		VPint(RALINK_CRYPTO_ENGINE_BASE+0x100) = 0x00000700;	//0x00030700;
+		VPint(RALINK_CRYPTO_ENGINE_BASE+0x1d0) = 0x00e400e4;
+#endif
+
+    EIP93_Write32_PE_CD_COUNT(Device_p->Device,(uint32_t)nWritten);
+
+    }
+
+    goto FUNC_RETURN;
+FUNC_RETURN:
+    if (res)
+    {
+        return -res;
+    }
+    else
+    {
+        return nWritten;
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ReadCB
+ * A read callback for the Ring Helper
+ */
+static int
+EIP93_ReadCB(
+        void * const CallbackParam1_p,
+        const int CallbackParam2,
+        const unsigned int ReadIndex,
+        const unsigned int ReadLimit,
+        void * Descriptors_p,
+        const unsigned int DescriptorSkipCount)
+{
+    unsigned int nDescrSize;
+    unsigned int i;
+    int nRead = 0;
+    EIP93_IOArea_t * const IOArea_p = (EIP93_IOArea_t *) CallbackParam1_p;
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_ARM_IS_READY;
+    EIP93_CHECK_POINTER(Descriptors_p);
+
+    IDENTIFIER_NOT_USED(CallbackParam2);
+
+    nDescrSize = ARM_p->Settings.nDescriptorSize;
+    // now we read all descriptors we can from RDR
+
+    for(i = ReadIndex; i < ReadIndex + ReadLimit; i++)
+    {
+        EIP93_ARM_ResultDescriptor_t * CurrentResultDesc_p =
+            ((EIP93_ARM_ResultDescriptor_t *)Descriptors_p) +
+            DescriptorSkipCount + nRead;
+
+        // first we call PostDMA to obtain descriptors to be read from
+        // the EIP93 DMA Master
+        HWPAL_DMAResource_PostDMA(ARM_p->ResultRingHandle,
+                                  i*nDescrSize*4,
+                                  nDescrSize*4);
+
+        // read it if ready
+        if (EIP93_ARM_Level0_ReadDescriptor_IfReady(
+                  CurrentResultDesc_p,
+                  ARM_p->ResultRingHandle,
+                  i*nDescrSize))
+        {
+
+            // just clear this descriptor
+            EIP93_ARM_Level0_ClearDescriptor(
+                    ARM_p->ResultRingHandle,
+                    i*nDescrSize);
+
+            // make sure our next "PostDMA" does not undo this
+            HWPAL_DMAResource_PreDMA(
+                    ARM_p->ResultRingHandle,
+                    i*nDescrSize*4,
+                    4);
+
+#ifdef EIP93_ARM_NUM_OF_DESC_PADDING_WORDS
+            CurrentResultDesc_p->fPaddingWordValuesAreValid =
+                !ARM_p->RingHelper.fSeparate;
+#endif //EIP93_ARM_NUM_OF_DESC_PADDING_WORDS
+
+            nRead++;
+
+        }
+        else
+        {
+            break; // for
+        }
+    }
+
+
+    if (nRead > 0)
+    {
+         EIP93_Write32_PE_RD_COUNT(Device_p->Device,(uint32_t)nRead);
+
+#ifdef RT_EIP93_DRIVER
+         //clear ResultInterrupt when PE_RD_COUNT==0
+        if(VPint(RALINK_CRYPTO_ENGINE_BASE+0x94)==0)
+                VPint(RALINK_CRYPTO_ENGINE_BASE+0x204) = 2;
+#endif
+    }
+
+    goto FUNC_RETURN;
+FUNC_RETURN:
+    if (res)
+    {
+        return -res;
+    }
+    else
+    {
+        return nRead;
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_StatusCB
+ * A status callback for the Ring Helper
+ */
+
+static int
+EIP93_StatusCB(
+        void * const CallbackParam1_p,
+        const int CallbackParam2,
+        int * const DeviceReadPos_p)
+{
+    uint16_t CmdIndex;
+    uint16_t ResIndex;
+
+    EIP93_IOArea_t * IOArea_p = (EIP93_IOArea_t *) CallbackParam1_p;
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_ARM_IS_READY;
+    IDENTIFIER_NOT_USED(CallbackParam2);
+
+    EIP93_Read32_PE_RING_PNTR(Device_p->Device,
+            (uint16_t *)&CmdIndex,
+            (uint16_t *)&ResIndex);
+    *DeviceReadPos_p = (int)CmdIndex;
+
+
+    goto FUNC_RETURN;
+FUNC_RETURN:
+    return 0;
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_Activate
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_ARM_Activate(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_ARM_Settings_t * const Settings_p,
+        const EIP93_ARM_RingMemory_t * const Ring_p)
+{
+    unsigned int RingSizeInDescr = 0;
+    bool fEnableSwap_PD = false;
+    bool fEnableSwap_SA = false;
+    bool fEnableSwap_Data = false;
+
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_DEVICE_IS_READY;
+    EIP93_CHECK_POINTER(Settings_p);
+    EIP93_CHECK_POINTER(Ring_p);
+
+
+    EIP93_CHECK_INT_INRANGE(
+            Settings_p->nDescriptorDoneCount,
+            EIP93_MIN_DESC_DONE_COUNT,
+            EIP93_MAX_DESC_DONE_COUNT);
+
+    EIP93_CHECK_INT_INRANGE(
+            Settings_p->nDescriptorPendingCount,
+            EIP93_MIN_DESC_PENDING_COUNT,
+            EIP93_MAX_DESC_PENDING_COUNT);
+
+    EIP93_CHECK_INT_INRANGE(
+            Settings_p->nDescriptorDoneTimeout,
+            EIP93_MIN_TIMEOUT_COUNT,
+            EIP93_MAX_TIMEOUT_COUNT);
+
+    EIP93_CHECK_INT_INRANGE(
+            Settings_p->nPEInputThreshold,
+            EIP93_MIN_PE_INPUT_THRESHOLD,
+            EIP93_MAX_PE_INPUT_THRESHOLD);
+
+    EIP93_CHECK_INT_INRANGE(
+            Settings_p->nPEOutputThreshold,
+            EIP93_MIN_PE_OUTPUT_THRESHOLD,
+            EIP93_MAX_PE_OUTPUT_THRESHOLD);
+
+    EIP93_CHECK_INT_INRANGE(
+            Settings_p->nDescriptorSize,
+            EIP93_MIN_PE_DESCRIPTOR_SIZE,
+            EIP93_MAX_PE_DESCRIPTOR_SIZE);
+
+      // first we configure the Ring Helper
+
+    ARM_p->RingHelperCallbacks.WriteFunc_p = &EIP93_WriteCB;
+    ARM_p->RingHelperCallbacks.ReadFunc_p = &EIP93_ReadCB;
+    ARM_p->RingHelperCallbacks.StatusFunc_p = &EIP93_StatusCB;
+    ARM_p->RingHelperCallbacks.CallbackParam1_p = IOArea_p;
+    ARM_p->RingHelperCallbacks.CallbackParam2 = 0;
+
+    RingSizeInDescr = Ring_p->RingSizeInWords / Settings_p->nDescriptorSize;
+
+    EIP93_CHECK_INT_INRANGE(
+            RingSizeInDescr,
+            EIP93_MIN_PE_RING_SIZE,
+            EIP93_MAX_PE_RING_SIZE);
+
+    RingHelper_Init(&ARM_p->RingHelper,
+                &ARM_p->RingHelperCallbacks,
+                Ring_p->fSeparateRings,
+                RingSizeInDescr,
+                RingSizeInDescr);
+
+
+    // now we initialize the EIP PE and ring registers
+
+    ARM_p->CommandRingHandle = Ring_p->CommandRingHandle;
+    EIP93_Write32_PE_CDR_BASE(Device_p->Device,
+                              Ring_p->CommandRingAddr.Addr);
+
+    if(Ring_p->fSeparateRings)
+    {
+        ARM_p->ResultRingHandle  = Ring_p->ResultRingHandle;
+        EIP93_Write32_PE_RDR_BASE(Device_p->Device,
+                                  Ring_p->ResultRingAddr.Addr);
+    }
+    else
+    {
+        ARM_p->ResultRingHandle  = Ring_p->CommandRingHandle;
+        EIP93_Write32_PE_RDR_BASE(Device_p->Device,
+                                  Ring_p->CommandRingAddr.Addr);
+    }
+
+    EIP93_Write32_PE_RING_SIZE(
+            Device_p->Device,
+            (uint16_t)Settings_p->nDescriptorSize,
+            //(uint16_t)RingSizeInDescr);
+            (uint16_t)RingSizeInDescr -1); /*for integration*/
+
+    EIP93_Write32_PE_RING_THRESH(
+            Device_p->Device,
+            (uint16_t) Settings_p->nDescriptorDoneCount,
+            (uint16_t) Settings_p->nDescriptorPendingCount,
+        (uint16_t) Settings_p->nDescriptorDoneTimeout);
+
+    EIP93_Write32_PE_IO_THRESHOLD(Device_p->Device,
+                                 (uint16_t) Settings_p->nPEInputThreshold,
+                                  (uint16_t)Settings_p->nPEOutputThreshold);
+
+
+
+    // prepare the ring buffers
+
+    // Initialize all descriptors with zero for command ring
+    EIP93_ARM_Level0_ClearAllDescriptors(
+            ARM_p->CommandRingHandle,
+            Settings_p->nDescriptorSize,
+            RingSizeInDescr);
+
+
+    // Call PreDMA to make sure engine sees it
+    HWPAL_DMAResource_PreDMA(ARM_p->CommandRingHandle,
+                             0,
+                             Ring_p->RingSizeInWords*4);
+
+    if(Ring_p->fSeparateRings)
+    {
+        EIP93_ARM_Level0_ClearAllDescriptors(
+                ARM_p->ResultRingHandle,
+                Settings_p->nDescriptorSize,
+                RingSizeInDescr);
+
+        // we do PreDMA for the whole RDR buffer, to make sure
+        // the EIP93 DMA Master gets the full control over the buffer
+        // (for instance, dirty cache lines are flushed now,
+        // so they will not overwrite possible new result descriptors
+        // written by EIP93 Packet Engine later)
+        HWPAL_DMAResource_PreDMA(ARM_p->ResultRingHandle,
+                                 0,
+                                 Ring_p->RingSizeInWords*4);
+    }
+
+#ifdef EIP93_ENABLE_SWAP_PD
+        fEnableSwap_PD = true;
+#endif //EIP93_ENABLE_SWAP_PD
+#ifdef EIP93_ENABLE_SWAP_SA
+        fEnableSwap_SA = true;
+#endif //EIP93_ENABLE_SWAP_SA
+#ifdef EIP93_ENABLE_SWAP_DATA
+        fEnableSwap_Data = true;
+#endif //EIP93_ENABLE_SWAP_DATA
+
+
+
+    // now we initizalize and start up the PE
+
+    EIP93_Write32_PE_CFG(Device_p->Device,
+                             0, // Rst PE: no
+                             0, // Reset PDR: no
+                             3, // ARM mode on
+                             fEnableSwap_PD,
+                             fEnableSwap_SA,
+                             fEnableSwap_Data,
+                             1, // PDR Update is on
+                             0); // target mode swap off
+
+
+    // now PE is running and we are ready to accept command descriptors
+    // and process packet data
+
+    ARM_p->Settings = *Settings_p;
+
+    Device_p->CurrentMode = EIP93_MODE_ARM;
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_FinalizeSA
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_ARM_FinalizeSA(
+        EIP93_IOArea_t * const IOArea_p,
+        const HWPAL_DMAResource_Handle_t SADataHandle)
+{
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_ARM_IS_READY;
+    EIP93_CHECK_HANDLE(SADataHandle);
+
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_PacketPut
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_ARM_PacketPut(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_ARM_CommandDescriptor_t *  CmdDescriptors_p,
+        const unsigned int CmdDescriptorCount,
+        unsigned int * const DoneCount_p)
+{
+    uint32_t CDtodoCnt;
+    uint16_t DescriptorOffset;
+    uint16_t RingSizeInDescriptor;
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_ARM_IS_READY;
+    EIP93_CHECK_POINTER(CmdDescriptors_p);
+    EIP93_CHECK_POINTER(DoneCount_p);
+
+    EIP93_Read32_PE_CD_COUNT(
+            Device_p->Device,
+        &CDtodoCnt);
+    EIP93_Read32_PE_RING_SIZE(
+            Device_p->Device,
+            &DescriptorOffset,
+            &RingSizeInDescriptor);
+
+
+    if(CDtodoCnt < (uint32_t)RingSizeInDescriptor)
+    {
+        *DoneCount_p = RingHelper_Put(
+                               &ARM_p->RingHelper,
+                               CmdDescriptors_p,
+                               CmdDescriptorCount);
+    }
+    else
+    {
+        *DoneCount_p = 0;
+    }
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_PacketGet
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_ARM_PacketGet(
+        EIP93_IOArea_t * const IOArea_p,
+        EIP93_ARM_ResultDescriptor_t *  ResDescriptors_p,
+        const unsigned int ResDescriptorLimit,
+        unsigned int * const DoneCount_p)
+{
+    uint32_t DoneCnt=0;
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_ARM_IS_READY;
+    EIP93_CHECK_POINTER(ResDescriptors_p);
+    EIP93_CHECK_POINTER(DoneCount_p);
+
+#ifndef VDRIVER_INTERRUPTS
+#ifdef RT_EIP93_DRIVER
+/* When EIP93 receives a big packet, it can't provide result packet
+ * right away. So we have to poll until EIP93 provides the result
+ * packet. The polling mechanism has to come with the spinlock
+ * "eip93_lock", otherwise the polling will fail on SMP environment.
+ */
+    while(DoneCnt==0)
+        EIP93_Read32_PE_RD_COUNT(Device_p->Device,&DoneCnt);
+#else
+    EIP93_Read32_PE_RD_COUNT(Device_p->Device,&DoneCnt);
+#endif
+
+#else
+    EIP93_Read32_PE_RD_COUNT(Device_p->Device,&DoneCnt);
+#endif
+
+    if(DoneCnt)
+    {
+    *DoneCount_p = RingHelper_Get(
+                       &ARM_p->RingHelper,
+                       -1,                 /* ReadyCount we don't know*/
+                       ResDescriptors_p,
+                       ResDescriptorLimit);
+     }
+     else
+     {
+      *DoneCount_p = 0;
+     }
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ARM_PacketExternalGet
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_ARM_PacketExternalGet(
+        EIP93_IOArea_t * const IOArea_p,
+        const unsigned int ExternalDoneCount)
+{
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_ARM;
+    EIP93_CHECK_ARM_IS_READY;
+
+    #if 0
+    RingHelper_Notify(
+            &ARM_p->RingHelper,
+            ExternalDoneCount);
+    #endif
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
diff --git a/drivers/net/cryptoDriver/source/utils/mtk_dmaBufHelper.c b/drivers/net/cryptoDriver/source/utils/mtk_dmaBufHelper.c
new file mode 100755
index 0000000..9457206
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/utils/mtk_dmaBufHelper.c
@@ -0,0 +1,440 @@
+
+#include "mtk_baseDefs.h"
+#include "mtk_dmaBuf.h"
+#include "mtk_hwDmaAccess.h"
+#include "mtk_cLib.h"               // memcmp
+#include "mtk_AdapterInternal.h"
+
+#ifndef ADAPTER_USER_DOMAIN_BUILD
+// kernel domain headers.
+#include <linux/slab.h>         // kmalloc
+#include <linux/hardirq.h>      // in_atomic
+#include <linux/dma-mapping.h>  // dma_get_cache_alignment
+#else
+// user domain headers
+#include <stdlib.h>              // malloc
+#endif  // ADAPTER_USER_DOMAIN_BUILD
+
+// to check DMAResource record consistency
+#define ADAPTER_DMABUF_MAGIC 0xD71A64
+
+#define ADAPTER_DMABUF_MEMORYBANK_INTERNALLOC 42
+
+const DMABuf_Handle_t Adapter_DMABuf_NullHandle = { 0 };
+
+#ifdef RT_EIP93_DRIVER
+#define   K1_TO_PHYSICAL(x) (((u32)(x)) & 0x1fffffff)
+#endif
+
+/*----------------------------------------------------------------------------
+ * Adapter_DMABuf_IsSameHandle
+ */
+bool
+Adapter_DMABuf_IsSameHandle(
+        const DMABuf_Handle_t * const Handle1_p,
+        const DMABuf_Handle_t * const Handle2_p)
+{
+    if (memcmp(Handle1_p, Handle2_p, sizeof(DMABuf_Handle_t)) == 0)
+        return true;
+
+    return false;
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_DMABuf_IsValidHandle
+ */
+bool
+Adapter_DMABuf_IsValidHandle(
+        DMABuf_Handle_t Handle)
+{
+    HWPAL_DMAResource_Handle_t DMAHandle;
+    HWPAL_DMAResource_Record_t * Rec_p;
+
+    if (Handle.p == NULL)
+        return false;
+
+    DMAHandle = Adapter_DMABuf_Handle2DMAResourceHandle( Handle);
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(DMAHandle);
+
+    if (Rec_p == NULL)
+        return false;
+
+    if (Rec_p->Magic != ADAPTER_DMABUF_MAGIC)
+        return false;
+
+    return true;
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_DMABuf_Handle2DMAResourceHandle
+ */
+HWPAL_DMAResource_Handle_t
+Adapter_DMABuf_Handle2DMAResourceHandle(
+        DMABuf_Handle_t Handle)
+{
+    return (HWPAL_DMAResource_Handle_t)Handle.p;
+}
+
+
+/*----------------------------------------------------------------------------
+ * Adapter_DMABuf_IsForeignAllocated
+ */
+bool
+Adapter_DMABuf_IsForeignAllocated(
+        DMABuf_Handle_t Handle)
+{
+    HWPAL_DMAResource_Handle_t DMAHandle =
+            Adapter_DMABuf_Handle2DMAResourceHandle(Handle);
+
+    if (HWPAL_DMAResource_IsValidHandle(DMAHandle))
+    {
+        HWPAL_DMAResource_Record_t * const Rec_p =
+                HWPAL_DMAResource_Handle2RecordPtr(DMAHandle);
+
+        // Buffer is allocated using DMABuf_Alloc()
+        if (Rec_p->alloc.MemoryBank == ADAPTER_DMABUF_MEMORYBANK_INTERNALLOC)
+            return false;
+    }
+
+    // buffer is not allocated using DMABuf_Alloc(), hence Foreign
+    return true;
+}
+
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Alloc
+ *
+ * Allocate a buffer of requested size that can be used for device DMA.
+ *
+ * RequestedProperties
+ *     Requested properties of the buffer that will be allocated, including
+ *     the size, start address alignment, etc. See above.
+ *
+ * Buffer_p (output)
+ *     Pointer to the memory location where the address of the buffer will be
+ *     written by this function when allocation is successful. This address
+ *     can then be used to access the driver on the host in the domain of the
+ *     driver.
+ *
+ * Handle_p (output)
+ *     Pointer to the memory location when the handle will be returned.
+ *
+ * Return Values
+ *     DMABUF_STATUS_OK: Success, Handle_p was written.
+ *     DMABUF_ERROR_BAD_ARGUMENT
+ *     DMABUF_ERROR_OUT_OF_MEMORY: Failed to allocate a buffer.
+ */
+DMABuf_Status_t
+DMABuf_Alloc(
+        const DMABuf_Properties_t RequestedProperties,
+        DMABuf_HostAddress_t * const Buffer_p,
+        DMABuf_Handle_t * const Handle_p)
+{
+    HWPAL_DMAResource_Handle_t DMAHandle;
+    HWPAL_DMAResource_Record_t * Rec_p;
+
+#ifndef ADAPTER_USER_DOMAIN_BUILD
+    unsigned int AlignTo = dma_get_cache_alignment();
+#else
+    unsigned int AlignTo = 1; // Not needed in user domain
+#endif  // ADAPTER_USER_DOMAIN_BUILD
+
+
+    if (Handle_p == NULL ||
+        Buffer_p == NULL)
+    {
+        return DMABUF_ERROR_BAD_ARGUMENT;
+    }
+
+    // initialize the output parameters
+    Handle_p->p = NULL;
+    Buffer_p->p = NULL;
+
+    // validate the properties
+    if (RequestedProperties.Size == 0)
+        return DMABUF_ERROR_BAD_ARGUMENT;
+
+    // we support up to 1 megabyte buffers
+    if (RequestedProperties.Size >= 1*1024*1024)
+        return DMABUF_ERROR_BAD_ARGUMENT;
+
+    // alignment must be a power of two, up to 32
+    if (RequestedProperties.Alignment != 1 &&
+        RequestedProperties.Alignment != 2 &&
+        RequestedProperties.Alignment != 4 &&
+        RequestedProperties.Alignment != 8 &&
+        RequestedProperties.Alignment != 16 &&
+        RequestedProperties.Alignment != 32 &&
+        RequestedProperties.Alignment != 64 &&
+        RequestedProperties.Alignment != 128)
+    {
+        return DMABUF_ERROR_BAD_ARGUMENT;
+    }
+
+    if (RequestedProperties.Alignment > AlignTo)
+        AlignTo = RequestedProperties.Alignment;
+
+    // we only support one memory bank: number zero
+    if (RequestedProperties.Bank != 0)
+        return DMABUF_ERROR_BAD_ARGUMENT;
+
+    // create a record
+    DMAHandle = HWPAL_DMAResource_Create();
+    if (DMAHandle == NULL)
+        return DMABUF_ERROR_OUT_OF_MEMORY;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(DMAHandle);
+    if (Rec_p == NULL)
+    {
+        // panic...
+        goto DESTROY_HANDLE;
+    }
+
+    // allocate the memory
+    {
+        unsigned int n;
+        void * p;
+#ifdef RT_EIP93_DRIVER
+        dma_addr_t dma_handle;
+#endif
+        n = AlignTo + RequestedProperties.Size;
+
+        {
+#ifndef ADAPTER_USER_DOMAIN_BUILD
+#ifdef RT_EIP93_DRIVER
+            int flags=0;
+#else
+            int flags = GFP_DMA;
+#endif
+
+            if (in_atomic())
+                flags |= GFP_ATOMIC;    // non-sleepable
+            else
+                flags |= GFP_KERNEL;    // sleepable
+
+#ifdef RT_EIP93_DRIVER
+            p = dma_alloc_coherent(NULL, n, &dma_handle, flags);
+#else
+            p = kmalloc(n, flags);
+#endif
+#else
+            p = malloc(n);
+#endif  // ADAPTER_USER_DOMAIN_BUILD
+        }
+
+        if (p == NULL)
+            goto DESTROY_HANDLE;
+
+        // fill in the record fields
+        Rec_p->Magic = ADAPTER_DMABUF_MAGIC;
+
+        Rec_p->alloc.AllocatedAddr_p = p;
+        Rec_p->alloc.AllocatedSize = n;
+        Rec_p->alloc.MemoryBank = ADAPTER_DMABUF_MEMORYBANK_INTERNALLOC;
+        Rec_p->alloc.AllocatorRef = ADAPTER_DMABUF_ALLOCATORREF_KMALLOC;
+        // used by AddrTrans
+
+        Rec_p->host.fCached = true;
+        Rec_p->host.Alignment = (uint8_t)AlignTo;
+        Rec_p->host.HostAddr_p = p;
+        Rec_p->host.BufferSize = RequestedProperties.Size;
+        // note: not the allocated "n"
+
+        // align the address
+        {
+            // create an alignment mask
+            unsigned int Mask = AlignTo - 1;
+            unsigned int A = (unsigned int)Rec_p->alloc.AllocatedAddr_p;
+            unsigned int MaskedBits = A & Mask;
+            if (MaskedBits != 0)
+            {
+                // calculate the alignment error
+                unsigned int Err = AlignTo - MaskedBits;
+                uint8_t * p = Rec_p->host.HostAddr_p;
+                p += Err;
+                Rec_p->host.HostAddr_p = p;
+            }
+        }
+    }
+
+    // set the output parameters
+    Handle_p->p = DMAHandle;
+    Buffer_p->p = Rec_p->host.HostAddr_p;
+
+    return DMABUF_STATUS_OK;
+
+DESTROY_HANDLE:
+    HWPAL_DMAResource_Destroy(DMAHandle);
+    return DMABUF_ERROR_OUT_OF_MEMORY;
+}
+EXPORT_SYMBOL(DMABuf_Alloc); /*for integration*/
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Register
+ *
+ * This function must be used to register an "alien" buffer that was allocated
+ * somewhere else. The caller guarantees that this buffer can be used for DMA.
+ *
+ * ActualProperties (input)
+ *     Properties that describe the buffer that is being registered.
+ *
+ * Buffer_p (input)
+ *     Pointer to the buffer. This pointer must be valid to use on the host
+ *     in the domain of the driver.
+ *
+ * Alternative_p (input)
+ *     Some allocators return two addresses. This parameter can be used to
+ *     pass this second address to the driver. The type is pointer to ensure
+ *     it is always large enough to hold a system address, also in LP64
+ *     architecture. Set to NULL if not used.
+ *
+ * AllocatorRef (input)
+ *     Number to describe the source of this buffer. The exact numbers
+ *     supported is implementation specitic. This provides some flexibility
+ *     for a specific implementation to support a number of "alien" buffers
+ *     from different allocator and propertly interpret and use the
+ *     Alternative_p parameter when translating the address to the device
+ *     memory map. Set to zero if not used.
+ *
+ * Handle_p (output)
+ *     Pointer to the memory location when the handle will be returned.
+ *
+ * Return Values
+ *     DMABUF_STATUS_OK: Success, Handle_p was written.
+ *     DMABUF_ERROR_BAD_ARGUMENT
+ */
+DMABuf_Status_t
+DMABuf_Register(
+        const DMABuf_Properties_t ActualProperties,
+        void * Buffer_p,
+        void * Alternative_p,
+        const char AllocatorRef,
+        DMABuf_Handle_t * const Handle_p)
+{
+    HWPAL_DMAResource_Handle_t DMAHandle;
+    HWPAL_DMAResource_Record_t * Rec_p;
+
+    if (Handle_p == NULL ||
+        Buffer_p == NULL)
+    {
+        return DMABUF_ERROR_BAD_ARGUMENT;
+    }
+
+    // initialize the output parameter
+    Handle_p->p = NULL;
+
+    // validate the properties
+    if (ActualProperties.Size == 0)
+        return DMABUF_ERROR_BAD_ARGUMENT;
+
+    // alignment must be a power of two, up to 32
+    if (ActualProperties.Alignment != 1 &&
+        ActualProperties.Alignment != 2 &&
+        ActualProperties.Alignment != 4 &&
+        ActualProperties.Alignment != 8 &&
+        ActualProperties.Alignment != 16 &&
+        ActualProperties.Alignment != 32)
+    {
+        return DMABUF_ERROR_BAD_ARGUMENT;
+    }
+
+    if (ActualProperties.Bank == ADAPTER_DMABUF_MEMORYBANK_INTERNALLOC)
+        return DMABUF_ERROR_BAD_ARGUMENT;
+
+    // create a record
+    DMAHandle = HWPAL_DMAResource_Create();
+    if (DMAHandle == NULL)
+        return DMABUF_ERROR_OUT_OF_MEMORY;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(DMAHandle);
+    if (Rec_p == NULL)
+    {
+        // panic...
+        goto DESTROY_HANDLE;
+    }
+
+    // allocate the memory
+    {
+        // fill in the record fields
+        Rec_p->Magic = ADAPTER_DMABUF_MAGIC;
+
+        Rec_p->alloc.AllocatedAddr_p = Buffer_p;
+        Rec_p->alloc.AllocatedSize = ActualProperties.Size;
+        Rec_p->alloc.Alternative_p = Alternative_p;
+        Rec_p->alloc.AllocatorRef = AllocatorRef;
+        Rec_p->alloc.MemoryBank = ActualProperties.Bank;
+
+        Rec_p->host.fCached = ActualProperties.fCached;
+
+        Rec_p->host.Alignment = ActualProperties.Alignment;
+        Rec_p->host.HostAddr_p = Rec_p->alloc.AllocatedAddr_p;
+        Rec_p->host.BufferSize = Rec_p->alloc.AllocatedSize;
+    }
+
+    // set the output parameters
+    Handle_p->p = DMAHandle;
+
+    return DMABUF_STATUS_OK;
+
+DESTROY_HANDLE:
+    HWPAL_DMAResource_Destroy(DMAHandle);
+    return DMABUF_ERROR_OUT_OF_MEMORY;
+}
+EXPORT_SYMBOL(DMABuf_Register); /*for integration*/
+
+/*----------------------------------------------------------------------------
+ * DMABuf_Release
+ *
+ * This function will close the handle that was returned by DMABuf_Alloc or
+ * DMABuf_Register, meaning it must not be used anymore.
+ * If the buffer was allocated through DMABuf_Alloc, this function will also
+ * free the buffer, meaning it must not be accessed anymore.
+ *
+ * Handle (input)
+ *     The handle that may be released.
+ *
+ * Return Values
+ *     DMABUF_STATUS_OK
+ *     DMABUF_ERROR_INVALID_HANDLE
+ */
+DMABuf_Status_t
+DMABuf_Release(
+        DMABuf_Handle_t Handle)
+{
+    HWPAL_DMAResource_Handle_t DMAHandle = Handle.p;
+
+    if (HWPAL_DMAResource_IsValidHandle(DMAHandle))
+    {
+        HWPAL_DMAResource_Record_t * Rec_p;
+
+        Rec_p = HWPAL_DMAResource_Handle2RecordPtr(DMAHandle);
+
+        if (Rec_p->alloc.MemoryBank == ADAPTER_DMABUF_MEMORYBANK_INTERNALLOC)
+        {
+#ifndef ADAPTER_USER_DOMAIN_BUILD
+#ifdef RT_EIP93_DRIVER
+            dma_free_coherent(NULL, Rec_p->alloc.AllocatedSize, Rec_p->alloc.AllocatedAddr_p, K1_TO_PHYSICAL(Rec_p->alloc.AllocatedAddr_p));
+#else
+            kfree(Rec_p->alloc.AllocatedAddr_p);
+#endif
+#else
+            free(Rec_p->alloc.AllocatedAddr_p);
+#endif  // ADAPTER_USER_DOMAIN_BUILD
+            Rec_p->alloc.AllocatedAddr_p = NULL;
+        }
+
+        Rec_p->Magic = 0;
+
+        HWPAL_DMAResource_Destroy(DMAHandle);
+
+        return DMABUF_STATUS_OK;
+    }
+
+    return DMABUF_ERROR_INVALID_HANDLE;
+}
+EXPORT_SYMBOL(DMABuf_Release); /*for integration*/
+
+/* end of file adapter_dmabuf.c */
diff --git a/drivers/net/cryptoDriver/source/utils/mtk_hwDevice.c b/drivers/net/cryptoDriver/source/utils/mtk_hwDevice.c
new file mode 100755
index 0000000..c9ae267
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/utils/mtk_hwDevice.c
@@ -0,0 +1,869 @@
+#include <asm/mach-ralink/rt_mmap.h>
+#include "mtk_cHwPci.h"
+#include "mtk_baseDefs.h"
+#include "mtk_hwAccess.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/moduleparam.h>
+
+#define HWPAL_FLAG_READ     BIT_0   // 1
+#define HWPAL_FLAG_WRITE    BIT_1   // 2
+#define HWPAL_FLAG_SWAP     BIT_2   // 4
+#define HWPAL_FLAG_HA       BIT_5   // 32
+
+// Device administration structure
+typedef struct
+{
+#ifdef HWPAL_DEVICE_MAGIC
+    // Magic value for detecting valid handles
+    unsigned int ValidHandle;
+#endif
+
+    // Name string used in HWPAL_Device_Find
+    const char * DeviceName_p;
+
+    // device offset range inside PCI device
+    unsigned int StartByteOffset;
+    unsigned int LastByteOffset;
+
+    char Flags;
+} HWPAL_Device_Administration_t;
+
+#define HWPAL_MAGIC_PCICONFIGSPACE  0xFF434647      // 43 46 47 = C F G
+
+// the cs_hwpal_linux_pci_x86.h file defines a HWPAL_DEVICES that
+// depends on the following HWPAL_DEVICE_ADD
+#ifdef HWPAL_DEVICE_MAGIC
+#define HWPAL_DEVICE_ADD(_name, _start, _last, _flags) \
+        { HWPAL_DEVICE_MAGIC, _name, _start, _last, _flags }
+#else
+#define HWPAL_DEVICE_ADD(_name, _start, _last, _flags) \
+        { _name, _start, _last, _flags }
+#endif
+
+static const HWPAL_Device_Administration_t HWPAL_Devices[] =
+{
+    HWPAL_DEVICE_ADD(
+        "PCI_CONFIG_SPACE",
+        HWPAL_MAGIC_PCICONFIGSPACE,
+        HWPAL_MAGIC_PCICONFIGSPACE + 1024,
+        HWPAL_PCI_CONFIG_FLAGS),
+    HWPAL_DEVICES
+};
+
+// number of devices supported calculated on HWPAL_DEVICES defined
+// in cs_linux_pci_x86.h
+#define DEVICE_COUNT \
+        (sizeof(HWPAL_Devices) \
+         / sizeof(HWPAL_Device_Administration_t))
+
+
+#ifdef RT_EIP93_DRIVER
+//the base address of Crypto Engine registers
+static uint32_t * HWPAL_MappedBaseAddr_p = (uint32_t *)RALINK_CRYPTO_ENGINE_BASE;
+#else
+// virtual address returned by ioremap()
+static uint32_t * HWPAL_MappedBaseAddr_p = NULL;
+#endif
+
+
+// declarations native to Linux kernel
+static struct pci_dev * HWPAL_PCI_Device_p = NULL;
+
+// checks that byte offset is in range as per the
+#define IS_INVALID_OFFSET(_ofs, _devp) \
+    (((_devp)->StartByteOffset + (_ofs) > (_devp)->LastByteOffset) || \
+     (((_ofs) & 3) != 0))
+
+#ifdef HWPAL_DEVICE_MAGIC
+
+// checks that device handle is valid
+#define IS_INVALID_DEVICE(_devp) \
+    ((_devp) < HWPAL_Devices || \
+     (_devp) >= HWPAL_Devices + DEVICE_COUNT || \
+     (_devp)->ValidHandle != HWPAL_DEVICE_MAGIC)
+
+#endif /* HWPAL_DEVICE_MAGIC */
+
+#ifdef RT_EIP93_DRIVER
+/*----------------------------------------------------------------------------
+ * rt_dump_register
+ *
+ * This function dumps an Crypto Engine's register.
+ * (define RT_DUMP_REGISTER in cs_hwpal_linux_pci.h before use it!)
+ *
+ * Use rt_dump_register(0xfff) to dump all registers.
+ * Use rt_dump_register(register_offset) to dump a specific register.
+ * The register_offset can be referred in Programmer-Manual.pdf
+ */
+void
+rt_dump_register(
+        unsigned int offset)
+{
+#ifdef RT_DUMP_REGISTER
+    unsigned int register_base = RALINK_CRYPTO_ENGINE_BASE;
+	unsigned int value = 0, i = 0;
+
+	offset &= 0xfff;
+	if(offset != 0xfff) /* print for a specific register */
+	{
+		value = ioread32((void __iomem *)(register_base+offset));
+		printk("<address>\t<value>\n0x%08x\t0x%08x\n", register_base+offset, value);
+	}
+	else /* print for all registers */
+	{
+		printk("\n[Command Registers:]\n");
+		printk("<address>\t<value>\n");
+		for(i=0; i<=0x1c; i+=0x4){
+			value = ioread32((void __iomem *)(register_base+i));
+			printk("0x%08x\t0x%08x\n", register_base+i, value);
+		}
+
+		printk("\n[Descriptor Ring Configuration Registers:]\n");
+        printk("<address>\t<value>\n");
+        for(i=0x80; i<=0x9c; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+
+        printk("\n[Configuration Registers:]\n");
+        printk("<address>\t<value>\n");
+        for(i=0x100; i<=0x104; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+        for(i=0x10c; i<=0x118; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+            printk("0x%08x\t0x%08x\n", register_base+0x120, value);
+            printk("0x%08x\t0x%08x\n", register_base+0x1d0, value);
+
+        printk("\n[Clock Control and Debug Interface Registers:]\n");
+        printk("<address>\t<value>\n");
+            printk("0x%08x\t0x%08x\n", register_base+0x1e0, value);
+
+        printk("\n[Device Revision and Options Registers:]\n");
+        printk("<address>\t<value>\n");
+        for(i=0x1f4; i<=0x1fc; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+
+        printk("\n[Interrupt Control Registers:]\n");
+        printk("<address>\t<value>\n");
+        for(i=0x200; i<=0x214; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+
+        printk("\n[SA Registers:]\n");
+        printk("<address>\t<value>\n");
+        for(i=0x400; i<=0x404; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+        for(i=0x420; i<=0x444; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+        for(i=0x468; i<=0x478; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+        for(i=0x500; i<=0x528; i+=0x4){
+            value = ioread32((void __iomem *)(register_base+i));
+            printk("0x%08x\t0x%08x\n", register_base+i, value);
+        }
+	}
+#endif
+}
+#endif
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Hexdump
+ *
+ * This function hex-dumps an array of uint32_t.
+ */
+#if ((defined(HWPAL_TRACE_DEVICE_READ)) || (defined(HWPAL_TRACE_DEVICE_WRITE)))
+static void
+HWPAL_Hexdump(
+        const char * ArrayName_p,
+        const char * DeviceName_p,
+        const unsigned int ByteOffset,
+        const uint32_t * WordArray_p,
+        const unsigned int WordCount,
+        bool fSwapEndianness)
+{
+    unsigned int i;
+
+    printk(
+        "%s: "
+        "byte offsets 0x%x - 0x%x"
+        " (%s)\n"
+        "  ",
+        ArrayName_p,
+        ByteOffset,
+        ByteOffset + WordCount*4 -1,
+        DeviceName_p);
+
+    for (i = 1; i <= WordCount; i++)
+    {
+        uint32_t Value = WordArray_p[i - 1];
+
+        if (fSwapEndianness)
+            Value = HWPAL_SwapEndian32(Value);
+
+        printk(" 0x%08x", Value);
+
+        if ((i & 7) == 0)
+            printk("\n  ");
+    }
+
+    if ((WordCount & 7) != 0)
+        printk("\n");
+}
+#endif
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Find
+ */
+bool
+HWPAL_Device_Find(
+        const char * DeviceName_p,
+        HWPAL_Device_t * const Device_p)
+{
+    uint32_t i;
+
+    if (Device_p == NULL)
+        return false;
+
+    *Device_p = NULL;
+
+    for (i = 0; i < DEVICE_COUNT; i++)
+    {
+        // protect again potential empty records
+        // caused by incomplete initializers
+        if (HWPAL_Devices[i].DeviceName_p == NULL)
+            continue;
+
+        if (strcmp(DeviceName_p, HWPAL_Devices[i].DeviceName_p) == 0)
+        {
+            *Device_p = (HWPAL_Device_t)&HWPAL_Devices[i];
+
+#ifdef HWPAL_TRACE_DEVICE_FIND
+            printk(
+                     "HWPAL_Device_Find: "
+                     "Returned %p for device %s\n",
+                     *Device_p,
+                     DeviceName_p);
+#endif
+            return true;
+        }
+    }
+
+#ifdef HWPAL_TRACE_DEVICE_FIND
+    printk(
+            "HWPAL_Device_Find: Failed to locate device %s\n",
+            DeviceName_p);
+#endif
+
+    return false;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Init
+ */
+void
+HWPAL_Device_Init(
+        HWPAL_Device_t Device)
+{
+    IDENTIFIER_NOT_USED(Device);
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_RemapDeviceAddress
+ *
+ * This function remaps certain device addresses (relative within the whole
+ * device address map) to other addresses. This is needed when the integration
+ * has remapped some EIP device registers to other addresses. The EIP Driver
+ * Libraries assume the devices always have the same internal layout.
+ */
+
+// the cs_hwpal_linux_pci_x86.h file defines a HWPAL_REMAP_ADDRESSES that
+// depends on the following HWPAL_REMAP_ONE
+
+#define HWPAL_REMAP_ONE(_old, _new) \
+    case _old: \
+        DeviceByteOffset = _new; \
+        break;
+
+static inline unsigned int
+HWPAL_RemapDeviceAddress(
+        unsigned int DeviceByteOffset)
+{
+    switch(DeviceByteOffset)
+    {
+        // include the remap statements
+        HWPAL_REMAP_ADDRESSES
+
+        default:
+            break;
+    }
+
+    return DeviceByteOffset;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Read32
+ */
+uint32_t
+HWPAL_Device_Read32(
+        HWPAL_Device_t Device,
+        const unsigned int ByteOffset)
+{
+    HWPAL_Device_Administration_t * Device_p;
+    uint32_t Value=0;
+
+    Device_p = (HWPAL_Device_Administration_t *)Device;
+    if (Device_p == NULL)
+        return 0xEEEEEEEE;
+
+#ifdef HWPAL_DEVICE_MAGIC
+    if (IS_INVALID_DEVICE(Device_p))
+    {
+        printk(
+                "HWPAL_Device_Read32: "
+                "Invalid device handle provided.\n");
+
+        return 0xEEEEEEEE;
+    }
+#endif /* HWPAL_DEVICE_MAGIC */
+
+#ifdef HWPAL_STRICT_ARGS_CHECK
+    if (IS_INVALID_OFFSET(ByteOffset, Device_p))
+    {
+        printk(
+                "HWPAL_Device_Read32: "
+                "Invalid ByteOffset 0x%x (device %s)\n",
+                ByteOffset,
+                Device_p->DeviceName_p);
+
+        return 0xEEEEEEEE;
+    }
+#endif /* HWPAL_STRICT_ARGS_CHECK */
+
+#ifdef HWPAL_ENABLE_HA_SIMULATION
+    if (Device_p->Flags & HWPAL_FLAG_HA)
+    {
+        // HA simulation mode
+        // disable access to PKA_MASTER_SEQ_CTRL
+        if (ByteOffset == 0x3FC8)
+        {
+            Value = 0;
+            goto HA_SKIP;
+        }
+    }
+#endif
+
+    if (Device_p->StartByteOffset == HWPAL_MAGIC_PCICONFIGSPACE)
+    {
+#ifndef RT_EIP93_DRIVER
+        pci_read_config_dword(HWPAL_PCI_Device_p, ByteOffset, &Value);
+#endif
+    }
+    else
+    {
+        unsigned int DeviceByteOffset = Device_p->StartByteOffset + ByteOffset;
+
+        DeviceByteOffset = HWPAL_RemapDeviceAddress(DeviceByteOffset);
+
+        Value = ioread32(HWPAL_MappedBaseAddr_p + (DeviceByteOffset / 4));
+    }
+
+#ifdef HWPAL_ENABLE_HA_SIMULATION
+HA_SKIP:
+#endif
+
+#ifdef HWPAL_DEVICE_ENABLE_SWAP
+    if (Device_p->Flags & HWPAL_FLAG_SWAP)
+        Value = HWPAL_SwapEndian32(Value);
+#endif
+
+#ifdef HWPAL_TRACE_DEVICE_READ
+    if (Device_p->Flags & HWPAL_FLAG_READ)
+    {
+        unsigned int DeviceByteOffset = Device_p->StartByteOffset + ByteOffset;
+        unsigned int DeviceByteOffset2 = HWPAL_RemapDeviceAddress(DeviceByteOffset);
+        if (DeviceByteOffset2 != DeviceByteOffset)
+        {
+            DeviceByteOffset2 -= Device_p->StartByteOffset;
+            printk(
+                    "HWPAL_Device_Read32: "
+                    "0x%x(was 0x%x) = 0x%08x (%s)\n",
+                    DeviceByteOffset2,
+                    ByteOffset,
+                    (unsigned int)Value,
+                    Device_p->DeviceName_p);
+        }
+        else
+        {
+            printk(
+                    "HWPAL_Device_Read32: "
+                    "0x%x = 0x%08x (%s)\n",
+                    ByteOffset,
+                    (unsigned int)Value,
+                    Device_p->DeviceName_p);
+        }
+    }
+#endif /* HWPAL_TRACE_DEVICE_READ */
+
+    return Value;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Write32
+ */
+void
+HWPAL_Device_Write32(
+        HWPAL_Device_t Device,
+        const unsigned int ByteOffset,
+        const uint32_t ValueIn)
+{
+    HWPAL_Device_Administration_t * Device_p;
+    uint32_t Value = ValueIn;
+
+    Device_p = (HWPAL_Device_Administration_t *)Device;
+    if (Device_p == NULL)
+        return;
+
+#ifdef HWPAL_DEVICE_MAGIC
+    if (IS_INVALID_DEVICE(Device_p))
+    {
+        printk(
+                "HWPAL_Device_Write32 :"
+                "Invalid device handle provided.\n");
+
+        return;
+    }
+#endif /* HWPAL_DEVICE_MAGIC */
+
+#ifdef HWPAL_STRICT_ARGS_CHECK
+    if (IS_INVALID_OFFSET(ByteOffset, Device_p))
+    {
+        printk(
+                "HWPAL_Device_Write32: "
+                "Invalid ByteOffset 0x%x (device %s)\n",
+                ByteOffset,
+                Device_p->DeviceName_p);
+        return;
+    }
+#endif /* HWPAL_STRICT_ARGS_CHECK */
+
+#ifdef HWPAL_TRACE_DEVICE_WRITE
+    if (Device_p->Flags & HWPAL_FLAG_WRITE)
+    {
+        printk(
+                "HWPAL_Device_Write32: "
+                "0x%x = 0x%08x (%s)\n",
+                ByteOffset,
+                (unsigned int)Value,
+                Device_p->DeviceName_p);
+    }
+#endif /* HWPAL_TRACE_DEVICE_WRITE*/
+
+#ifdef HWPAL_DEVICE_ENABLE_SWAP
+    if (Device_p->Flags & HWPAL_FLAG_SWAP)
+        Value = HWPAL_SwapEndian32(Value);
+#endif
+
+#ifdef HWPAL_ENABLE_HA_SIMULATION
+    if (Device_p->Flags & HWPAL_FLAG_HA)
+    {
+        // HA simulation mode
+        // disable access to PKA_MASTER_SEQ_CTRL
+        if (ByteOffset == 0x3FC8)
+        {
+            printk(
+                "HWPAL_Device_Write32: "
+                "Unexpected write to PKA_MASTER_SEQ_CTRL\n");
+            return;
+        }
+    }
+#endif
+
+    if (Device_p->StartByteOffset == HWPAL_MAGIC_PCICONFIGSPACE)
+    {
+#ifndef RT_EIP93_DRIVER
+        pci_write_config_dword(HWPAL_PCI_Device_p, ByteOffset, Value);
+#endif
+    }
+    else
+    {
+        uint32_t DeviceByteOffset = Device_p->StartByteOffset + ByteOffset;
+
+        DeviceByteOffset = HWPAL_RemapDeviceAddress(DeviceByteOffset);
+
+        iowrite32(Value, HWPAL_MappedBaseAddr_p + (DeviceByteOffset / 4));
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Read32Array
+ *
+ * Not supported for PCI Configuration space!
+ */
+void
+HWPAL_Device_Read32Array(
+        HWPAL_Device_t Device,
+        unsigned int Offset,            // read starts here, +4 increments
+        uint32_t * MemoryDst_p,         // writing starts here
+        const int Count)                // number of uint32's to transfer
+{
+    HWPAL_Device_Administration_t * Device_p;
+    unsigned int DeviceByteOffset;
+
+    Device_p = (HWPAL_Device_Administration_t *)Device;
+
+    if (Device_p == NULL ||
+        MemoryDst_p == NULL ||
+        Count <= 0)
+    {
+        return;
+    }
+
+    if (IS_INVALID_OFFSET(Offset, Device_p))
+    {
+        printk("HWPAL_Device_Read32Array: "
+               "Invalid ByteOffset 0x%x (device %s)\n",
+               Offset,
+               Device_p->DeviceName_p);
+        return;
+    }
+
+#ifdef HWPAL_ENABLE_HA_SIMULATION
+    if (Device_p->Flags & HWPAL_FLAG_HA)
+    {
+        // HA simulation mode
+        // disable access to PKA_MASTER_SEQ_CTRL
+        return;
+    }
+#endif
+
+    DeviceByteOffset = Device_p->StartByteOffset + Offset;
+
+    {
+        unsigned int RemappedOffset;
+        uint32_t Value;
+        int i;
+
+#ifdef HWPAL_DEVICE_ENABLE_SWAP
+        bool fSwap = false;
+        if (Device_p->Flags & HWPAL_FLAG_SWAP)
+            fSwap = true;
+#endif
+        for (i = 0; i < Count; i++)
+        {
+            RemappedOffset = HWPAL_RemapDeviceAddress(DeviceByteOffset);
+
+            Value = ioread32(HWPAL_MappedBaseAddr_p + (RemappedOffset / 4));
+
+#ifdef HWPAL_DEVICE_ENABLE_SWAP
+            // swap endianness if required
+            if (fSwap)
+                Value = HWPAL_SwapEndian32(Value);
+#endif
+
+            MemoryDst_p[i] = Value;
+            DeviceByteOffset +=  4;
+        } // for
+    }
+
+#ifdef HWPAL_TRACE_DEVICE_READ
+    if (Device_p->Flags & HWPAL_FLAG_READ)
+    {
+        HWPAL_Hexdump(
+            "HWPAL_Device_Read32Array",
+            Device_p->DeviceName_p,
+            Device_p->StartByteOffset + Offset,
+            MemoryDst_p,
+            Count,
+            false);     // already swapped during read above
+    }
+#endif /* HWPAL_TRACE_DEVICE_READ */
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Device_Write32Array
+ *
+ * Not supported for PCI Configuration space!
+ */
+void
+HWPAL_Device_Write32Array(
+        HWPAL_Device_t Device,
+        unsigned int Offset,            // write starts here, +4 increments
+        const uint32_t * MemorySrc_p,   // reading starts here
+        const int Count)                // number of uint32's to transfer
+{
+    HWPAL_Device_Administration_t * Device_p;
+    unsigned int DeviceByteOffset;
+
+    Device_p = (HWPAL_Device_Administration_t *)Device;
+
+    if (Device_p == NULL ||
+        MemorySrc_p == NULL ||
+        Count <= 0)
+    {
+        return;     // ## RETURN ##
+    }
+
+    if (IS_INVALID_OFFSET(Offset, Device_p))
+    {
+        printk(
+            "HWPAL_Device_Write32Array: "
+            "Invalid ByteOffset 0x%x (device %s)\n",
+            Offset,
+            Device_p->DeviceName_p);
+        return;
+    }
+
+    DeviceByteOffset = Device_p->StartByteOffset + Offset;
+
+#ifdef HWPAL_ENABLE_HA_SIMULATION
+    if (Device_p->Flags & HWPAL_FLAG_HA)
+    {
+        // HA simulation mode
+        // disable access to PKA_MASTER_SEQ_CTRL
+        return;
+    }
+#endif
+
+#ifdef HWPAL_TRACE_DEVICE_WRITE
+    if (Device_p->Flags & HWPAL_FLAG_WRITE)
+    {
+        bool fSwap = false;
+#ifdef HWPAL_DEVICE_ENABLE_SWAP
+        if (Device_p->Flags & HWPAL_FLAG_SWAP)
+            fSwap = true;
+#endif
+
+        HWPAL_Hexdump(
+            "HWPAL_Device_Write32Array",
+            Device_p->DeviceName_p,
+            DeviceByteOffset,
+            MemorySrc_p,
+            Count,
+            fSwap);
+    }
+#endif /* HWPAL_TRACE_DEVICE_WRITE */
+
+    {
+        unsigned int RemappedOffset;
+        uint32_t Value;
+        int i;
+
+#ifdef HWPAL_DEVICE_ENABLE_SWAP
+        bool fSwap = false;
+        if (Device_p->Flags & HWPAL_FLAG_SWAP)
+            fSwap = true;
+#endif
+
+        for (i = 0; i < Count; i++)
+        {
+            RemappedOffset = HWPAL_RemapDeviceAddress(DeviceByteOffset);
+            Value = MemorySrc_p[i];
+#ifdef HWPAL_DEVICE_ENABLE_SWAP
+            if (fSwap)
+                Value = HWPAL_SwapEndian32(Value);
+#endif
+            iowrite32(Value, HWPAL_MappedBaseAddr_p + (RemappedOffset / 4));
+
+            DeviceByteOffset += 4;
+        } // for
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Probe
+ */
+static int
+HWPAL_Probe(
+        struct pci_dev * PCI_Device_p,
+        const struct pci_device_id * id)
+{
+    const int BAR_ID = 0;
+    resource_size_t BaseAddrHwRd;
+
+    {
+        // enable the device
+        // this also looks up the IRQ
+        int res = pci_enable_device(PCI_Device_p);
+
+        if (res)
+        {
+            printk(
+                "HWPAL_Probe: "
+                "Failed to enable PCI device %s\n",
+                pci_name(PCI_Device_p));
+
+            return res;
+        }
+    }
+
+    // remember the device reference
+    // we need when access the configuration space
+    HWPAL_PCI_Device_p = PCI_Device_p;
+
+    // now map the chip into kernel memory
+    // so we can access the EIP static resources
+    BaseAddrHwRd = pci_resource_start(PCI_Device_p, BAR_ID);
+    BaseAddrHwRd &= ~0xf; // Chop off the control bits
+
+    // note: ioremap is uncached by default
+    HWPAL_MappedBaseAddr_p = ioremap(
+                                 BaseAddrHwRd,
+                                 pci_resource_len(PCI_Device_p, BAR_ID));
+
+    if (!HWPAL_MappedBaseAddr_p)
+    {
+        printk(
+            "HWPAL_Probe: "
+            "Failed to ioremap PCI device %s\n",
+            pci_name(PCI_Device_p));
+
+        return 1;
+    }
+
+    printk(
+        "HWPAL_Probe: "
+        "Mapped base address is: %p, sizeof(resource_size_t)=%d\n"
+        "  start=0x%x, end=0x%x, len=0x%x, flags=0x%x, irq=%d\n",
+        HWPAL_MappedBaseAddr_p,
+        sizeof(resource_size_t),
+        (unsigned int)pci_resource_start(PCI_Device_p, 0),
+        (unsigned int)pci_resource_end(PCI_Device_p, 0),
+        (unsigned int)pci_resource_len(PCI_Device_p, 0),
+        (unsigned int)pci_resource_flags(PCI_Device_p, 0),
+        PCI_Device_p->irq);
+
+    IDENTIFIER_NOT_USED(id);
+
+    // return 0 to indicate "we decided to take ownership"
+    return 0;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Remove
+ */
+static void
+HWPAL_Remove(
+        struct pci_dev * PCI_Device_p)
+{
+    printk(
+        "HWPAL_Remove: "
+        "HWPAL_MappedBaseAddr_p=%p\n",
+        HWPAL_MappedBaseAddr_p);
+
+    if (HWPAL_MappedBaseAddr_p)
+    {
+        iounmap(HWPAL_MappedBaseAddr_p);
+        HWPAL_MappedBaseAddr_p = NULL;
+    }
+
+    pci_disable_device(PCI_Device_p);
+}
+
+
+/*----------------------------------------------------------------------------
+ * Declarations native to Linux kernel
+ */
+
+static char HWPAL_Module_Name[] = HWPAL_PCI_DRIVER_NAME;
+
+// Safenet PCI vendor ID
+#define HWPAL_PCI_VENDOR_ID_SAFENET  0x16AE
+
+const struct pci_device_id DeviceIDs[] =
+{
+    {PCI_DEVICE(HWPAL_PCI_VENDOR_ID_SAFENET, HWPAL_PCI_DEVICE_ID), },
+    {0, }
+};
+
+static struct pci_driver HWPAL_PCI_Driver =
+{
+#ifdef _MSC_VER
+    // microsoft compiler does not support partial initializers
+    // NOTE: struct must have fields in this order
+    HWPAL_Module_Name,
+    DeviceIDs,
+    HWPAL_Probe,
+    HWPAL_Remove,
+#else
+    .name = HWPAL_Module_Name,
+    .id_table = DeviceIDs,
+    .probe = HWPAL_Probe,
+    .remove = HWPAL_Remove,
+#endif
+};
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Initialize
+ */
+bool
+HWPAL_Initialize(
+        void * CustomInitData_p)
+{
+    int Status;
+
+    Status = pci_register_driver(&HWPAL_PCI_Driver);
+    if (Status < 0)
+    {
+        printk(
+            "HWPAL_Initialize: "
+            "Failed to register the PCI device\n");
+
+        return false;
+    }
+
+    // if provided, CustomInitData_p points to an "int"
+    // we return the "irq" number via this output parameter
+    if (CustomInitData_p)
+    {
+        int * p = (int *)CustomInitData_p;
+        *p = HWPAL_PCI_Device_p->irq;
+    }
+
+    return true;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Unitialize
+ */
+void
+HWPAL_UnInitialize(void)
+{
+    printk(
+        "HWPAL_UnInitialize: "
+        "calling pci_unregister_driver\n");
+
+    pci_unregister_driver(&HWPAL_PCI_Driver);
+}
+
+
+MODULE_DEVICE_TABLE(pci, DeviceIDs);
+
diff --git a/drivers/net/cryptoDriver/source/utils/mtk_hwDmaResource.c b/drivers/net/cryptoDriver/source/utils/mtk_hwDmaResource.c
new file mode 100755
index 0000000..da0f23e
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/utils/mtk_hwDmaResource.c
@@ -0,0 +1,945 @@
+
+#include "mtk_cHwPci.h"
+
+#include "mtk_baseDefs.h"
+#include "mtk_cLib.h"
+#include "mtk_hwDmaAccess.h"
+#include "mtk_hwAccess.h"
+
+#include <linux/slab.h>         // kmalloc, kfree
+#include <linux/dma-mapping.h>  // dma_sync_single_for_cpu
+
+#ifdef HWPAL_LOCK_SLEEPABLE
+#include <linux/mutex.h>        // mutex_*
+#else
+#include <linux/spinlock.h>     // spinlock_*
+#endif
+
+
+/*
+
+ Requirements on the records:
+  - pre-allocated array of records
+  - valid between Create and Destroy
+  - re-use on a least-recently-used basis to make sure accidental continued
+    use after destroy does not cause crashes, allowing us to detect the
+    situation instead of crashing quickly.
+
+ Requirements on the handles:
+  - one handle per record
+  - valid between Create and Destroy
+  - quickly find the ptr-to-record belonging to the handle
+  - detect continued use of a handle after Destroy
+  - caller-hidden admin/status, thus not inside the record
+  - report leaking handles upon exit
+
+ Solution:
+  - handle cannot be a record number (no post-destroy use detection possible)
+  - recnr/destroyed in separate memory location for each handle: Handles_p
+  - Array of records: Records_p
+  - free locations in Array1: Freelist1 (FreeHandles)
+  - free record numbers list: Freelist2 (FreeRecords)
+ */
+
+typedef struct
+{
+    int ReadIndex;
+    int WriteIndex;
+    int * Nrs_p;
+} HWPAL_FreeList_t;
+
+static int HandlesCount = 0;        // remainder are valid only when this is != 0
+static int * Handles_p;
+static HWPAL_DMAResource_Record_t * Records_p;
+static HWPAL_FreeList_t FreeHandles;
+static HWPAL_FreeList_t FreeRecords;
+
+
+#ifdef HWPAL_LOCK_SLEEPABLE
+static struct mutex HWPAL_Lock;
+#else
+static spinlock_t HWPAL_SpinLock;
+#endif
+
+#define HWPAL_RECNR_DESTROYED  -1
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_FreeList_Get
+ *
+ * Gets the next entry from the freelist. Returns -1 when the list is empty.
+ */
+static inline int
+HWPAL_FreeList_Get(
+        HWPAL_FreeList_t * const List_p)
+{
+    int Nr = -1;
+    int ReadIndex_Updated = List_p->ReadIndex + 1;
+
+    if (ReadIndex_Updated >= HandlesCount)
+        ReadIndex_Updated = 0;
+
+    // if post-increment ReadIndex == WriteIndex, the list is empty
+    if (ReadIndex_Updated != List_p->WriteIndex)
+    {
+        // grab the next number
+        Nr = List_p->Nrs_p[List_p->ReadIndex];
+        List_p->ReadIndex = ReadIndex_Updated;
+    }
+
+    return Nr;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_FreeList_Add
+ *
+ * Adds an entry to the freelist.
+ */
+static inline void
+HWPAL_FreeList_Add(
+        HWPAL_FreeList_t * const List_p,
+        int Nr)
+{
+    if (List_p->WriteIndex == List_p->ReadIndex)
+    {
+        printk(
+            "HWPAL_FreeList_Add: "
+            "Attempt to add value %d to full list\n",
+            Nr);
+        return;
+    }
+
+    if (Nr < 0 || Nr >= HandlesCount)
+    {
+        printk(
+            "HWPAL_FreeList_Add: "
+            "Attempt to put invalid value: %d\n",
+            Nr);
+        return;
+    }
+
+    {
+        int WriteIndex_Updated = List_p->WriteIndex + 1;
+        if (WriteIndex_Updated >= HandlesCount)
+            WriteIndex_Updated = 0;
+
+        // store the number
+        List_p->Nrs_p[List_p->WriteIndex] = Nr;
+        List_p->WriteIndex = WriteIndex_Updated;
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_Hexdump
+ *
+ * This function hex-dumps an array of uint32_t.
+ */
+#ifdef HWPAL_TRACE_DMARESOURCE_READWRITE
+
+static inline void
+HWPAL_DMAResource_Hexdump(
+        const char * ArrayName_p,
+        const uint16_t * Handle_p,
+        const unsigned int Offset,
+        const uint32_t * WordArray_p,
+        const unsigned int WordCount,
+        bool fSwapEndianness)
+{
+    unsigned int i;
+
+    printk(
+        "%s: "
+        "Handle = %p: "
+        "byte offsets %u - %u "
+        "(swap=%d)\n"
+        ArrayName_p,
+        Handle_p,
+        Offset,
+        Offset + WordCount*4 - 1,
+        fSwapEndianess);
+
+    for (i = 1; i <= WordCount; i++)
+    {
+        uint32_t Value = WordArray_p[i - 1];
+
+        if (fSwapEndianness)
+            Value = HWPAL_SwapEndian32(Value);
+
+        printk(" 0x%08x", Value);
+
+        if ((i & 7) == 0)
+            printk("\n  ");
+    }
+
+    if ((WordCount & 7) != 0)
+        printk("\n");
+}
+#endif
+
+
+bool
+HWPAL_DMAResource_Init(
+        const unsigned int MaxHandles)
+{
+
+#ifdef HWPAL_LOCK_SLEEPABLE
+    mutex_init(&HWPAL_Lock);
+#else
+    spin_lock_init(&HWPAL_SpinLock);
+#endif
+
+    // already initialized?
+    if (HandlesCount != 0)
+        return false;
+
+    // this implementation only supports MaxHandles != 0
+    if (MaxHandles == 0)
+        return false;
+
+    Records_p = kmalloc(MaxHandles * sizeof(HWPAL_DMAResource_Record_t), GFP_KERNEL);
+    Handles_p = kmalloc(MaxHandles * sizeof(int), GFP_KERNEL);
+    FreeHandles.Nrs_p = kmalloc(MaxHandles * sizeof(int), GFP_KERNEL);
+    FreeRecords.Nrs_p = kmalloc(MaxHandles * sizeof(int), GFP_KERNEL);
+
+    // if any allocation failed, free the whole lot
+    if (Records_p == NULL ||
+        Handles_p == NULL ||
+        FreeHandles.Nrs_p == NULL ||
+        FreeRecords.Nrs_p == NULL)
+    {
+        if (Records_p)
+            kfree(Records_p);
+
+        if (Handles_p)
+            kfree(Handles_p);
+
+        if (FreeHandles.Nrs_p)
+            kfree(FreeHandles.Nrs_p);
+
+        if (FreeRecords.Nrs_p)
+            kfree(FreeRecords.Nrs_p);
+
+        Records_p = NULL;
+        Handles_p = NULL;
+        FreeHandles.Nrs_p = NULL;
+        FreeRecords.Nrs_p = NULL;
+
+        return false;
+    }
+
+
+    {
+        unsigned int i;
+
+        for (i = 0; i < MaxHandles; i++)
+        {
+            Handles_p[i] = HWPAL_RECNR_DESTROYED;
+            FreeHandles.Nrs_p[i] = MaxHandles - 1 - i;
+            FreeRecords.Nrs_p[i] = i;
+        }
+
+        FreeHandles.ReadIndex = 0;
+        FreeHandles.WriteIndex = 0;
+
+        FreeRecords.ReadIndex = 0;
+        FreeRecords.WriteIndex = 0;
+    }
+
+    HandlesCount = MaxHandles;
+
+    return true;
+}
+
+
+
+void
+HWPAL_DMAResource_UnInit(void)
+{
+    // exit if not initialized
+    if (HandlesCount == 0)
+        return;
+
+
+    HandlesCount = 0;
+
+    kfree(FreeHandles.Nrs_p);
+    kfree(FreeRecords.Nrs_p);
+    kfree(Handles_p);
+    kfree(Records_p);
+
+    FreeHandles.Nrs_p = NULL;
+    FreeRecords.Nrs_p = NULL;
+    Handles_p = NULL;
+    Records_p = NULL;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Create
+ */
+HWPAL_DMAResource_Handle_t
+HWPAL_DMAResource_Create(void)
+{
+#ifndef HWPAL_LOCK_SLEEPABLE
+    unsigned long flags;
+#endif
+    int HandleNr;
+    int RecNr = 0;
+
+    // return NULL when not initialized
+    if (HandlesCount == 0)
+        return NULL;
+
+#ifdef HWPAL_LOCK_SLEEPABLE
+    mutex_lock(&HWPAL_Lock);
+#else
+    spin_lock_irqsave(&HWPAL_SpinLock, flags);
+#endif
+
+    HandleNr = HWPAL_FreeList_Get(&FreeHandles);
+    if (HandleNr != -1)
+    {
+        RecNr = HWPAL_FreeList_Get(&FreeRecords);
+        if (RecNr == -1)
+        {
+            HWPAL_FreeList_Add(&FreeHandles, HandleNr);
+            HandleNr = -1;
+        }
+    }
+
+#ifdef HWPAL_LOCK_SLEEPABLE
+    mutex_unlock(&HWPAL_Lock);
+#else
+    spin_unlock_irqrestore(&HWPAL_SpinLock, flags);
+#endif
+
+    // return NULL when reservation failed
+    if (HandleNr == -1)
+        return NULL;
+
+    // initialize the record
+    {
+        HWPAL_DMAResource_Record_t * Rec_p = Records_p + RecNr;
+        memset(Rec_p, 0, sizeof(HWPAL_DMAResource_Record_t));
+    }
+
+    // initialize the handle
+    Handles_p[HandleNr] = RecNr;
+
+    // fill in the handle position
+    return Handles_p + HandleNr;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Destroy
+ */
+void
+HWPAL_DMAResource_Destroy(
+        HWPAL_DMAResource_Handle_t Handle)
+{
+    if (HWPAL_DMAResource_IsValidHandle(Handle))
+    {
+        int * p = (int *)Handle;
+        int RecNr = *p;
+
+        if (RecNr >= 0 &&
+            RecNr < HandlesCount)
+        {
+#ifndef HWPAL_LOCK_SLEEPABLE
+            unsigned long flags;
+#endif
+            int HandleNr = p - Handles_p;
+
+            // note handle is no longer value
+            *p = HWPAL_RECNR_DESTROYED;
+
+#ifdef HWPAL_LOCK_SLEEPABLE
+            mutex_lock(&HWPAL_Lock);
+#else
+            spin_lock_irqsave(&HWPAL_SpinLock, flags);
+#endif
+
+            // add the HandleNr and RecNr to respective LRU lists
+            HWPAL_FreeList_Add(&FreeHandles, HandleNr);
+            HWPAL_FreeList_Add(&FreeRecords, RecNr);
+
+#ifdef HWPAL_LOCK_SLEEPABLE
+            mutex_unlock(&HWPAL_Lock);
+#else
+            spin_unlock_irqrestore(&HWPAL_SpinLock, flags);
+#endif
+        }
+        else
+        {
+            printk(
+                "HWPAL_DMAResource_Destroy: "
+                "Handle %p was already destroyed\n",
+                Handle);
+        }
+    }
+    else
+    {
+        printk(
+            "HWPAL_DMAResource_Destroy: "
+            "Invalid handle %p\n",
+            Handle);
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_IsValidHandle
+ */
+bool
+HWPAL_DMAResource_IsValidHandle(
+        HWPAL_DMAResource_Handle_t Handle)
+{
+    int * p = (int *)Handle;
+
+    if (p < Handles_p ||
+        p >= Handles_p + HandlesCount)
+    {
+        return false;
+    }
+
+    // check that the handle has not been destroyed yet
+    if (*p < 0 ||
+        *p >= HandlesCount)
+    {
+        return false;
+    }
+
+    return true;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Handle2RecordPtr
+ */
+HWPAL_DMAResource_Record_t *
+HWPAL_DMAResource_Handle2RecordPtr(
+        HWPAL_DMAResource_Handle_t Handle)
+{
+    int * p = (int *)Handle;
+
+    if (p != NULL)
+    {
+        int RecNr = *p;
+
+        if (RecNr >= 0 &&
+            RecNr < HandlesCount)
+        {
+            return Records_p + RecNr;           // ## RETURN ##
+        }
+    }
+
+    return NULL;
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Read32
+ *
+ * This function can be used to read one 32bit word from the DMA Resource
+ * buffer.
+ * If required (decided by HWPAL_DMAResource_Record_t.device.fSwapEndianess),
+ * on the fly endianess swapping of the value read will be performed before it
+ * is returned to the caller.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to read from.
+ *
+ * Return Value
+ *     The value read.
+ *
+ * When the Handle and WordOffset parameters are not valid, the implementation
+ * will return an unspecified value.
+ */
+uint32_t
+HWPAL_DMAResource_Read32(
+        HWPAL_DMAResource_Handle_t Handle,
+        const uint32_t WordOffset)
+{
+    HWPAL_DMAResource_Record_t * Rec_p;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(Handle);
+    if (Rec_p == NULL)
+    {
+        printk(
+            "HWPAL_DMAResource_Read32: "
+            "Invalid handle %p\n",
+            Handle);
+
+        return 0;
+    }
+
+    if (WordOffset * 4 >= Rec_p->host.BufferSize)
+    {
+        printk(
+            "HWPAL_DMAResource_Read32: "
+            "Invalid WordOffset %u for Handle %p\n",
+            WordOffset,
+            Handle);
+
+        return 0;
+    }
+
+    {
+        uint32_t * Address_p = Rec_p->host.HostAddr_p;
+        uint32_t Value = Address_p[WordOffset];
+
+        // swap endianness, if required
+        if (Rec_p->device.fSwapEndianess)
+            Value = HWPAL_SwapEndian32(Value);
+
+#ifdef HWPAL_TRACE_DMARESOURCE_READ
+        printk(
+            "HWPAL_DMAResource_Read32:  "
+            "(handle %p) "
+            "0x%08x = [%u] "
+            "(swap=%d)\n",
+            Handle,
+            Value,
+            WordOffset,
+            Rec_p->device.fSwapEndianess);
+#endif
+
+        return Value;
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Write32
+ *
+ * This function can be used to write one 32bit word to the DMA Resource.
+ * If required (decided by HWPAL_DMAResource_Record_t.device.fSwapEndianess),
+ * on the fly endianess swapping of the value to be written will be performed.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to write to.
+ *
+ * Value (input)
+ *     The 32bit value to write.
+ *
+ * Return Value
+ *     None
+ *
+ * The write can only be successful when the Handle and WordOffset
+ * parameters are valid.
+ */
+void
+HWPAL_DMAResource_Write32(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const uint32_t Value)
+{
+    HWPAL_DMAResource_Record_t * Rec_p;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(Handle);
+    if (Rec_p == NULL)
+    {
+        printk(
+            "HWPAL_DMAResource_Write32: "
+            "Invalid handle %p\n",
+            Handle);
+
+        return;
+    }
+
+    if (WordOffset * 4 >= Rec_p->host.BufferSize)
+    {
+        printk(
+            "HWPAL_DMAResource_Write32: "
+            "Invalid WordOffset %u for Handle %p\n",
+            WordOffset,
+            Handle);
+
+        return;
+    }
+
+#ifdef HWPAL_TRACE_DMARESOURCE_WRITE
+    printk(
+        "HWPAL_DMAResource_Write32: "
+        "(handle %p) "
+        "[%u] = 0x%08x "
+        "(swap=%d)\n",
+        Handle,
+        WordOffset,
+        Value,
+        Rec_p->device.fSwapEndianess);
+#endif
+
+    {
+        uint32_t * Address_p = Rec_p->host.HostAddr_p;
+        uint32_t WriteValue = Value;
+
+        // swap endianness, if required
+        if (Rec_p->device.fSwapEndianess)
+            WriteValue = HWPAL_SwapEndian32(WriteValue);
+
+        Address_p[WordOffset] = WriteValue;
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Read32Array
+ *
+ * This function perform the same task as HWPAL_DMAResource_Read32 for a
+ * consecutive array of 32bit words.
+ *
+ * See HWPAL_DMAResource_Read32 for a more detailed description.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to start
+ *     reading from.
+ *
+ * WordCount (input)
+ *     The number of 32bit words to transfer.
+ *
+ * Values_p (input)
+ *     Memory location to write the retrieved values to.
+ *     Note the ability to let Values_p point inside the DMAResource that is
+ *     being read from, allowing for in-place endianess conversion.
+ *
+ * Return Value
+ *     None.
+ *
+ * The read can only be successful when the Handle and WordOffset
+ * parameters are valid.
+ */
+void
+HWPAL_DMAResource_Read32Array(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const unsigned int WordCount,
+        uint32_t * Values_p)
+{
+    HWPAL_DMAResource_Record_t * Rec_p;
+
+    if (WordCount == 0)
+        return;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(Handle);
+    if (Rec_p == NULL)
+    {
+        printk(
+            "HWPAL_DMAResource_Read32Array: "
+            "Invalid handle %p\n",
+            Handle);
+        return;
+    }
+
+    if ((WordOffset + WordCount - 1) * 4 >= Rec_p->host.BufferSize)
+    {
+        printk(
+            "HWPAL_DMAResource_Read32Array: "
+            "Invalid range: %u - %u\n",
+            WordOffset,
+            WordOffset + WordCount - 1);
+        return;
+    }
+
+    {
+        uint32_t * Address_p = Rec_p->host.HostAddr_p;
+        unsigned int i;
+
+        for (i = 0; i < WordCount; i++)
+        {
+            uint32_t Value = Address_p[WordOffset + i];
+
+            // swap endianness, if required
+            if (Rec_p->device.fSwapEndianess)
+                Value = HWPAL_SwapEndian32(Value);
+
+            Values_p[i] = Value;
+        } // for
+    }
+
+#ifdef HWPAL_TRACE_DMARESOURCE_READ
+    {
+        uint32_t * Address_p = Rec_p->host.HostAddr_p;
+        if (Values_p == Address_p + WordOffset)
+        {
+            printk(
+                "HWPAL_DMAResource_Read32Array: "
+                "(handle %p) "
+                "[%u..%u] IN-PLACE "
+                "(swap=%d)\n",
+                Handle,
+                WordOffset,
+                WordOffset + WordCount - 1,
+                Rec_p->device.fSwapEndianess);
+        }
+        else
+        {
+            printk(
+                "HWPAL_DMAResource_Read32Array: "
+                "(handle %p) "
+                "[%u..%u] "
+                "(swap=%d)\n",
+                Handle,
+                WordOffset,
+                WordOffset + WordCount - 1,
+                Rec_p->device.fSwapEndianess);
+        }
+    }
+#endif
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_Write32Array
+ *
+ * This function perform the same task as HWPAL_DMAResource_Write32 for a
+ * consecutive array of 32bit words.
+ *
+ * See HWPAL_DMAResource_Write32 for a more detailed description.
+ *
+ * Handle (input)
+ *     Handle for the DMA Resource to access.
+ *
+ * WordOffset (input)
+ *     Offset in 32bit words, from the start of the DMA Resource to start
+ *     writing from.
+ *
+ * WordCount (input)
+ *     The number of 32bit words to transfer.
+ *
+ * Values_p (input)
+ *     Pointer to the memory where the values to be written are located.
+ *     Note the ability to let Values_p point inside the DMAResource that is
+ *     being written to, allowing for in-place endianess conversion.
+ *
+ * Return Value
+ *     None.
+ *
+ * The write can only be successful when the Handle and WordOffset
+ * parameters are valid.
+ */
+void
+HWPAL_DMAResource_Write32Array(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int WordOffset,
+        const unsigned int WordCount,
+        const uint32_t * Values_p)
+{
+    HWPAL_DMAResource_Record_t * Rec_p;
+
+    if (WordCount == 0)
+        return;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(Handle);
+    if (Rec_p == NULL)
+    {
+        printk(
+            "HWPAL_DMAResource_Write32Array: "
+            "Invalid handle %p\n",
+            Handle);
+        return;
+    }
+
+    if ((WordOffset + WordCount - 1) * 4 >= Rec_p->host.BufferSize)
+    {
+        printk(
+            "HWPAL_DMAResource_Write32Array: "
+            "Invalid range: %u - %u\n",
+            WordOffset,
+            WordOffset + WordCount - 1);
+        return;
+    }
+
+    {
+        uint32_t * Address_p = Rec_p->host.HostAddr_p;
+        unsigned int i;
+
+        for (i = 0; i < WordCount; i++)
+        {
+            uint32_t Value = Values_p[i];
+
+            // swap endianness, if required
+            if (Rec_p->device.fSwapEndianess)
+                Value = HWPAL_SwapEndian32(Value);
+
+            Address_p[WordOffset + i] = Value;
+        } // for
+    }
+
+#ifdef HWPAL_TRACE_DMARESOURCE_WRITE
+    {
+        uint32_t * Address_p = Rec_p->host.HostAddr_p;
+        if (Values_p == Address_p + WordOffset)
+        {
+            printk(
+                "HWPAL_DMAResource_Write32Array: "
+                "(handle %p) "
+                "[%u..%u] IN-PLACE "
+                "(swap=%d)\n",
+                Handle,
+                WordOffset,
+                WordOffset + WordCount - 1,
+                Rec_p->device.fSwapEndianess);
+        }
+        else
+        {
+            printk(
+                "HWPAL_DMAResource_Write32Array: "
+                "(handle %p) "
+                "[%u..%u] "
+                "(swap=%d)\n",
+                Handle,
+                WordOffset,
+                WordOffset + WordCount - 1,
+                Rec_p->device.fSwapEndianess);
+        }
+    }
+#endif
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_PreDMA
+ */
+void
+HWPAL_DMAResource_PreDMA(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int ByteOffset,
+        const unsigned int ByteCount)
+{
+    HWPAL_DMAResource_Record_t * Rec_p;
+    dma_addr_t pa;
+    size_t size;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(Handle);
+    if (Rec_p == NULL)
+    {
+        printk(
+            "HWPAL_DMAResource_PreDMA: "
+            "Invalid handle %p\n",
+            Handle);
+
+        return;
+    }
+
+    // dma_sync_single_for_cpu wants the bus address
+    pa = Rec_p->device.DeviceAddr32;
+    size = 0;
+
+    if (ByteCount == 0)
+    {
+#ifdef HWPAL_TRACE_DMARESOURCE_PREPOSTDMA
+        printk(
+            "HWPAL_DMAResource_PreDMA: "
+            "Handle=%p, "
+            "Range=ALL (%u, %u)\n",
+            Handle,
+            ByteOffset,
+            ByteCount);
+#endif
+        size = Rec_p->host.BufferSize;
+    }
+    else
+    {
+#ifdef HWPAL_TRACE_DMARESOURCE_PREPOSTDMA
+        printk(
+                "HWPAL_DMAResource_PreDMA: "
+                "Handle=%p, "
+                "Range=%u-%u\n",
+                Handle,
+                ByteOffset,
+                ByteOffset + ByteCount -1);
+#endif
+        pa += ByteOffset;
+        size = ByteCount;
+    }
+
+#ifdef HWPAL_TRACE_DMARESOURCE_PREPOSTDMA
+    printk(
+        "HWPAL_DMAResource_PreDMA: "
+        "pa=0x%08x, size=0x%08x\n",
+        pa, size);
+#endif
+
+    dma_sync_single_for_cpu(NULL, pa, size, DMA_TO_DEVICE);
+}
+
+
+/*----------------------------------------------------------------------------
+ * HWPAL_DMAResource_PostDMA
+ */
+void
+HWPAL_DMAResource_PostDMA(
+        HWPAL_DMAResource_Handle_t Handle,
+        const unsigned int ByteOffset,
+        const unsigned int ByteCount)
+{
+    HWPAL_DMAResource_Record_t * Rec_p;
+    dma_addr_t pa;
+    size_t size;
+
+    Rec_p = HWPAL_DMAResource_Handle2RecordPtr(Handle);
+    if (Rec_p == NULL)
+    {
+        printk(
+            "HWPAL_DMAResource_PostDMA: "
+            "Invalid handle %p\n",
+            Handle);
+
+        return;
+    }
+
+    // dma_sync_single_for_cpu wants the bus address
+    pa = Rec_p->device.DeviceAddr32;
+    size = 0;
+
+    if (ByteCount == 0)
+    {
+#ifdef HWPAL_TRACE_DMARESOURCE_PREPOSTDMA
+        printk(
+                "HWPAL_DMAResource_PostDMA: "
+                "Handle=%p, "
+                "Range=ALL (%u, %u)\n",
+                Handle,
+                ByteOffset,
+                ByteCount);
+#endif
+        size = Rec_p->host.BufferSize;
+    }
+    else
+    {
+#ifdef HWPAL_TRACE_DMARESOURCE_PREPOSTDMA
+        printk(
+                "HWPAL_DMAResource_PostDMA: "
+                "Handle=%p, "
+                "Range=%u-%u\n",
+                Handle,
+                ByteOffset,
+                ByteOffset + ByteCount -1);
+#endif
+        pa += ByteOffset;
+        size = ByteCount;
+    }
+
+#ifdef HWPAL_TRACE_DMARESOURCE_PREPOSTDMA
+    printk(
+        "HWPAL_DMAResource_PostDMA: "
+        "pa=0x%08x, size=0x%08x\n",
+        pa, size);
+#endif
+
+    dma_sync_single_for_cpu(NULL, pa, size, DMA_FROM_DEVICE);
+}
+
diff --git a/drivers/net/cryptoDriver/source/utils/mtk_ringHelper.c b/drivers/net/cryptoDriver/source/utils/mtk_ringHelper.c
new file mode 100755
index 0000000..2c83f35
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/utils/mtk_ringHelper.c
@@ -0,0 +1,372 @@
+
+#include "mtk_baseDefs.h"     // bool, MIN
+#include "mtk_ring.h"
+#include "mtk_cLib.h"           // memset
+
+
+/*----------------------------------------------------------------------------
+ * RingHelper_Init
+ *
+ * This routine must be called once to initialize the administration block
+ * related to a ring.
+ *
+ * See header file for function specification.
+ */
+int
+RingHelper_Init(
+        RingHelper_t * const Ring_p,
+        const RingHelper_CallbackInterface_t * const CallbackIF_p,
+        const bool fSeparateRings,
+        const unsigned int CommandRing_MaxDescriptors,
+        const unsigned int ResultRing_MaxDescriptors)
+{
+    if (Ring_p == NULL ||
+        CallbackIF_p == NULL ||
+        CommandRing_MaxDescriptors < 1)
+    {
+        // invalid argument
+        return -1;
+    }
+
+    if (fSeparateRings)
+    {
+        if (ResultRing_MaxDescriptors < 1)
+        {
+            // invalid arguments
+            return -1;
+        }
+    }
+
+    if (CallbackIF_p->ReadFunc_p == NULL ||
+        CallbackIF_p->WriteFunc_p == NULL ||
+        CallbackIF_p->StatusFunc_p == NULL)
+    {
+        return -1;
+    }
+
+    // initialize the ring admin data structure
+    memset(Ring_p, 0, sizeof(RingHelper_t));
+
+    Ring_p->CB = *CallbackIF_p;
+    Ring_p->fSupportsDeviceReadPos = true;      // initial assumption
+    Ring_p->IN_Size = CommandRing_MaxDescriptors;
+
+    if (fSeparateRings)
+    {
+        // separate rings
+        Ring_p->fSeparate = true;
+        Ring_p->OUT_Size = ResultRing_MaxDescriptors;
+    }
+    else
+    {
+        // combined rings
+        Ring_p->fSeparate = false;
+        Ring_p->OUT_Size = CommandRing_MaxDescriptors;
+    }
+
+    return 0;   // success
+}
+
+
+/*----------------------------------------------------------------------------
+ * RingHelper_Put
+ *
+ * This function tries to add a number of descriptors to the command ring
+ * specified.
+ *
+ * See header file for function specification.
+ */
+int
+RingHelper_Put(
+        RingHelper_t * const Ring_p,
+        const void * Descriptors_p,
+        const int DescriptorCount)
+{
+    int A, N, W1, W2;
+
+    if (Ring_p == NULL ||
+        Descriptors_p == NULL ||
+        DescriptorCount < 0)
+    {
+        return -1;
+    }
+
+    if (DescriptorCount == 0)
+        return 0;
+
+    W1 = W2 = 0;
+
+    // out of the descriptors provided, calculate the maximum number of
+    // descriptors that can be written sequentially before the ring is full.
+    if (Ring_p->fSeparate)
+    {
+        // separate rings
+
+        // ask how far the device has processed the ring
+        // we do this on every call and do not cache the result
+        int DeviceReadHead = -1;    // not supported
+
+        if (Ring_p->fSupportsDeviceReadPos)
+        {
+            int res;
+			//read PE_RING_PNTR for CmdRing and store it in DeviceReadHead --Trey
+            res = Ring_p->CB.StatusFunc_p( //EIP93_StatusCB()
+                                 Ring_p->CB.CallbackParam1_p, //IOArea_p
+                                 Ring_p->CB.CallbackParam2, //0
+                                 &DeviceReadHead);
+
+            if (res < 0)
+                return res;     // ## RETURN ##
+
+            // suppress these calls if the device does not support it
+            if (DeviceReadHead < 0)
+                Ring_p->fSupportsDeviceReadPos = false;
+        }
+
+        if (DeviceReadHead < 0)
+        {
+            // device does not expose its read position
+            // this means we cannot calculate how much space is available
+            // the WriteFunc will have to check, descriptor by descriptor
+            A = Ring_p->IN_Size;
+
+            // note: under this condition we rely on the implementation of
+            // the callback interface to handle ring-full condition and not
+            // overwrite existing descriptors. Because of this, we can
+            // fill the ring to the limit and do not have to keep 1 free
+            // position as done below.
+        }
+        else
+        {
+            unsigned int Device_IN_Head = (unsigned int)DeviceReadHead;
+
+            // based on the device read position we can calculate
+            // how many positions in the ring are free
+            if (Ring_p->IN_Tail < Device_IN_Head)
+            {
+                // we have wrapped around
+                // available space is between the two
+                A = Device_IN_Head - Ring_p->IN_Tail;
+            }
+            else
+            {
+                // used positions are between the two pointers
+                // rest is free
+                A = Ring_p->IN_Size - (Ring_p->IN_Tail - Device_IN_Head);
+            }
+
+            // avoid filling the entire ring
+            // so we can differentiate full from empty
+            if (A != 0)
+                A--;
+        }
+    }
+    else
+    {
+        // combined rings
+
+        // Critical: we have to be careful not to read the OUT_Head more
+        //           than one, since it might change in between!
+        unsigned int OUT_Head_copy = Ring_p->OUT_Head;
+
+        // we can write descriptors up to the point where we expect the
+        // result descriptors
+        if (Ring_p->IN_Tail < OUT_Head_copy)
+        {
+            // used positions are around the wrap point
+            // free positions are between the pointers
+            A = OUT_Head_copy - Ring_p->IN_Tail;
+        }
+        else
+        {
+            // used positions are between the two pointers
+            // rest is free
+            A = Ring_p->IN_Size - (Ring_p->IN_Tail - OUT_Head_copy);
+        }
+
+        // avoid filling the entire ring
+        // so we can differentiate full from empty
+        // (when it contains all commands or all results)
+        if (A != 0)
+            A--;
+    }
+
+    // limit based on provided descriptors
+    A = MIN(A, DescriptorCount);
+
+    // limit for sequential writing
+    N = MIN(A, (int)(Ring_p->IN_Size - Ring_p->IN_Tail));
+
+    // bail out early if there is no space
+    if (N == 0)
+    {
+        return 0;       // ## RETURN ##
+    }
+
+    W1 = Ring_p->CB.WriteFunc_p(  //EIP93_WriteCB in eip93_arm.c
+                        Ring_p->CB.CallbackParam1_p,
+                        Ring_p->CB.CallbackParam2,
+                        /*WriteIndex:*/Ring_p->IN_Tail,
+                        /*WriteCount:*/N,
+                        /*AvailableSpace*/A,
+                        Descriptors_p,
+                        DescriptorCount,
+                        /*SkipCount:*/0);
+
+    if (W1 <= 0)
+    {
+        //  0: no descriptors could be added
+        // <0: failure
+        return W1;      // ## RETURN ##
+    }
+
+    if (W1 == N &&
+        W1 < DescriptorCount &&
+        A > N)
+    {
+        // we have written all possible positions up to the end of the ring
+        // now write the rest
+        N = A - N;
+
+        W2 = Ring_p->CB.WriteFunc_p(
+                            Ring_p->CB.CallbackParam1_p,
+                            Ring_p->CB.CallbackParam2,
+                            /*WriteIndex:*/0,
+                            /*WriteCount:*/N,
+                            /*AvailableSpace*/N,
+                            Descriptors_p,
+                            DescriptorCount,
+                            /*SkipCount:*/W1);
+
+        if (W2 < 0)
+        {
+            // failure
+            return W2;      // ## RETURN ##
+        }
+    }
+
+    // now update the position for the next write
+    {
+        unsigned int i = Ring_p->IN_Tail + W1 + W2;
+
+        // do not use % operator to avoid costly divisions
+        if (i >= Ring_p->IN_Size)
+            i -= Ring_p->IN_Size;
+
+        Ring_p->IN_Tail = i;
+    }
+
+    // return how many descriptors were added
+    return W1 + W2;
+}
+
+
+/*----------------------------------------------------------------------------
+ * RingHelper_Get
+ *
+ * This routine retrieves a number of descriptors from the result ring
+ * specified.
+ *
+ * See header file for function specification.
+ */
+int
+RingHelper_Get(
+        RingHelper_t * const Ring_p,
+        const int ReadyCount,
+        void * Descriptors_p,
+        const int DescriptorsLimit)
+{
+    int A, N;
+    int R1, R2;
+
+    R1 = R2 = 0;
+
+    if (Ring_p == NULL ||
+        Descriptors_p == NULL ||
+        DescriptorsLimit < 0)
+    {
+        return -1;
+    }
+
+    if (DescriptorsLimit == 0 ||
+        ReadyCount == 0)
+    {
+        // no space in output buffer
+        // or no descriptors ready
+        return 0;
+    }
+
+    // calculate the maximum number of descriptors that can be retrieved
+    // sequentially from this read position, taking into account the
+    // DescriptorsLimit and the ReadyCount (if available)
+
+    // A = entries in result ring from read position till end
+    A = Ring_p->OUT_Size - Ring_p->OUT_Head;
+
+    N = MIN(A, DescriptorsLimit);
+
+    if (ReadyCount > 0)
+        N = MIN(N, ReadyCount);
+
+    // now retrieve this number of descriptors
+    R1 = Ring_p->CB.ReadFunc_p( //EIP93_ReadCB
+                        Ring_p->CB.CallbackParam1_p,
+                        Ring_p->CB.CallbackParam2,
+                        /*ReadIndex:*/Ring_p->OUT_Head,
+                        /*ReadLimit:*/N,
+                        Descriptors_p,
+                        /*SkipCount:*/0);
+
+    if (R1 <= 0)
+    {
+        //  0: if we got nothing on the first call, we can stop here
+        // <0: error while reading
+        //     this means we cannot maintain read synchronization
+
+        return R1;      // ## RETURN ##
+    }
+
+    // if we got the maximum, we can try to read more
+    // after wrapping to the start of the buffer
+    if (R1 == N &&
+        R1 < DescriptorsLimit &&
+        R1 != ReadyCount)
+    {
+        // A = number of entries in ring up to previous read-start position
+        A = Ring_p->OUT_Head;
+
+        N = MIN(A, DescriptorsLimit - R1);
+
+        if (ReadyCount > 0)
+            N = MIN(N, ReadyCount - R1);
+
+        R2 = Ring_p->CB.ReadFunc_p(
+                            Ring_p->CB.CallbackParam1_p,
+                            Ring_p->CB.CallbackParam2,
+                            /*ReadIndex:*/0,        // start of buffer
+                            /*ReadLimit:*/N,
+                            Descriptors_p,
+                            /*SkipCount:*/R1);
+
+        if (R2 < 0)
+        {
+            // failure
+            return R2;      // ## RETURN ##
+        }
+    }
+
+    // now update the position for the next read
+    {
+        unsigned int i = Ring_p->OUT_Head + R1 + R2;
+
+        // do not use % operator to avoid costly divisions
+        if (i >= Ring_p->OUT_Size)
+            i -= Ring_p->OUT_Size;
+
+        Ring_p->OUT_Head = i;
+    }
+
+    // return the number of descriptors read
+    return R1 + R2;
+}
+
diff --git a/drivers/net/cryptoDriver/source/utils/mtk_sLib.c b/drivers/net/cryptoDriver/source/utils/mtk_sLib.c
new file mode 100755
index 0000000..fd1bc89
--- /dev/null
+++ b/drivers/net/cryptoDriver/source/utils/mtk_sLib.c
@@ -0,0 +1,453 @@
+#include "mtk_baseDefs.h"      // uint8_t, IDENTIFIER_NOT_USED, etc.
+#include "mtk_cLib.h"                   // C Lib API
+#include "mtk_hwAccess.h"              // HW access API
+#include "mtk_eip93.h"                // the API we will implement
+#include "mtk_cEip93.h"              // configration options
+#include "mtk_L0.h"         // macros and functions to access EIP93 reg
+
+#include "mtk_prngL0.h"    // macros and functions to access PRNG_CTRL
+#include "mtk_internal.h"       // internal API
+#include "mtk_descp.h"     // the Descriptor API we also implement
+
+#ifdef EIP93_STRICT_ARGS
+
+#define EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL \
+    EIP93_Status_t res = EIP93_STATUS_OK; \
+    EIP93_Device_t* Device_p = NULL; \
+    EIP93_ARM_Mode_t* ARM_p = NULL; \
+    EIP93_DHM_Mode_t* DHM_p = NULL; \
+    EIP93_CHECK_POINTER(IOArea_p); \
+    Device_p = (EIP93_Device_t*)IOArea_p; \
+    ARM_p = &Device_p->extras.ARM_mode; \
+    DHM_p = &Device_p->extras.DHM_mode; \
+    IDENTIFIER_NOT_USED(ARM_p);   \
+    IDENTIFIER_NOT_USED(DHM_p);
+
+#else
+
+#define EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL \
+    EIP93_Status_t res = EIP93_STATUS_OK; \
+    EIP93_Device_t* Device_p = (EIP93_Device_t*)IOArea_p; \
+    EIP93_ARM_Mode_t* ARM_p = &Device_p->extras.ARM_mode; \
+    EIP93_DHM_Mode_t* DHM_p = &Device_p->extras.DHM_mode; \
+    IDENTIFIER_NOT_USED(ARM_p); \
+    IDENTIFIER_NOT_USED(DHM_p);
+
+#endif //EIP93_STRICT_ARGS
+
+/* Function to Set the PRNG is auto mode */
+static inline void
+EIP93_Internal_PRNG_Activate(
+        const HWPAL_Device_t Device,
+        bool IsInit)
+{
+    if(IsInit == true)
+    {
+        EIP93_Write32_PRNG_SEED_0(Device, EIP93_SEED_0);
+        EIP93_Write32_PRNG_SEED_1(Device, EIP93_SEED_1);
+        EIP93_Write32_PRNG_SEED_2(Device, EIP93_SEED_2);
+        EIP93_Write32_PRNG_SEED_3(Device, EIP93_SEED_3);
+
+        EIP93_Write32_PRNG_KEY_0(Device, EIP93_KEY_0);
+        EIP93_Write32_PRNG_KEY_1(Device, EIP93_KEY_1);
+        EIP93_Write32_PRNG_KEY_2(Device, EIP93_KEY_2);
+        EIP93_Write32_PRNG_KEY_3(Device, EIP93_KEY_3);
+
+        EIP93_Write32_PRNG_LFSR_0(Device, EIP93_LFSR_0);
+        EIP93_Write32_PRNG_LFSR_1(Device, EIP93_LFSR_1);
+    }
+
+    EIP93_Write32_PRNG_CTRL(Device,
+            EIP93_PRNG_MANUAL_OFF,
+            EIP93_PRNG_AUTO_ON,
+            EIP93_PRNG_RESULT64);
+}
+
+/*----------------------------------------------------------------------------
+ * EIP93_HWRevision_Get
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_HWRevision_Get(
+        EIP93_IOArea_t * const  IOArea_p,
+        EIP93_Capabilities_t * const Capabilities_p)
+{
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_POINTER(Capabilities_p);
+
+    EIP93_Read32_PE_OPTIONS_1(Device_p->Device,
+            &(Capabilities_p->fDesTdes),
+            &(Capabilities_p->fARC4),
+            &(Capabilities_p->fAes),
+            &(Capabilities_p->fAes128),
+            &(Capabilities_p->fAes192),
+            &(Capabilities_p->fAes256),
+            &(Capabilities_p->fKasumiF8),
+            &(Capabilities_p->fDesOfgCfb),
+            &(Capabilities_p->fAesCfb),
+            &(Capabilities_p->fMd5),
+            &(Capabilities_p->fSha1),
+            &(Capabilities_p->fSha224),
+            &(Capabilities_p->fSha256),
+            &(Capabilities_p->fSha384),
+            &(Capabilities_p->fSha512),
+            &(Capabilities_p->fKasumiF9),
+            &(Capabilities_p->fAesXcbc),
+            &(Capabilities_p->fGcm),
+            &(Capabilities_p->fGmac),
+            &(Capabilities_p->fAesCbcMac),
+            &(Capabilities_p->fAesCbcMac128),
+            &(Capabilities_p->fAesCbcMac192),
+            &(Capabilities_p->fAesCbcMac256));
+
+    EIP93_Read32_PE_OPTIONS_0(Device_p->Device,
+            &(Capabilities_p->IntFaceType),
+            &(Capabilities_p->f64BitAddress),
+            &(Capabilities_p->fExtInterrupt),
+            &(Capabilities_p->fPrng),
+            &(Capabilities_p->fSARev1),
+            &(Capabilities_p->fSARev2),
+            &(Capabilities_p->fDynamicSA),
+            &(Capabilities_p->fEsn),
+            &(Capabilities_p->fEsp),
+            &(Capabilities_p->fAh),
+            &(Capabilities_p->fSsl),
+            &(Capabilities_p->fTls),
+            &(Capabilities_p->fDtls),
+            &(Capabilities_p->fSrtp),
+            &(Capabilities_p->fMacsec));
+
+    EIP93_Read32_REVISION_REG(Device_p->Device,
+            &(Capabilities_p->EipNumber),
+            &(Capabilities_p->ComplmtEipNumber),
+            &(Capabilities_p->HWPatchLevel),
+            &(Capabilities_p->MinHWRevision),
+            &(Capabilities_p->MajHWRevision));
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+/*----------------------------------------------------------------------------
+ * EIP93_Initialize
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_Initialize(
+        EIP93_IOArea_t * const IOArea_p,
+        const HWPAL_Device_t Device)
+{
+    uint8_t EipNumber = 0;
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_DEVICE_IS_RESET;
+
+    memset(Device_p, 0, sizeof(EIP93_Device_t));
+    Device_p->Device = Device;
+
+    HWPAL_Device_Init(Device);
+
+    // reset the the Packet Engine
+    EIP93_Write32_PE_CFG(Device_p->Device,
+              1, // Rst PE: yes
+              1, // Reset PDR: yes
+              0, 0, 0, 0, 0, 0 );
+
+    // Start: Do the device communication test
+    // Read the EIP number and see that it matches the expected "0x5E"
+    EIP93_Read32_REVISION_REG(Device, &EipNumber, NULL, NULL, NULL, NULL);
+    if(EipNumber != 0x5D)
+    {
+#ifdef RT_EIP93_DRIVER_DEBUG
+        printk("EipNumber: %d\n", EipNumber);
+#endif
+        return EIP93_ERROR_BAD_ARGUMENT;
+    }
+
+    // Initilaize the PRNG in AUTO Mode
+    EIP93_Internal_PRNG_Activate(Device_p->Device, true);
+
+    // Initialize the BYTE_ORDER_CFG register
+    EIP93_Write32_MST_BYTE_ORDER_CFG(Device,
+            (uint8_t) EIP93_BYTE_ORDER_PD,
+            (uint8_t) EIP93_BYTE_ORDER_SA,
+            (uint8_t) EIP93_BYTE_ORDER_DATA,
+            (uint8_t) EIP93_BYTE_ORDER_TD);
+
+    // Initialize the INT_CFG register
+    EIP93_Write32_INT_CFG(Device,
+        (uint8_t)(EIP93_INT_HOST_OUTPUT_TYPE ? 1 : 0),
+        (uint8_t)((EIP93_INT_HOST_OUTPUT_TYPE > 0) ?
+        (EIP93_INT_PULSE_CLEAR > 0 ? 1 : 0) : 0));
+
+     // Clock Control, must for DHM, optional for ARM
+     EIP93_Write32(Device, 0X1E8, 0x1 );
+    Device_p->CurrentMode = EIP93_MODE_INITIALIZED;
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_Deactivate
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_Deactivate(
+        EIP93_IOArea_t * const IOArea_p)
+{
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_DEVICE_IS_NOT_RESET;
+
+    if (Device_p->CurrentMode == EIP93_MODE_ARM)
+    {
+        // clean the ARM IOArea
+        memset(ARM_p, 0, sizeof(*ARM_p));
+        // reset the the Packet Descriptor Ring state machine
+        EIP93_Write32_PE_CFG(Device_p->Device,
+                             1, // Rst PE: Yes
+                             1, // Reset PDR: yes
+                             0, 0, 0, 0, 0, 0 );
+
+    }
+    else if (Device_p->CurrentMode == EIP93_MODE_DHM)
+        {
+            // clean the ARM IOArea
+            memset(ARM_p, 0, sizeof(*DHM_p));
+        EIP93_Write32_PE_CFG(Device_p->Device,
+                             1, // Rst PE: Yes
+                             0, // Reset PDR:No
+                             0, 0, 0, 0, 0, 0 );
+
+        }
+
+
+    // change the mode
+    Device_p->CurrentMode = EIP93_MODE_INITIALIZED;
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_Shutdown
+ *
+ *  See header file for function specification.
+ */
+EIP93_Status_t
+EIP93_Shutdown(
+        EIP93_IOArea_t * const IOArea_p)
+{
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+
+
+     // De-Initilaize the PRNG from AUTO Mode
+     EIP93_Internal_PRNG_Activate(Device_p->Device, false);
+
+
+
+    if (Device_p->CurrentMode == EIP93_MODE_ARM
+        || Device_p->CurrentMode == EIP93_MODE_DHM
+       )
+    {
+        EIP93_Deactivate(IOArea_p);
+    }
+
+    if (Device_p->CurrentMode == EIP93_MODE_INITIALIZED)
+    {
+        // reset the the Packet Engine
+        EIP93_Write32_PE_CFG(Device_p->Device,
+                             1, // Rst PE: yes
+                             1, // Reset PDR: yes
+                             0, 0, 0, 0, 0, 0);
+        // clean the device IOArea
+        memset(Device_p, 0, sizeof(*Device_p));
+    }
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+
+/*----------------------------------------------------------------------------
+ *                      Descriptor Helper functions API
+ *----------------------------------------------------------------------------
+ */
+
+/*----------------------------------------------------------------------------
+ * EIP93_CommandDescriptor_Control_MakeWord
+ *
+ * See eip93_descriptor.h header file for description.
+ */
+uint32_t
+EIP93_CommandDescriptor_Control_MakeWord(
+        const EIP93_CommandDescriptor_Control_t * const  CommandCtrl_p)
+{
+    uint32_t word = 0;
+    word |= CommandCtrl_p->PadControl << 24;
+    word |= CommandCtrl_p->NextHeaderValue << 8;
+    word |= (CommandCtrl_p->fHashFinal ? 1 : 0) << 4;
+    return word;
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_ResultDescriptor_Status_InterpretWord
+ *
+ * See eip93_descriptor.h header file for description.
+ */
+void
+EIP93_ResultDescriptor_Status_InterpretWord(
+        const uint32_t StatusWord,
+        EIP93_ResultDescriptor_Status_t * const  ResultStatus_p)
+{
+    ResultStatus_p->RawStatus = (StatusWord >> 16) &  (BIT_8-1);
+    ResultStatus_p->PadStatus = (StatusWord >> 24) &  (BIT_8-1);
+    ResultStatus_p->PadValue = (StatusWord >> 8) &  (BIT_8-1);
+    ResultStatus_p->ExtendedErrorCode =
+            (ResultStatus_p->RawStatus >> 4) & (BIT_4-1);
+    ResultStatus_p->fErrorORNotificationValid =
+            (ResultStatus_p->RawStatus >> 3) & 1;
+    ResultStatus_p->fSequenceNumberFail =
+            (ResultStatus_p->RawStatus >> 2) & 1;
+    ResultStatus_p->fCryptoPadFail =
+            (ResultStatus_p->RawStatus >> 1) & 1;
+    ResultStatus_p->fAuthenticationFail =
+            ResultStatus_p->RawStatus & 1;
+}
+
+
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_Mask
+ */
+
+EIP93_Status_t
+EIP93_INT_Mask(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_INT_SourceBitmap_t WhichIntSources)
+
+{
+
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_VALID_INTERRUPT(WhichIntSources);
+
+    EIP93_Write32(
+                 Device_p->Device,
+                 EIP93_REG_MASK_DISABLE,
+                 WhichIntSources);
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_UnMask
+ */
+
+EIP93_Status_t
+EIP93_INT_UnMask(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_INT_SourceBitmap_t WhichIntSources)
+
+{
+
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_VALID_INTERRUPT(WhichIntSources);
+    EIP93_Write32(
+                 Device_p->Device,
+                 EIP93_REG_MASK_ENABLE,
+                 WhichIntSources);
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+}
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_IsRawActive
+ */
+
+EIP93_Status_t
+EIP93_INT_IsRawActive(
+        EIP93_IOArea_t * const IOArea_p,
+        EIP93_INT_SourceBitmap_t * const PendingIntSources_p)
+{
+
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_POINTER(PendingIntSources_p);
+    *PendingIntSources_p = EIP93_Read32(
+                                   Device_p->Device,
+                                   EIP93_REG_INT_UNMASK_STAT);
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+
+
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_IsActive
+ */
+
+EIP93_Status_t
+EIP93_INT_IsActive(
+        EIP93_IOArea_t * const IOArea_p,
+        EIP93_INT_SourceBitmap_t * const PendingIntSources_p)
+{
+
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_POINTER(PendingIntSources_p);
+
+    *PendingIntSources_p = EIP93_Read32(
+                                   Device_p->Device,
+                                   EIP93_REG_INT_MASK_STAT);
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_Acknowledge
+ */
+
+EIP93_Status_t
+EIP93_INT_Acknowledge(
+        EIP93_IOArea_t * const IOArea_p,
+        const EIP93_INT_SourceBitmap_t WhichIntSources)
+{
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+    EIP93_CHECK_VALID_INTERRUPT(WhichIntSources);
+
+    EIP93_Write32(
+                 Device_p->Device,
+                 EIP93_REG_INT_CLR,
+                 WhichIntSources);
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+
+}
+
+
+/*----------------------------------------------------------------------------
+ * EIP93_INT_Configure
+ */
+EIP93_Status_t
+EIP93_INT_Configure(
+        EIP93_IOArea_t * const IOArea_p,
+        const bool fPulsed,
+    const bool fAutoClear)
+{
+
+
+    EIP93_INSERTCODE_FUNCTION_ENTRY_CODE_SL;
+
+    EIP93_Write32_INT_CFG(
+                    Device_p->Device,
+                    fPulsed ? 1 : 0,
+                    fAutoClear ? 1 : 0);
+
+    EIP93_INSERTCODE_FUNCTION_EXIT_CODE;
+
+}
+
+
diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c
index dcaed0c..427e1cd 100644
--- a/net/xfrm/xfrm_output.c
+++ b/net/xfrm/xfrm_output.c
@@ -24,7 +24,7 @@
 
 static int xfrm_output2(struct sk_buff *skb);
 
-static int xfrm_skb_check_space(struct sk_buff *skb)
+int xfrm_skb_check_space(struct sk_buff *skb)
 {
 	struct dst_entry *dst = skb_dst(skb);
 	int nhead = dst->header_len + LL_RESERVED_SPACE(dst->dev)
@@ -41,7 +41,7 @@ static int xfrm_skb_check_space(struct sk_buff *skb)
 	return pskb_expand_head(skb, nhead, ntail, GFP_ATOMIC);
 }
 
-static int xfrm_output_one(struct sk_buff *skb, int err)
+int xfrm_output_one(struct sk_buff *skb, int err)
 {
 	struct dst_entry *dst = skb_dst(skb);
 	struct xfrm_state *x = dst->xfrm;
@@ -243,4 +243,6 @@ int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb)
 }
 
 EXPORT_SYMBOL_GPL(xfrm_output);
+EXPORT_SYMBOL_GPL(xfrm_output_one);
+EXPORT_SYMBOL_GPL(xfrm_skb_check_space);
 EXPORT_SYMBOL_GPL(xfrm_inner_extract_output);
